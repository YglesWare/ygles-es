[
    {
        "name": "array-callback-return",
        "url": "https://eslint.org/docs/latest/rules/array-callback-return",
        "description": "Enforce return statements in callbacks of array methodsArray has several methods for filtering, mapping, and folding. If we forget to write return statement in a callback of those, it’s probably a mistake. If you don’t want to use a return or don’t need the returned results, consider using .forEach instead.This rule enforces usage of return statement in callbacks of array’s methods. Additionally, it may also enforce the forEach array method callback to not return a value by using the checkForEach option.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint array-callback-return: \"error\"*/\n\nvar indexMap = myArray.reduce(function(memo, item, index) {\n    memo[item] = index;\n}, {});\n\nvar foo = Array.from(nodes, function(node) {\n    if (node.tagName === \"DIV\") {\n        return true;\n    }\n});\n\nvar bar = foo.filter(function(x) {\n    if (x) {\n        return true;\n    } else {\n        return;\n    }\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint array-callback-return: \"error\"*/\n\nvar indexMap = myArray.reduce(function(memo, item, index) {\n    memo[item] = index;\n    return memo;\n}, {});\n\nvar foo = Array.from(nodes, function(node) {\n    if (node.tagName === \"DIV\") {\n        return true;\n    }\n    return false;\n});\n\nvar bar = foo.map(node => node.getAttribute(\"id\"));"
            },
            {
                "type": "correct",
                "content": "/*eslint array-callback-return: [\"error\", { allowImplicit: true }]*/\nvar undefAllTheThings = myArray.map(function(item) {\n    return;\n});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-callback-return: [\"error\", { checkForEach: true }]*/\n\nmyArray.forEach(function(item) {\n    return handleItem(item)\n});\n\nmyArray.forEach(function(item) {\n    if (item < 0) {\n        return x;\n    }\n    handleItem(item);\n});\n\nmyArray.forEach(item => handleItem(item));\n\nmyArray.forEach(item => {\n    return handleItem(item);\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint array-callback-return: [\"error\", { checkForEach: true }]*/\n\nmyArray.forEach(function(item) {\n    handleItem(item)\n});\n\nmyArray.forEach(function(item) {\n    if (item < 0) {\n        return;\n    }\n    handleItem(item);\n});\n\nmyArray.forEach(function(item) {\n    handleItem(item);\n    return;\n});\n\nmyArray.forEach(item => {\n    handleItem(item);\n});"
            }
        ]
    },
    {
        "name": "constructor-super",
        "url": "https://eslint.org/docs/latest/rules/constructor-super",
        "description": "Require super() calls in constructorsConstructors of derived classes must call super(). Constructors of non derived classes must not call super(). If this is not observed, the JavaScript engine will raise a runtime error.This rule checks whether or not there is a valid super() call.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint constructor-super: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    constructor() {\n        super();  // This is a SyntaxError.\n    }\n}\n\nclass A extends B {\n    constructor() { }  // Would throw a ReferenceError.\n}\n\n// Classes which inherits from a non constructor are always problems.\nclass A extends null {\n    constructor() {\n        super();  // Would throw a TypeError.\n    }\n}\n\nclass A extends null {\n    constructor() { }  // Would throw a ReferenceError.\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint constructor-super: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    constructor() { }\n}\n\nclass A extends B {\n    constructor() {\n        super();\n    }\n}"
            }
        ]
    },
    {
        "name": "for-direction",
        "url": "https://eslint.org/docs/latest/rules/for-direction",
        "description": "Enforce \"for\" loop update clause moving the counter in the right direction.A for loop with a stop condition that can never be reached, such as one with a counter that moves in the wrong direction, will run infinitely. While there are occasions when an infinite loop is intended, the convention is to construct such loops as while loops. More typically, an infinite for loop is a bug.Examples of incorrect code for this rule:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint for-direction: \"error\"*/\nfor (var i = 0; i < 10; i--) {\n}\n\nfor (var i = 10; i >= 0; i++) {\n}\n\nfor (var i = 0; i > 10; i++) {\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint for-direction: \"error\"*/\nfor (var i = 0; i < 10; i++) {\n}"
            }
        ]
    },
    {
        "name": "getter-return",
        "url": "https://eslint.org/docs/latest/rules/getter-return",
        "description": "Enforce return statements in gettersThe get syntax binds an object property to a function that will be called when that property is looked up. It was first introduced in ECMAScript 5:Note that every getter is expected to return a value.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint getter-return: \"error\"*/\n\np = {\n    get name(){\n        // no returns.\n    }\n};\n\nObject.defineProperty(p, \"age\", {\n    get: function (){\n        // no returns.\n    }\n});\n\nclass P{\n    get name(){\n        // no returns.\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint getter-return: \"error\"*/\n\np = {\n    get name(){\n        return \"nicholas\";\n    }\n};\n\nObject.defineProperty(p, \"age\", {\n    get: function (){\n        return 18;\n    }\n});\n\nclass P{\n    get name(){\n        return \"nicholas\";\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint getter-return: [\"error\", { allowImplicit: true }]*/\np = {\n    get name(){\n        return; // return undefined implicitly.\n    }\n};"
            }
        ]
    },
    {
        "name": "no-async-promise-executor",
        "url": "https://eslint.org/docs/latest/rules/no-async-promise-executor",
        "description": "Disallow using an async function as a Promise executorThe new Promise constructor accepts an executor function as an argument, which has resolve and reject parameters that can be used to control the state of the created Promise. For example:The executor function can also be an async function. However, this is usually a mistake, for a few reasons:",
        "examples": [
            {
                "type": "incorrect",
                "content": "const foo = new Promise(async (resolve, reject) => {\n  readFile('foo.txt', function(err, result) {\n    if (err) {\n      reject(err);\n    } else {\n      resolve(result);\n    }\n  });\n});\n\nconst result = new Promise(async (resolve, reject) => {\n  resolve(await foo);\n});"
            },
            {
                "type": "correct",
                "content": "const foo = new Promise((resolve, reject) => {\n  readFile('foo.txt', function(err, result) {\n    if (err) {\n      reject(err);\n    } else {\n      resolve(result);\n    }\n  });\n});\n\nconst result = Promise.resolve(foo);"
            }
        ]
    },
    {
        "name": "no-await-in-loop",
        "url": "https://eslint.org/docs/latest/rules/no-await-in-loop",
        "description": "Disallow await inside of loopsPerforming an operation on each element of an iterable is a common task. However, performing an await as part of each operation is an indication that the program is not taking full advantage of the parallelization benefits of async/await.Usually, the code should be refactored to create all the promises at once, then get access to the results using Promise.all(). Otherwise, each successive operation will not start until the previous one has completed.",
        "examples": [
            {
                "type": "correct",
                "content": "/*eslint no-await-in-loop: \"error\"*/\n\nasync function foo(things) {\n  const results = [];\n  for (const thing of things) {\n    // Good: all asynchronous operations are immediately started.\n    results.push(bar(thing));\n  }\n  // Now that all the asynchronous operations are running, here we wait until they all complete.\n  return baz(await Promise.all(results));\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-await-in-loop: \"error\"*/\n\nasync function foo(things) {\n  const results = [];\n  for (const thing of things) {\n    // Bad: each loop iteration is delayed until the entire asynchronous operation completes\n    results.push(await bar(thing));\n  }\n  return baz(results);\n}"
            }
        ]
    },
    {
        "name": "no-class-assign",
        "url": "https://eslint.org/docs/latest/rules/no-class-assign",
        "description": "Disallow reassigning class membersClassDeclaration creates a variable, and we can modify the variable.But the modification is a mistake in most cases.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nclass A { }\nA = 0;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nA = 0;\nclass A { }"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    b() {\n        A = 0;\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nlet A = class A {\n    b() {\n        A = 0;\n        // `let A` is shadowed by the class name.\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nlet A = class A { }\nA = 0; // A is a variable."
            },
            {
                "type": "correct",
                "content": "/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nlet A = class {\n    b() {\n        A = 0; // A is a variable.\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-class-assign: 2*/\n/*eslint-env es6*/\n\nclass A {\n    b(A) {\n        A = 0; // A is a parameter.\n    }\n}"
            }
        ]
    },
    {
        "name": "no-compare-neg-zero",
        "url": "https://eslint.org/docs/latest/rules/no-compare-neg-zero",
        "description": "Disallow comparing against -0The rule should warn against code that tries to compare against -0, since that will not work as intended. That is, code like x === -0 will pass for both +0 and -0. The author probably intended Object.is(x, -0).Examples of incorrect code for this rule:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint no-compare-neg-zero: \"error\" */\n\nif (x === -0) {\n    // doSomething()...\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint no-compare-neg-zero: \"error\" */\n\nif (x === 0) {\n    // doSomething()...\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint no-compare-neg-zero: \"error\" */\n\nif (Object.is(x, -0)) {\n    // doSomething()...\n}"
            }
        ]
    },
    {
        "name": "no-cond-assign",
        "url": "https://eslint.org/docs/latest/rules/no-cond-assign",
        "description": "Disallow assignment operators in conditional expressionsIn conditional statements, it is very easy to mistype a comparison operator (such as ==) as an assignment operator (such as =). For example:There are valid reasons to use assignment operators in conditional statements. However, it can be difficult to tell whether a specific assignment was intentional.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-cond-assign: \"error\"*/\n\n// Unintentional assignment\nvar x;\nif (x = 0) {\n    var b = 1;\n}\n\n// Practical example that is similar to an error\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while (someNode = someNode.parentNode);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-cond-assign: \"error\"*/\n\n// Assignment replaced by comparison\nvar x;\nif (x === 0) {\n    var b = 1;\n}\n\n// Practical example that wraps the assignment in parentheses\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode));\n}\n\n// Practical example that wraps the assignment and tests for 'null'\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode) !== null);\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-cond-assign: [\"error\", \"always\"]*/\n\n// Unintentional assignment\nvar x;\nif (x = 0) {\n    var b = 1;\n}\n\n// Practical example that is similar to an error\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while (someNode = someNode.parentNode);\n}\n\n// Practical example that wraps the assignment in parentheses\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode));\n}\n\n// Practical example that wraps the assignment and tests for 'null'\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode) !== null);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-cond-assign: [\"error\", \"always\"]*/\n\n// Assignment replaced by comparison\nvar x;\nif (x === 0) {\n    var b = 1;\n}"
            }
        ]
    },
    {
        "name": "no-const-assign",
        "url": "https://eslint.org/docs/latest/rules/no-const-assign",
        "description": "Disallow reassigning const variablesWe cannot modify variables that are declared using const keyword. It will raise a runtime error.Under non ES2015 environment, it might be ignored merely.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\na = 1;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\na += 1;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\n++a;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\nconsole.log(a);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nfor (const a in [1, 2, 3]) { // `a` is re-defined (not modified) on each loop step.\n    console.log(a);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nfor (const a of [1, 2, 3]) { // `a` is re-defined (not modified) on each loop step.\n    console.log(a);\n}"
            }
        ]
    },
    {
        "name": "no-constant-binary-expression",
        "url": "https://eslint.org/docs/latest/rules/no-constant-binary-expression",
        "description": "Disallow expressions where the operation doesn't affect the valueComparisons which will always evaluate to true or false and logical expressions (||, &&, ??) which either always short-circuit or never short-circuit are both likely indications of programmer error.These errors are especially common in complex expressions where operator precedence is easy to misjudge. For example:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-constant-binary-expression: \"error\"*/\n\nconst value1 = +x == null;\n\nconst value2 = condition ? x : {} || DEFAULT;\n\nconst value3 = !foo == null;\n\nconst value4 = new Boolean(foo) === true;\n\nconst objIsEmpty = someObj === {};\n\nconst arrIsEmpty = someArr === [];"
            },
            {
                "type": "correct",
                "content": "/*eslint no-constant-binary-expression: \"error\"*/\n\nconst value1 = x == null;\n\nconst value2 = (condition ? x : {}) || DEFAULT;\n\nconst value3 = !(foo == null);\n\nconst value4 = Boolean(foo) === true;\n\nconst objIsEmpty = Object.keys(someObj).length === 0;\n\nconst arrIsEmpty = someArr.length === 0;"
            }
        ]
    },
    {
        "name": "no-constant-condition",
        "url": "https://eslint.org/docs/latest/rules/no-constant-condition",
        "description": "Disallow constant expressions in conditionsA constant expression (for example, a literal) as a test condition might be a typo or development trigger for a specific behavior. For example, the following code looks as if it is not ready for production.This rule disallows constant expressions in the test condition of:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-constant-condition: \"error\"*/\n\nif (false) {\n    doSomethingUnfinished();\n}\n\nif (void x) {\n    doSomethingUnfinished();\n}\n\nif (x &&= false) {\n    doSomethingNever();\n}\n\nif (class {}) {\n    doSomethingAlways();\n}\n\nif (new Boolean(x)) {\n    doSomethingAlways();\n}\n\nif (Boolean(1)) {\n    doSomethingAlways();\n}\n\nif (undefined) {\n    doSomethingUnfinished();\n}\n\nif (x ||= true) {\n    doSomethingAlways();\n}\n\nfor (;-2;) {\n    doSomethingForever();\n}\n\nwhile (typeof x) {\n    doSomethingForever();\n}\n\ndo {\n    doSomethingForever();\n} while (x = -1);\n\nvar result = 0 ? a : b;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-constant-condition: \"error\"*/\n\nif (x === 0) {\n    doSomething();\n}\n\nfor (;;) {\n    doSomethingForever();\n}\n\nwhile (typeof x === \"undefined\") {\n    doSomething();\n}\n\ndo {\n    doSomething();\n} while (x);\n\nvar result = x !== 0 ? a : b;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\nwhile (true) {\n    doSomething();\n    if (condition()) {\n        break;\n    }\n};\n\nfor (;true;) {\n    doSomething();\n    if (condition()) {\n        break;\n    }\n};\n\ndo {\n    doSomething();\n    if (condition()) {\n        break;\n    }\n} while (true)"
            }
        ]
    },
    {
        "name": "no-constructor-return",
        "url": "https://eslint.org/docs/latest/rules/no-constructor-return",
        "description": "Disallow returning value from constructorIn JavaScript, returning a value in the constructor of a class may be a mistake. Forbidding this pattern prevents mistakes resulting from unfamiliarity with the language or a copy-paste error.This rule disallows return statements in the constructor of a class. Note that returning nothing with flow control is allowed.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-constructor-return: \"error\"*/\n\nclass A {\n    constructor(a) {\n        this.a = a;\n        return a;\n    }\n}\n\nclass B {\n    constructor(f) {\n        if (!f) {\n            return 'falsy';\n        }\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-constructor-return: \"error\"*/\n\nclass C {\n    constructor(c) {\n        this.c = c;\n    }\n}\n\nclass D {\n    constructor(f) {\n        if (!f) {\n            return;  // Flow control.\n        }\n\n        f();\n    }\n}"
            }
        ]
    },
    {
        "name": "no-control-regex",
        "url": "https://eslint.org/docs/latest/rules/no-control-regex",
        "description": "Disallow control characters in regular expressionsControl characters are special, invisible characters in the ASCII range 0-31. These characters are rarely used in JavaScript strings so a regular expression containing elements that explicitly match these characters is most likely a mistake.This rule disallows control characters and some escape sequences that match control characters in regular expressions.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-control-regex: \"error\"*/\n\nvar pattern1 = /\\x00/;\nvar pattern2 = /\\x0C/;\nvar pattern3 = /\\x1F/;\nvar pattern4 = /\\u000C/;\nvar pattern5 = /\\u{C}/u;\nvar pattern6 = new RegExp(\"\\x0C\"); // raw U+000C character in the pattern\nvar pattern7 = new RegExp(\"\\\\x0C\"); // \\x0C pattern"
            },
            {
                "type": "correct",
                "content": "/*eslint no-control-regex: \"error\"*/\n\nvar pattern1 = /\\x20/;\nvar pattern2 = /\\u0020/;\nvar pattern3 = /\\u{20}/u;\nvar pattern4 = /\\t/;\nvar pattern5 = /\\n/;\nvar pattern6 = new RegExp(\"\\x20\");\nvar pattern7 = new RegExp(\"\\\\t\");\nvar pattern8 = new RegExp(\"\\\\n\");"
            }
        ]
    },
    {
        "name": "no-debugger",
        "url": "https://eslint.org/docs/latest/rules/no-debugger",
        "description": "Disallow the use of debuggerThe debugger statement is used to tell the executing JavaScript environment to stop execution and start up a debugger at the current point in the code. This has fallen out of favor as a good practice with the advent of modern debugging and development tools. Production code should definitely not contain debugger, as it will cause the browser to stop executing code and open an appropriate debugger.This rule disallows debugger statements.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-debugger: \"error\"*/\n\nfunction isTruthy(x) {\n    debugger;\n    return Boolean(x);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-debugger: \"error\"*/\n\nfunction isTruthy(x) {\n    return Boolean(x); // set a breakpoint at this line\n}"
            }
        ]
    },
    {
        "name": "no-dupe-args",
        "url": "https://eslint.org/docs/latest/rules/no-dupe-args",
        "description": "Disallow duplicate arguments in function definitionsIf more than one parameter has the same name in a function definition, the last occurrence “shadows” the preceding occurrences. A duplicated name might be a typing error.This rule disallows duplicate parameter names in function declarations or expressions. It does not apply to arrow functions or class methods, because the parser reports the error.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-dupe-args: \"error\"*/\n\nfunction foo(a, b, a) {\n    console.log(\"value of the second a:\", a);\n}\n\nvar bar = function (a, b, a) {\n    console.log(\"value of the second a:\", a);\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-dupe-args: \"error\"*/\n\nfunction foo(a, b, c) {\n    console.log(a, b, c);\n}\n\nvar bar = function (a, b, c) {\n    console.log(a, b, c);\n};"
            }
        ]
    },
    {
        "name": "no-dupe-class-members",
        "url": "https://eslint.org/docs/latest/rules/no-dupe-class-members",
        "description": "Disallow duplicate class membersIf there are declarations of the same name in class members, the last declaration overwrites other declarations silently. It can cause unexpected behaviors.This rule is aimed to flag the use of duplicate names in class members.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-dupe-class-members: \"error\"*/\n\nclass Foo {\n  bar() { }\n  bar() { }\n}\n\nclass Foo {\n  bar() { }\n  get bar() { }\n}\n\nclass Foo {\n  bar;\n  bar;\n}\n\nclass Foo {\n  bar;\n  bar() { }\n}\n\nclass Foo {\n  static bar() { }\n  static bar() { }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-dupe-class-members: \"error\"*/\n\nclass Foo {\n  bar() { }\n  qux() { }\n}\n\nclass Foo {\n  get bar() { }\n  set bar(value) { }\n}\n\nclass Foo {\n  bar;\n  qux;\n}\n\nclass Foo {\n  bar;\n  qux() { }\n}\n\nclass Foo {\n  static bar() { }\n  bar() { }\n}"
            }
        ]
    },
    {
        "name": "no-dupe-else-if",
        "url": "https://eslint.org/docs/latest/rules/no-dupe-else-if",
        "description": "Disallow duplicate conditions in if-else-if chainsif-else-if chains are commonly used when there is a need to execute only one branch (or at most one branch) out of several possible branches, based on certain conditions.Two identical test conditions in the same chain are almost always a mistake in the code. Unless there are side effects in the expressions, a duplicate will evaluate to the same true or false value as the identical expression earlier in the chain, meaning that its branch can never execute.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-dupe-else-if: \"error\"*/\n\nif (isSomething(x)) {\n    foo();\n} else if (isSomething(x)) {\n    bar();\n}\n\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n} else if (c && d) {\n    baz();\n} else if (c && d) {\n    quux();\n} else {\n    quuux();\n}\n\nif (n === 1) {\n    foo();\n} else if (n === 2) {\n    bar();\n} else if (n === 3) {\n    baz();\n} else if (n === 2) {\n    quux();\n} else if (n === 5) {\n    quuux();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-dupe-else-if: \"error\"*/\n\nif (isSomething(x)) {\n    foo();\n} else if (isSomethingElse(x)) {\n    bar();\n}\n\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n} else if (c && d) {\n    baz();\n} else if (c && e) {\n    quux();\n} else {\n    quuux();\n}\n\nif (n === 1) {\n    foo();\n} else if (n === 2) {\n    bar();\n} else if (n === 3) {\n    baz();\n} else if (n === 4) {\n    quux();\n} else if (n === 5) {\n    quuux();\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-dupe-else-if: \"error\"*/\n\nif (a || b) {\n    foo();\n} else if (a) {\n    bar();\n}\n\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n} else if (a || b) {\n    baz();\n}\n\nif (a) {\n    foo();\n} else if (a && b) {\n    bar();\n}\n\nif (a && b) {\n    foo();\n} else if (a && b && c) {\n    bar();\n}\n\nif (a || b) {\n    foo();\n} else if (b && c) {\n    bar();\n}\n\nif (a) {\n    foo();\n} else if (b && c) {\n    bar();\n} else if (d && (c && e && b || a)) {\n    baz();\n}"
            }
        ]
    },
    {
        "name": "no-dupe-keys",
        "url": "https://eslint.org/docs/latest/rules/no-dupe-keys",
        "description": "Disallow duplicate keys in object literalsMultiple properties with the same key in object literals can cause unexpected behavior in your application.This rule disallows duplicate keys in object literals.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-dupe-keys: \"error\"*/\n\nvar foo = {\n    bar: \"baz\",\n    bar: \"qux\"\n};\n\nvar foo = {\n    \"bar\": \"baz\",\n    bar: \"qux\"\n};\n\nvar foo = {\n    0x1: \"baz\",\n    1: \"qux\"\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-dupe-keys: \"error\"*/\n\nvar foo = {\n    bar: \"baz\",\n    quxx: \"qux\"\n};"
            }
        ]
    },
    {
        "name": "no-duplicate-case",
        "url": "https://eslint.org/docs/latest/rules/no-duplicate-case",
        "description": "Disallow duplicate case labelsIf a switch statement has duplicate test expressions in case clauses, it is likely that a programmer copied a case clause but forgot to change the test expression.This rule disallows duplicate test expressions in case clauses of switch statements.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-duplicate-case: \"error\"*/\n\nvar a = 1,\n    one = 1;\n\nswitch (a) {\n    case 1:\n        break;\n    case 2:\n        break;\n    case 1:         // duplicate test expression\n        break;\n    default:\n        break;\n}\n\nswitch (a) {\n    case one:\n        break;\n    case 2:\n        break;\n    case one:         // duplicate test expression\n        break;\n    default:\n        break;\n}\n\nswitch (a) {\n    case \"1\":\n        break;\n    case \"2\":\n        break;\n    case \"1\":         // duplicate test expression\n        break;\n    default:\n        break;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-duplicate-case: \"error\"*/\n\nvar a = 1,\n    one = 1;\n\nswitch (a) {\n    case 1:\n        break;\n    case 2:\n        break;\n    case 3:\n        break;\n    default:\n        break;\n}\n\nswitch (a) {\n    case one:\n        break;\n    case 2:\n        break;\n    case 3:\n        break;\n    default:\n        break;\n}\n\nswitch (a) {\n    case \"1\":\n        break;\n    case \"2\":\n        break;\n    case \"3\":\n        break;\n    default:\n        break;\n}"
            }
        ]
    },
    {
        "name": "no-duplicate-imports",
        "url": "https://eslint.org/docs/latest/rules/no-duplicate-imports",
        "description": "Disallow duplicate module importsUsing a single import statement per module will make the code clearer because you can see everything being imported from that module on one line.In the following example the module import on line 1 is repeated on line 3. These can be combined to make the list of imports more succinct.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-duplicate-imports: \"error\"*/\n\nimport { merge } from 'module';\nimport something from 'another-module';\nimport { find } from 'module';"
            },
            {
                "type": "correct",
                "content": "/*eslint no-duplicate-imports: \"error\"*/\n\nimport { merge, find } from 'module';\nimport something from 'another-module';"
            },
            {
                "type": "correct",
                "content": "/*eslint no-duplicate-imports: \"error\"*/\n\n// not mergeable\nimport { merge } from 'module';\nimport * as something from 'module';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-duplicate-imports: [\"error\", { \"includeExports\": true }]*/\n\nimport { merge } from 'module';\n\nexport { find } from 'module';"
            },
            {
                "type": "correct",
                "content": "/*eslint no-duplicate-imports: [\"error\", { \"includeExports\": true }]*/\n\nimport { merge, find } from 'module';\n\nexport { find };"
            },
            {
                "type": "correct",
                "content": "/*eslint no-duplicate-imports: [\"error\", { \"includeExports\": true }]*/\n\nimport { merge, find } from 'module';\n\n// cannot be merged with the above import\nexport * as something from 'module';\n\n// cannot be written differently\nexport * from 'module';"
            }
        ]
    },
    {
        "name": "no-empty-character-class",
        "url": "https://eslint.org/docs/latest/rules/no-empty-character-class",
        "description": "Disallow empty character classes in regular expressionsBecause empty character classes in regular expressions do not match anything, they might be typing mistakes.This rule disallows empty character classes in regular expressions.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-empty-character-class: \"error\"*/\n\n/^abc[]/.test(\"abcdefg\"); // false\n\"abcdefg\".match(/^abc[]/); // null"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-character-class: \"error\"*/\n\n/^abc/.test(\"abcdefg\"); // true\n\"abcdefg\".match(/^abc/); // [\"abc\"]\n\n/^abc[a-z]/.test(\"abcdefg\"); // true\n\"abcdefg\".match(/^abc[a-z]/); // [\"abcd\"]"
            }
        ]
    },
    {
        "name": "no-empty-pattern",
        "url": "https://eslint.org/docs/latest/rules/no-empty-pattern",
        "description": "Disallow empty destructuring patternsWhen using destructuring, it’s possible to create a pattern that has no effect. This happens when empty curly braces are used to the right of an embedded object destructuring pattern, such as:In this code, no new variables are created because a is just a location helper while the {} is expected to contain the variables to create, such as:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-empty-pattern: \"error\"*/\n\nvar {} = foo;\nvar [] = foo;\nvar {a: {}} = foo;\nvar {a: []} = foo;\nfunction foo({}) {}\nfunction foo([]) {}\nfunction foo({a: {}}) {}\nfunction foo({a: []}) {}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-pattern: \"error\"*/\n\nvar {a = {}} = foo;\nvar {a = []} = foo;\nfunction foo({a = {}}) {}\nfunction foo({a = []}) {}"
            }
        ]
    },
    {
        "name": "no-ex-assign",
        "url": "https://eslint.org/docs/latest/rules/no-ex-assign",
        "description": "Disallow reassigning exceptions in catch clausesIf a catch clause in a try statement accidentally (or purposely) assigns another value to the exception parameter, it is impossible to refer to the error from that point on. Since there is no arguments object to offer alternative access to this data, assignment of the parameter is absolutely destructive.This rule disallows reassigning exceptions in catch clauses.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-ex-assign: \"error\"*/\n\ntry {\n    // code\n} catch (e) {\n    e = 10;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-ex-assign: \"error\"*/\n\ntry {\n    // code\n} catch (e) {\n    var foo = 10;\n}"
            }
        ]
    },
    {
        "name": "no-fallthrough",
        "url": "https://eslint.org/docs/latest/rules/no-fallthrough",
        "description": "Disallow fallthrough of case statementsThe switch statement in JavaScript is one of the more error-prone constructs of the language thanks in part to the ability to “fall through” from one case to the next. For example:In this example, if foo is 1, then execution will flow through both cases, as the first falls through to the second. You can prevent this by using break, as in this example:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-fallthrough: \"error\"*/\n\nswitch(foo) {\n    case 1:\n        doSomething();\n\n    case 2:\n        doSomething();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-fallthrough: \"error\"*/\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        break;\n\n    case 2:\n        doSomething();\n}\n\nfunction bar(foo) {\n    switch(foo) {\n        case 1:\n            doSomething();\n            return;\n\n        case 2:\n            doSomething();\n    }\n}\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        throw new Error(\"Boo!\");\n\n    case 2:\n        doSomething();\n}\n\nswitch(foo) {\n    case 1:\n    case 2:\n        doSomething();\n}\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        // falls through\n\n    case 2:\n        doSomething();\n}\n\nswitch(foo) {\n    case 1: {\n        doSomething();\n        // falls through\n    }\n\n    case 2: {\n        doSomethingElse();\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-fallthrough: [\"error\", { \"commentPattern\": \"break[\\\\s\\\\w]*omitted\" }]*/\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        // break omitted\n\n    case 2:\n        doSomething();\n}\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        // caution: break is omitted intentionally\n\n    default:\n        doSomething();\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint no-fallthrough: [\"error\", { \"allowEmptyCase\": true }] */\n\nswitch(foo){\n    case 1:\n\n    case 2: doSomething();\n}\n\nswitch(foo){\n    case 1:\n    /*\n    Put a message here \n    */\n    case 2: doSomething();\n}\n"
            }
        ]
    },
    {
        "name": "no-func-assign",
        "url": "https://eslint.org/docs/latest/rules/no-func-assign",
        "description": "Disallow reassigning function declarationsJavaScript functions can be written as a FunctionDeclaration function foo() { ... } or as a FunctionExpression var foo = function() { ... };. While a JavaScript interpreter might tolerate it, overwriting/reassigning a function written as a FunctionDeclaration is often indicative of a mistake or issue.This rule disallows reassigning function declarations.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-func-assign: \"error\"*/\n\nfunction foo() {}\nfoo = bar;\n\nfunction foo() {\n    foo = bar;\n}\n\nvar a = function hello() {\n  hello = 123;\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-func-assign: \"error\"*/\n\nfoo = bar;\nfunction foo() {}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-func-assign: \"error\"*/\n\nvar foo = function () {}\nfoo = bar;\n\nfunction foo(foo) { // `foo` is shadowed.\n    foo = bar;\n}\n\nfunction foo() {\n    var foo = bar;  // `foo` is shadowed.\n}"
            }
        ]
    },
    {
        "name": "no-import-assign",
        "url": "https://eslint.org/docs/latest/rules/no-import-assign",
        "description": "Disallow assigning to imported bindingsThe updates of imported bindings by ES Modules cause runtime errors.This rule warns the assignments, increments, and decrements of imported bindings.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-import-assign: \"error\"*/\n\nimport mod, { named } from \"./mod.mjs\"\nimport * as mod_ns from \"./mod.mjs\"\n\nmod = 1          // ERROR: 'mod' is readonly.\nnamed = 2        // ERROR: 'named' is readonly.\nmod_ns.named = 3 // ERROR: The members of 'mod_ns' are readonly.\nmod_ns = {}      // ERROR: 'mod_ns' is readonly.\n// Can't extend 'mod_ns'\nObject.assign(mod_ns, { foo: \"foo\" }) // ERROR: The members of 'mod_ns' are readonly."
            },
            {
                "type": "correct",
                "content": "/*eslint no-import-assign: \"error\"*/\n\nimport mod, { named } from \"./mod.mjs\"\nimport * as mod_ns from \"./mod.mjs\"\n\nmod.prop = 1\nnamed.prop = 2\nmod_ns.named.prop = 3\n\n// Known Limitation\nfunction test(obj) {\n    obj.named = 4 // Not errored because 'obj' is not namespace objects.\n}\ntest(mod_ns) // Not errored because it doesn't know that 'test' updates the member of the argument."
            }
        ]
    },
    {
        "name": "no-inner-declarations",
        "url": "https://eslint.org/docs/latest/rules/no-inner-declarations",
        "description": "Disallow variable or function declarations in nested blocksIn JavaScript, prior to ES6, a function declaration is only allowed in the first level of a program or the body of another function, though parsers sometimes erroneously accept them elsewhere. This only applies to function declarations; named or anonymous function expressions can occur anywhere an expression is permitted.A variable declaration is permitted anywhere a statement can go, even nested deeply inside other blocks. This is often undesirable due to variable hoisting, and moving declarations to the root of the program or function body can increase clarity. Note that block bindings (let, const) are not hoisted and therefore they are not affected by this rule.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-inner-declarations: \"error\"*/\n\nif (test) {\n    function doSomething() { }\n}\n\nfunction doSomethingElse() {\n    if (test) {\n        function doAnotherThing() { }\n    }\n}\n\nif (foo) function f(){}\n\nclass C {\n    static {\n        if (test) {\n            function doSomething() { }\n        }\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-inner-declarations: \"error\"*/\n\nfunction doSomething() { }\n\nfunction doSomethingElse() {\n    function doAnotherThing() { }\n}\n\nclass C {\n    static {\n        function doSomething() { }\n    }\n}\n\nif (test) {\n    asyncCall(id, function (err, data) { });\n}\n\nvar fn;\nif (test) {\n    fn = function fnExpression() { };\n}\n\nif (foo) var a;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-inner-declarations: [\"error\", \"both\"]*/\n\nif (test) {\n    var foo = 42;\n}\n\nfunction doAnotherThing() {\n    if (test) {\n        var bar = 81;\n    }\n}\n\nif (foo) var a;\n\nif (foo) function f(){}\n\nclass C {\n    static {\n        if (test) {\n            var something;\n        }\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-inner-declarations: [\"error\", \"both\"]*/\n\nvar bar = 42;\n\nif (test) {\n    let baz = 43;\n}\n\nfunction doAnotherThing() {\n    var baz = 81;\n}\n\nclass C {\n    static {\n        var something;\n    }\n}"
            }
        ]
    },
    {
        "name": "no-invalid-regexp",
        "url": "https://eslint.org/docs/latest/rules/no-invalid-regexp",
        "description": "Disallow invalid regular expression strings in RegExp constructorsAn invalid pattern in a regular expression literal is a SyntaxError when the code is parsed, but an invalid string in RegExp constructors throws a SyntaxError only when the code is executed.This rule disallows invalid regular expression strings in RegExp constructors.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-invalid-regexp: \"error\"*/\n\nRegExp('[')\n\nRegExp('.', 'z')\n\nnew RegExp('\\\\')"
            },
            {
                "type": "correct",
                "content": "/*eslint no-invalid-regexp: \"error\"*/\n\nRegExp('.')\n\nnew RegExp\n\nthis.RegExp('[')"
            },
            {
                "type": "correct",
                "content": "/*eslint no-invalid-regexp: [\"error\", { \"allowConstructorFlags\": [\"a\", \"z\"] }]*/\n\nnew RegExp('.', 'a')\n\nnew RegExp('.', 'az')"
            }
        ]
    },
    {
        "name": "no-irregular-whitespace",
        "url": "https://eslint.org/docs/latest/rules/no-irregular-whitespace",
        "description": "Disallow irregular whitespaceInvalid or irregular whitespace causes issues with ECMAScript 5 parsers and also makes code harder to debug in a similar nature to mixed tabs and spaces.Various whitespace characters can be inputted by programmers by mistake for example from copying or keyboard shortcuts. Pressing Alt + Space on macOS adds in a non breaking space character for example.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-irregular-whitespace: \"error\"*/\n\nfunction thing() /*<NBSP>*/{\n    return 'test';\n}\n\nfunction thing( /*<NBSP>*/){\n    return 'test';\n}\n\nfunction thing /*<NBSP>*/(){\n    return 'test';\n}\n\nfunction thing᠎/*<MVS>*/(){\n    return 'test';\n}\n\nfunction thing() {\n    return 'test'; /*<ENSP>*/\n}\n\nfunction thing() {\n    return 'test'; /*<NBSP>*/\n}\n\nfunction thing() {\n    // Description <NBSP>: some descriptive text\n}\n\n/*\nDescription <NBSP>: some descriptive text\n*/\n\nfunction thing() {\n    return / <NBSP>regexp/;\n}\n\n/*eslint-env es6*/\nfunction thing() {\n    return `template <NBSP>string`;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-irregular-whitespace: \"error\"*/\n\nfunction thing() {\n    return ' <NBSP>thing';\n}\n\nfunction thing() {\n    return '​<ZWSP>thing';\n}\n\nfunction thing() {\n    return 'th <NBSP>ing';\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-irregular-whitespace: [\"error\", { \"skipComments\": true }]*/\n\nfunction thing() {\n    // Description <NBSP>: some descriptive text\n}\n\n/*\nDescription <NBSP>: some descriptive text\n*/"
            },
            {
                "type": "correct",
                "content": "/*eslint no-irregular-whitespace: [\"error\", { \"skipRegExps\": true }]*/\n\nfunction thing() {\n    return / <NBSP>regexp/;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-irregular-whitespace: [\"error\", { \"skipTemplates\": true }]*/\n/*eslint-env es6*/\n\nfunction thing() {\n    return `template <NBSP>string`;\n}"
            }
        ]
    },
    {
        "name": "no-loss-of-precision",
        "url": "https://eslint.org/docs/latest/rules/no-loss-of-precision",
        "description": "Disallow literal numbers that lose precisionThis rule would disallow the use of number literals that lose precision at runtime when converted to a JS Number due to 64-bit floating-point rounding.In JS, Numbers are stored as double-precision floating-point numbers according to the IEEE 754 standard. Because of this, numbers can only retain accuracy up to a certain amount of digits. If the programmer enters additional digits, those digits will be lost in the conversion to the Number type and will result in unexpected behavior.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-loss-of-precision: \"error\"*/\n\nconst x = 9007199254740993\nconst x = 5123000000000000000000000000001\nconst x = 1230000000000000000000000.0\nconst x = .1230000000000000000000000\nconst x = 0X20000000000001\nconst x = 0X2_000000000_0001;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-loss-of-precision: \"error\"*/\n\nconst x = 12345\nconst x = 123.456\nconst x = 123e34\nconst x = 12300000000000000000000000\nconst x = 0x1FFFFFFFFFFFFF\nconst x = 9007199254740991\nconst x = 9007_1992547409_91"
            }
        ]
    },
    {
        "name": "no-misleading-character-class",
        "url": "https://eslint.org/docs/latest/rules/no-misleading-character-class",
        "description": "Disallow characters which are made with multiple code points in character class syntaxUnicode includes the characters which are made with multiple code points. RegExp character class syntax (/[abc]/) cannot handle characters which are made by multiple code points as a character; those characters will be dissolved to each code point. For example, ❇️ is made by ❇ (U+2747) and VARIATION SELECTOR-16 (U+FE0F). If this character is in RegExp character class, it will match to either ❇ (U+2747) or VARIATION SELECTOR-16 (U+FE0F) rather than ❇️.This rule reports the regular expressions which include multiple code point characters in character class syntax. This rule considers the following characters as multiple code point characters.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-misleading-character-class: error */\n\n/^[Á]$/u\n/^[❇️]$/u\n/^[👶🏻]$/u\n/^[🇯🇵]$/u\n/^[👨‍👩‍👦]$/u\n/^[👍]$/"
            },
            {
                "type": "correct",
                "content": "/*eslint no-misleading-character-class: error */\n\n/^[abc]$/\n/^[👍]$/u"
            }
        ]
    },
    {
        "name": "no-new-native-nonconstructor",
        "url": "https://eslint.org/docs/latest/rules/no-new-native-nonconstructor",
        "description": "Disallow new operators with global non-constructor functionsIt is a convention in JavaScript that global variables beginning with an uppercase letter typically represent classes that can be instantiated using the new operator, such as new Array and new Map. Confusingly, JavaScript also provides some global variables that begin with an uppercase letter that cannot be called using the new operator and will throw an error if you attempt to do so. These are typically functions that are related to data types and are easy to mistake for classes. Consider the following example::::",
        "examples": [
            {
                "type": "correct",
                "content": "/*eslint no-new-native-nonconstructor: \"error\"*/\n/*eslint-env es2022*/\n\nvar foo = Symbol('foo');\nvar bar = BigInt(9007199254740991);\n\n// Ignores shadowed Symbol.\nfunction baz(Symbol) {\n    const qux = new Symbol(\"baz\");\n}\nfunction quux(BigInt) {\n    const corge = new BigInt(9007199254740991);\n}\n"
            }
        ]
    },
    {
        "name": "no-new-symbol",
        "url": "https://eslint.org/docs/latest/rules/no-new-symbol",
        "description": "Disallow new operators with the Symbol objectSymbol is not intended to be used with the new operator, but to be called as a function.This throws a TypeError exception.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-new-symbol: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = new Symbol('foo');"
            },
            {
                "type": "correct",
                "content": "/*eslint no-new-symbol: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = Symbol('foo');\n\n// Ignores shadowed Symbol.\nfunction bar(Symbol) {\n    const baz = new Symbol(\"baz\");\n}\n"
            }
        ]
    },
    {
        "name": "no-obj-calls",
        "url": "https://eslint.org/docs/latest/rules/no-obj-calls",
        "description": "Disallow calling global object properties as functionsECMAScript provides several global objects that are intended to be used as-is. Some of these objects look as if they could be constructors due their capitalization (such as Math and JSON) but will throw an error if you try to execute them as functions.The ECMAScript 5 specification makes it clear that both Math and JSON cannot be invoked:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-obj-calls: \"error\"*/\n/*eslint-env es2017*/\n\nvar math = Math();\n\nvar newMath = new Math();\n\nvar json = JSON();\n\nvar newJSON = new JSON();\n\nvar reflect = Reflect();\n\nvar newReflect = new Reflect();\n\nvar atomics = Atomics();\n\nvar newAtomics = new Atomics();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-obj-calls: \"error\"*/\n/*eslint-env es2017*/\n\nfunction area(r) {\n    return Math.PI * r * r;\n}\n\nvar object = JSON.parse(\"{}\");\n\nvar value = Reflect.get({ x: 1, y: 2 }, \"x\");\n\nvar first = Atomics.load(foo, 0);"
            }
        ]
    },
    {
        "name": "no-promise-executor-return",
        "url": "https://eslint.org/docs/latest/rules/no-promise-executor-return",
        "description": "Disallow returning values from Promise executor functionsThe new Promise constructor accepts a single argument, called an executor.The executor function usually initiates some asynchronous operation. Once it is finished, the executor should call resolve with the result, or reject if an error occurred.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-promise-executor-return: \"error\"*/\n\nnew Promise((resolve, reject) => {\n    if (someCondition) {\n        return defaultResult;\n    }\n    getSomething((err, result) => {\n        if (err) {\n            reject(err);\n        } else {\n            resolve(result);\n        }\n    });\n});\n\nnew Promise((resolve, reject) => getSomething((err, data) => {\n    if (err) {\n        reject(err);\n    } else {\n        resolve(data);\n    }\n}));\n\nnew Promise(() => {\n    return 1;\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint no-promise-executor-return: \"error\"*/\n\nnew Promise((resolve, reject) => {\n    if (someCondition) {\n        resolve(defaultResult);\n        return;\n    }\n    getSomething((err, result) => {\n        if (err) {\n            reject(err);\n        } else {\n            resolve(result);\n        }\n    });\n});\n\nnew Promise((resolve, reject) => {\n    getSomething((err, data) => {\n        if (err) {\n            reject(err);\n        } else {\n            resolve(data);\n        }\n    });\n});\n\nPromise.resolve(1);"
            }
        ]
    },
    {
        "name": "no-prototype-builtins",
        "url": "https://eslint.org/docs/latest/rules/no-prototype-builtins",
        "description": "Disallow calling some Object.prototype methods directly on objectsIn ECMAScript 5.1, Object.create was added, which enables the creation of objects with a specified [[Prototype]]. Object.create(null) is a common pattern used to create objects that will be used as a Map. This can lead to errors when it is assumed that objects will have properties from Object.prototype. This rule prevents calling some Object.prototype methods directly from an object.Additionally, objects can have properties that shadow the builtins on Object.prototype, potentially causing unintended behavior or denial-of-service security vulnerabilities. For example, it would be unsafe for a webserver to parse JSON input from a client and call hasOwnProperty directly on the resulting object, because a malicious client could send a JSON value like {\"hasOwnProperty\": 1} and cause the server to crash.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-prototype-builtins: \"error\"*/\n\nvar hasBarProperty = foo.hasOwnProperty(\"bar\");\n\nvar isPrototypeOfBar = foo.isPrototypeOf(bar);\n\nvar barIsEnumerable = foo.propertyIsEnumerable(\"bar\");"
            },
            {
                "type": "correct",
                "content": "/*eslint no-prototype-builtins: \"error\"*/\n\nvar hasBarProperty = Object.prototype.hasOwnProperty.call(foo, \"bar\");\n\nvar isPrototypeOfBar = Object.prototype.isPrototypeOf.call(foo, bar);\n\nvar barIsEnumerable = {}.propertyIsEnumerable.call(foo, \"bar\");"
            }
        ]
    },
    {
        "name": "no-self-assign",
        "url": "https://eslint.org/docs/latest/rules/no-self-assign",
        "description": "Disallow assignments where both sides are exactly the sameSelf assignments have no effect, so probably those are an error due to incomplete refactoring. Those indicate that what you should do is still remaining.This rule is aimed at eliminating self assignments.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-self-assign: \"error\"*/\n\nfoo = foo;\n\n[a, b] = [a, b];\n\n[a, ...b] = [x, ...b];\n\n({a, b} = {a, x});\n\nfoo &&= foo;\nfoo ||= foo;\nfoo ??= foo;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-self-assign: \"error\"*/\n\nfoo = bar;\n[a, b] = [b, a];\n\n// This pattern is warned by the `no-use-before-define` rule.\nlet foo = foo;\n\n// The default values have an effect.\n[foo = 1] = [foo];\n\n// non-self-assignments with properties.\nobj.a = obj.b;\nobj.a.b = obj.c.b;\nobj.a.b = obj.a.c;\nobj[a] = obj[\"a\"];\n\n// This ignores if there is a function call.\nobj.a().b = obj.a().b;\na().b = a().b;\n\n// `&=` and `|=` have an effect on non-integers.\nfoo &= foo;\nfoo |= foo;\n\n// Known limitation: this does not support computed properties except single literal or single identifier.\nobj[a + b] = obj[a + b];\nobj[\"a\" + \"b\"] = obj[\"a\" + \"b\"];"
            },
            {
                "type": "correct",
                "content": "/*eslint no-self-assign: [\"error\", {\"props\": false}]*/\n\n// self-assignments with properties.\nobj.a = obj.a;\nobj.a.b = obj.a.b;\nobj[\"a\"] = obj[\"a\"];\nobj[a] = obj[a];"
            }
        ]
    },
    {
        "name": "no-self-compare",
        "url": "https://eslint.org/docs/latest/rules/no-self-compare",
        "description": "Disallow comparisons where both sides are exactly the sameComparing a variable against itself is usually an error, either a typo or refactoring error. It is confusing to the reader and may potentially introduce a runtime error.The only time you would compare a variable against itself is when you are testing for NaN. However, it is far more appropriate to use typeof x === 'number' && isNaN(x) or the Number.isNaN ES2015 function for that use case rather than leaving the reader of the code to determine the intent of self comparison.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-self-compare: \"error\"*/\n\nvar x = 10;\nif (x === x) {\n    x = 20;\n}"
            }
        ]
    },
    {
        "name": "no-setter-return",
        "url": "https://eslint.org/docs/latest/rules/no-setter-return",
        "description": "Disallow returning values from settersSetters cannot return values.While returning a value from a setter does not produce an error, the returned value is being ignored. Therefore, returning a value from a setter is either unnecessary or a possible error, since the returned value cannot be used.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-setter-return: \"error\"*/\n\nvar foo = {\n    set a(value) {\n        this.val = value;\n        return value;\n    }\n};\n\nclass Foo {\n    set a(value) {\n        this.val = value * 2;\n        return this.val;\n    }\n}\n\nconst Bar = class {\n    static set a(value) {\n        if (value < 0) {\n            this.val = 0;\n            return 0;\n        }\n        this.val = value;\n    }\n};\n\nObject.defineProperty(foo, \"bar\", {\n    set(value) {\n        if (value < 0) {\n            return false;\n        }\n        this.val = value;\n    }\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint no-setter-return: \"error\"*/\n\nvar foo = {\n    set a(value) {\n        this.val = value;\n    }\n};\n\nclass Foo {\n    set a(value) {\n        this.val = value * 2;\n    }\n}\n\nconst Bar = class {\n    static set a(value) {\n        if (value < 0) {\n            this.val = 0;\n            return;\n        }\n        this.val = value;\n    }\n};\n\nObject.defineProperty(foo, \"bar\", {\n    set(value) {\n        if (value < 0) {\n            throw new Error(\"Negative value.\");\n        }\n        this.val = value;\n    }\n});"
            }
        ]
    },
    {
        "name": "no-sparse-arrays",
        "url": "https://eslint.org/docs/latest/rules/no-sparse-arrays",
        "description": "Disallow sparse arraysSparse arrays contain empty slots, most frequently due to multiple commas being used in an array literal, such as:While the items array in this example has a length of 2, there are actually no values in items[0] or items[1]. The fact that the array literal is valid with only commas inside, coupled with the length being set and actual item values not being set, make sparse arrays confusing for many developers. Consider the following:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-sparse-arrays: \"error\"*/\n\nvar items = [,];\nvar colors = [ \"red\",, \"blue\" ];"
            },
            {
                "type": "correct",
                "content": "/*eslint no-sparse-arrays: \"error\"*/\n\nvar items = [];\nvar items = new Array(23);\n\n// trailing comma (after the last element) is not a problem\nvar colors = [ \"red\", \"blue\", ];"
            }
        ]
    },
    {
        "name": "no-template-curly-in-string",
        "url": "https://eslint.org/docs/latest/rules/no-template-curly-in-string",
        "description": "Disallow template literal placeholder syntax in regular stringsECMAScript 6 allows programmers to create strings containing variable or expressions using template literals, instead of string concatenation, by writing expressions like ${variable} between two backtick quotes (`). It can be easy to use the wrong quotes when wanting to use template literals, by writing \"${variable}\", and end up with the literal value \"${variable}\" instead of a string containing the value of the injected expressions.This rule aims to warn when a regular string contains what looks like a template literal placeholder. It will warn when it finds a string containing the template literal placeholder (${something}) that uses either \" or ' for the quotes.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-template-curly-in-string: \"error\"*/\n\"Hello ${name}!\";\n'Hello ${name}!';\n\"Time: ${12 * 60 * 60 * 1000}\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-template-curly-in-string: \"error\"*/\n`Hello ${name}!`;\n`Time: ${12 * 60 * 60 * 1000}`;\n\ntemplateFunction`Hello ${name}`;"
            }
        ]
    },
    {
        "name": "no-this-before-super",
        "url": "https://eslint.org/docs/latest/rules/no-this-before-super",
        "description": "Disallow this/super before calling super() in constructorsIn the constructor of derived classes, if this/super are used before super() calls, it raises a reference error.This rule checks this/super keywords in constructors, then reports those that are before super().",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-this-before-super: \"error\"*/\n/*eslint-env es6*/\n\nclass A extends B {\n    constructor() {\n        this.a = 0;\n        super();\n    }\n}\n\nclass A extends B {\n    constructor() {\n        this.foo();\n        super();\n    }\n}\n\nclass A extends B {\n    constructor() {\n        super.foo();\n        super();\n    }\n}\n\nclass A extends B {\n    constructor() {\n        super(this.foo());\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-this-before-super: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    constructor() {\n        this.a = 0; // OK, this class doesn't have an `extends` clause.\n    }\n}\n\nclass A extends B {\n    constructor() {\n        super();\n        this.a = 0; // OK, this is after `super()`.\n    }\n}\n\nclass A extends B {\n    foo() {\n        this.a = 0; // OK. this is not in a constructor.\n    }\n}"
            }
        ]
    },
    {
        "name": "no-undef",
        "url": "https://eslint.org/docs/latest/rules/no-undef",
        "description": "Disallow the use of undeclared variables unless mentioned in /*global */ commentsThis rule can help you locate potential ReferenceErrors resulting from misspellings of variable and parameter names, or accidental implicit globals (for example, from forgetting the var keyword in a for loop initializer).Any reference to an undeclared variable causes a warning, unless the variable is explicitly mentioned in a /*global ...*/ comment, or specified in the globals key in the configuration file. A common use case for these is if you intentionally use globals that are defined elsewhere (e.g. in a script sourced from HTML).",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-undef: \"error\"*/\n\nvar foo = someFunction();\nvar bar = a + 1;"
            },
            {
                "type": "correct",
                "content": "/*global someFunction, a*/\n/*eslint no-undef: \"error\"*/\n\nvar foo = someFunction();\nvar bar = a + 1;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-undef: \"error\"*/\n\nif (typeof UndefinedIdentifier === \"undefined\") {\n    // do something ...\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-undef: [\"error\", { \"typeof\": true }] */\n\nif(typeof a === \"string\"){}"
            },
            {
                "type": "correct",
                "content": "/*global a*/\n/*eslint no-undef: [\"error\", { \"typeof\": true }] */\n\nif(typeof a === \"string\"){}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-undef: \"error\"*/\n/*eslint-env browser*/\n\nsetTimeout(function() {\n    alert(\"Hello\");\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint no-undef: \"error\"*/\n/*eslint-env node*/\n\nvar fs = require(\"fs\");\nmodule.exports = function() {\n    console.log(fs);\n};"
            }
        ]
    },
    {
        "name": "no-unexpected-multiline",
        "url": "https://eslint.org/docs/latest/rules/no-unexpected-multiline",
        "description": "Disallow confusing multiline expressionsSemicolons are usually optional in JavaScript, because of automatic semicolon insertion (ASI). You can require or disallow semicolons with the semi rule.The rules for ASI are relatively straightforward: As once described by Isaac Schlueter, a newline character always ends a statement, just like a semicolon, except where one of the following is true:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unexpected-multiline: \"error\"*/\n\nvar foo = bar\n(1 || 2).baz();\n\nvar hello = 'world'\n[1, 2, 3].forEach(addNumber);\n\nlet x = function() {}\n`hello`\n\nlet x = function() {}\nx\n`hello`\n\nlet x = foo\n/regex/g.test(bar)"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unexpected-multiline: \"error\"*/\n\nvar foo = bar;\n(1 || 2).baz();\n\nvar foo = bar\n;(1 || 2).baz()\n\nvar hello = 'world';\n[1, 2, 3].forEach(addNumber);\n\nvar hello = 'world'\nvoid [1, 2, 3].forEach(addNumber);\n\nlet x = function() {};\n`hello`\n\nlet tag = function() {}\ntag `hello`"
            }
        ]
    },
    {
        "name": "no-unmodified-loop-condition",
        "url": "https://eslint.org/docs/latest/rules/no-unmodified-loop-condition",
        "description": "Disallow unmodified loop conditionsVariables in a loop condition often are modified in the loop. If not, it’s possibly a mistake.This rule finds references which are inside of loop conditions, then checks the variables of those references are modified in the loop.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unmodified-loop-condition: \"error\"*/\n\nvar node = something;\n\nwhile (node) {\n    doSomething(node);\n}\nnode = other;\n\nfor (var j = 0; j < items.length; ++i) {\n    doSomething(items[j]);\n}\n\nwhile (node !== root) {\n    doSomething(node);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unmodified-loop-condition: \"error\"*/\n\nwhile (node) {\n    doSomething(node);\n    node = node.parent;\n}\n\nfor (var j = 0; j < items.length; ++j) {\n    doSomething(items[j]);\n}\n\n// OK, the result of this binary expression is changed in this loop.\nwhile (node !== root) {\n    doSomething(node);\n    node = node.parent;\n}\n\n// OK, the result of this ternary expression is changed in this loop.\nwhile (node ? A : B) {\n    doSomething(node);\n    node = node.parent;\n}\n\n// A property might be a getter which has side effect...\n// Or \"doSomething\" can modify \"obj.foo\".\nwhile (obj.foo) {\n    doSomething(obj);\n}\n\n// A function call can return various values.\nwhile (check(obj)) {\n    doSomething(obj);\n}"
            }
        ]
    },
    {
        "name": "no-unreachable",
        "url": "https://eslint.org/docs/latest/rules/no-unreachable",
        "description": "Disallow unreachable code after return, throw, continue, and break statementsBecause the return, throw, break, and continue statements unconditionally exit a block of code, any statements after them cannot be executed. Unreachable statements are usually a mistake.Another kind of mistake is defining instance fields in a subclass whose constructor doesn’t call super(). Instance fields of a subclass are only added to the instance after super(). If there are no super() calls, their definitions are never applied and therefore are unreachable code.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unreachable: \"error\"*/\n\nfunction foo() {\n    return true;\n    console.log(\"done\");\n}\n\nfunction bar() {\n    throw new Error(\"Oops!\");\n    console.log(\"done\");\n}\n\nwhile(value) {\n    break;\n    console.log(\"done\");\n}\n\nthrow new Error(\"Oops!\");\nconsole.log(\"done\");\n\nfunction baz() {\n    if (Math.random() < 0.5) {\n        return;\n    } else {\n        throw new Error();\n    }\n    console.log(\"done\");\n}\n\nfor (;;) {}\nconsole.log(\"done\");"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unreachable: \"error\"*/\n\nfunction foo() {\n    return bar();\n    function bar() {\n        return 1;\n    }\n}\n\nfunction bar() {\n    return x;\n    var x;\n}\n\nswitch (foo) {\n    case 1:\n        break;\n        var x;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unreachable: \"error\"*/\n\nclass C extends B {\n    #x; // unreachable\n    #y = 1; // unreachable\n    a; // unreachable\n    b = 1; // unreachable\n\n    constructor() {\n        return {};\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unreachable: \"error\"*/\n\nclass D extends B {\n    #x;\n    #y = 1;\n    a;\n    b = 1;\n\n    constructor() {\n        super();\n    }\n}\n\nclass E extends B {\n    #x;\n    #y = 1;\n    a;\n    b = 1;\n\n    // implicit constructor always calls `super()`\n}\n\nclass F extends B {\n    static #x;\n    static #y = 1;\n    static a;\n    static b = 1;\n\n    constructor() {\n        return {};\n    }\n}"
            }
        ]
    },
    {
        "name": "no-unreachable-loop",
        "url": "https://eslint.org/docs/latest/rules/no-unreachable-loop",
        "description": "Disallow loops with a body that allows only one iterationA loop that can never reach the second iteration is a possible error in the code.In rare cases where only one iteration (or at most one iteration) is intended behavior, the code should be refactored to use if conditionals instead of while, do-while and for loops. It’s considered a best practice to avoid using loop constructs for such cases.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unreachable-loop: \"error\"*/\n\nwhile (foo) {\n    doSomething(foo);\n    foo = foo.parent;\n    break;\n}\n\nfunction verifyList(head) {\n    let item = head;\n    do {\n        if (verify(item)) {\n            return true;\n        } else {\n            return false;\n        }\n    } while (item);\n}\n\nfunction findSomething(arr) {\n    for (var i = 0; i < arr.length; i++) {\n        if (isSomething(arr[i])) {\n            return arr[i];\n        } else {\n            throw new Error(\"Doesn't exist.\");\n        }\n    }\n}\n\nfor (key in obj) {\n    if (key.startsWith(\"_\")) {\n        break;\n    }\n    firstKey = key;\n    firstValue = obj[key];\n    break;\n}\n\nfor (foo of bar) {\n    if (foo.id === id) {\n        doSomething(foo);\n    }\n    break;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unreachable-loop: \"error\"*/\n\nwhile (foo) {\n    doSomething(foo);\n    foo = foo.parent;\n}\n\nfunction verifyList(head) {\n    let item = head;\n    do {\n        if (verify(item)) {\n            item = item.next;\n        } else {\n            return false;\n        }\n    } while (item);\n\n    return true;\n}\n\nfunction findSomething(arr) {\n    for (var i = 0; i < arr.length; i++) {\n        if (isSomething(arr[i])) {\n            return arr[i];\n        }\n    }\n    throw new Error(\"Doesn't exist.\");\n}\n\nfor (key in obj) {\n    if (key.startsWith(\"_\")) {\n        continue;\n    }\n    firstKey = key;\n    firstValue = obj[key];\n    break;\n}\n\nfor (foo of bar) {\n    if (foo.id === id) {\n        doSomething(foo);\n        break;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unreachable-loop: \"error\"*/\n\ndo {\n    doSomething();\n} while (false)\n\nfor (let i = 0; i < 1; i++) {\n    doSomething(i);\n}\n\nfor (const a of [1]) {\n    doSomething(a);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unreachable-loop: [\"error\", { \"ignore\": [\"ForInStatement\", \"ForOfStatement\"] }]*/\n\nfor (var key in obj) {\n  hasEnumerableProperties = true;\n  break;\n}\n\nfor (const a of b) break;"
            }
        ]
    },
    {
        "name": "no-unsafe-finally",
        "url": "https://eslint.org/docs/latest/rules/no-unsafe-finally",
        "description": "Disallow control flow statements in finally blocksJavaScript suspends the control flow statements of try and catch blocks until the execution of finally block finishes. So, when return, throw, break, or continue is used in finally, control flow statements inside try and catch are overwritten, which is considered as unexpected behavior. Such as:This rule disallows return, throw, break, and continue statements inside finally blocks. It allows indirect usages, such as in function or class definitions.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unsafe-finally: \"error\"*/\nlet foo = function() {\n    try {\n        return 1;\n    } catch(err) {\n        return 2;\n    } finally {\n        return 3;\n    }\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unsafe-finally: \"error\"*/\nlet foo = function() {\n    try {\n        return 1;\n    } catch(err) {\n        return 2;\n    } finally {\n        throw new Error;\n    }\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unsafe-finally: \"error\"*/\nlet foo = function() {\n    try {\n        return 1;\n    } catch(err) {\n        return 2;\n    } finally {\n        console.log(\"hola!\");\n    }\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unsafe-finally: \"error\"*/\nlet foo = function() {\n    try {\n        return 1;\n    } catch(err) {\n        return 2;\n    } finally {\n        let a = function() {\n            return \"hola!\";\n        }\n    }\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unsafe-finally: \"error\"*/\nlet foo = function(a) {\n    try {\n        return 1;\n    } catch(err) {\n        return 2;\n    } finally {\n        switch(a) {\n            case 1: {\n                console.log(\"hola!\")\n                break;\n            }\n        }\n    }\n};"
            }
        ]
    },
    {
        "name": "no-unsafe-negation",
        "url": "https://eslint.org/docs/latest/rules/no-unsafe-negation",
        "description": "Disallow negating the left operand of relational operatorsJust as developers might type -a + b when they mean -(a + b) for the negative of a sum, they might type !key in object by mistake when they almost certainly mean !(key in object) to test that a key is not in an object. !obj instanceof Ctor is similar.This rule disallows negating the left operand of the following relational operators:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unsafe-negation: \"error\"*/\n\nif (!key in object) {\n    // operator precedence makes it equivalent to (!key) in object\n    // and type conversion makes it equivalent to (key ? \"false\" : \"true\") in object\n}\n\nif (!obj instanceof Ctor) {\n    // operator precedence makes it equivalent to (!obj) instanceof Ctor\n    // and it equivalent to always false since boolean values are not objects.\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unsafe-negation: \"error\"*/\n\nif (!(key in object)) {\n    // key is not in object\n}\n\nif (!(obj instanceof Ctor)) {\n    // obj is not an instance of Ctor\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unsafe-negation: \"error\"*/\n\nif ((!foo) in object) {\n    // allowed, because the negation is explicitly wrapped in parentheses\n    // it is equivalent to (foo ? \"false\" : \"true\") in object\n    // this is allowed as an exception for rare situations when that is the intended meaning\n}\n\nif((\"\" + !foo) in object) {\n    // you can also make the intention more explicit, with type conversion\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unsafe-negation: \"error\"*/\n\nif (!(foo) in object) {\n    // this is not an allowed exception\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unsafe-negation: [\"error\", { \"enforceForOrderingRelations\": true }]*/\n\nif (! a < b) {}\n\nwhile (! a > b) {}\n\nfoo = ! a <= b;\n\nfoo = ! a >= b;"
            }
        ]
    },
    {
        "name": "no-unsafe-optional-chaining",
        "url": "https://eslint.org/docs/latest/rules/no-unsafe-optional-chaining",
        "description": "Disallow use of optional chaining in contexts where the undefined value is not allowedThe optional chaining (?.) expression can short-circuit with a return value of undefined. Therefore, treating an evaluated optional chaining expression as a function, object, number, etc., can cause TypeError or unexpected results. For example:Also, parentheses limit the scope of short-circuiting in chains. For example:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unsafe-optional-chaining: \"error\"*/\n\n(obj?.foo)();\n\n(obj?.foo).bar;\n\n(foo?.()).bar;\n\n(foo?.()).bar();\n\n(obj?.foo ?? obj?.bar)();\n\n(foo || obj?.foo)();\n\n(obj?.foo && foo)();\n\n(foo ? obj?.foo : bar)();\n\n(foo, obj?.bar).baz;\n\n(obj?.foo)`template`;\n\nnew (obj?.foo)();\n\n[...obj?.foo];\n\nbar(...obj?.foo);\n\n1 in obj?.foo;\n\nbar instanceof obj?.foo;\n\nfor (bar of obj?.foo);\n\nconst { bar } = obj?.foo;\n\n[{ bar } = obj?.foo] = [];\n\nwith (obj?.foo);\n\nclass A extends obj?.foo {}\n\nvar a = class A extends obj?.foo {};\n\nasync function foo () {\n    const { bar } = await obj?.foo;\n   (await obj?.foo)();\n   (await obj?.foo).bar;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unsafe-optional-chaining: \"error\"*/\n\n(obj?.foo)?.();\n\nobj?.foo();\n\n(obj?.foo ?? bar)();\n\nobj?.foo.bar;\n\nobj.foo?.bar;\n\nfoo?.()?.bar;\n\n(obj?.foo ?? bar)`template`;\n\nnew (obj?.foo ?? bar)();\n\nvar baz = {...obj?.foo};\n\nconst { bar } = obj?.foo || baz;\n\nasync function foo () {\n  const { bar } = await obj?.foo || baz;\n   (await obj?.foo)?.();\n   (await obj?.foo)?.bar;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unsafe-optional-chaining: [\"error\", { \"disallowArithmeticOperators\": true }]*/\n\n+obj?.foo;\n-obj?.foo;\n\nobj?.foo + bar;\nobj?.foo - bar;\nobj?.foo / bar;\nobj?.foo * bar;\nobj?.foo % bar;\nobj?.foo ** bar;\n\nbaz += obj?.foo;\nbaz -= obj?.foo;\nbaz /= obj?.foo;\nbaz *= obj?.foo;\nbaz %= obj?.foo;\nbaz **= obj?.foo;\n\nasync function foo () {\n  +await obj?.foo;\n  await obj?.foo + bar;\n  baz += await obj?.foo;\n}"
            }
        ]
    },
    {
        "name": "no-unused-private-class-members",
        "url": "https://eslint.org/docs/latest/rules/no-unused-private-class-members",
        "description": "Disallow unused private class membersPrivate class members that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring. Such class members take up space in the code and can lead to confusion by readers.This rule reports unused private class members.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-private-class-members: \"error\"*/\n\nclass Foo {\n    #unusedMember = 5;\n}\n\nclass Foo {\n    #usedOnlyInWrite = 5;\n    method() {\n        this.#usedOnlyInWrite = 42;\n    }\n}\n\nclass Foo {\n    #usedOnlyToUpdateItself = 5;\n    method() {\n        this.#usedOnlyToUpdateItself++;\n    }\n}\n\nclass Foo {\n    #unusedMethod() {}\n}\n\nclass Foo {\n    get #unusedAccessor() {}\n    set #unusedAccessor(value) {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-private-class-members: \"error\"*/\n\nclass Foo {\n    #usedMember = 42;\n    method() {\n        return this.#usedMember;\n    }\n}\n\nclass Foo {\n    #usedMethod() {\n        return 42;\n    }\n    anotherMethod() {\n        return this.#usedMethod();\n    }\n}\n\nclass Foo {\n    get #usedAccessor() {}\n    set #usedAccessor(value) {}\n    \n    method() {\n        this.#usedAccessor = 42;\n    }\n}"
            }
        ]
    },
    {
        "name": "no-unused-vars",
        "url": "https://eslint.org/docs/latest/rules/no-unused-vars",
        "description": "Disallow unused variablesVariables that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring. Such variables take up space in the code and can lead to confusion by readers.This rule is aimed at eliminating unused variables, functions, and function parameters.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-vars: \"error\"*/\n/*global some_unused_var*/\n\n// It checks variables you have defined as global\nsome_unused_var = 42;\n\nvar x;\n\n// Write-only variables are not considered as used.\nvar y = 10;\ny = 5;\n\n// A read for a modification of itself is not considered as used.\nvar z = 0;\nz = z + 1;\n\n// By default, unused arguments cause warnings.\n(function(foo) {\n    return 5;\n})();\n\n// Unused recursive functions also cause warnings.\nfunction fact(n) {\n    if (n < 2) return 1;\n    return n * fact(n - 1);\n}\n\n// When a function definition destructures an array, unused entries from the array also cause warnings.\nfunction getY([x, y]) {\n    return y;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-vars: \"error\"*/\n\nvar x = 10;\nalert(x);\n\n// foo is considered used here\nmyFunc(function foo() {\n    // ...\n}.bind(this));\n\n(function(foo) {\n    return foo;\n})();\n\nvar myFunc;\nmyFunc = setTimeout(function() {\n    // myFunc is considered used\n    myFunc();\n}, 50);\n\n// Only the second argument from the destructured array is used.\nfunction getY([, y]) {\n    return y;\n}"
            },
            {
                "type": "correct",
                "content": "/* exported global_var */\n\nvar global_var = 42;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-vars: [\"error\", { \"vars\": \"local\" }]*/\n/*global some_unused_var */\n\nsome_unused_var = 42;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"[iI]gnored\" }]*/\n\nvar firstVarIgnored = 1;\nvar secondVar = 2;\nconsole.log(secondVar);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-vars: [\"error\", { \"args\": \"after-used\" }]*/\n\n// 2 errors, for the parameters after the last used parameter (bar)\n// \"baz\" is defined but never used\n// \"qux\" is defined but never used\n(function(foo, bar, baz, qux) {\n    return bar;\n})();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-vars: [\"error\", {\"args\": \"after-used\"}]*/\n\n(function(foo, bar, baz, qux) {\n    return qux;\n})();"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-vars: [\"error\", { \"args\": \"all\" }]*/\n\n// 2 errors\n// \"foo\" is defined but never used\n// \"baz\" is defined but never used\n(function(foo, bar, baz) {\n    return bar;\n})();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-vars: [\"error\", { \"args\": \"none\" }]*/\n\n(function(foo, bar, baz) {\n    return bar;\n})();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-vars: [\"error\", { \"ignoreRestSiblings\": true }]*/\n// 'foo' and 'bar' were ignored because they have a rest property sibling.\nvar { foo, ...coords } = data;\n\nvar bar;\n({ bar, ...coords } = data);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\nfunction foo(x, _y) {\n    return x + 1;\n}\nfoo();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-vars: [\"error\", { \"destructuredArrayIgnorePattern\": \"^_\" }]*/\n\nconst [a, _b, c] = [\"a\", \"b\", \"c\"];\nconsole.log(a+c);\n\nconst { x: [_a, foo] } = bar;\nconsole.log(foo);\n\nfunction baz([_c, x]) {\n    x;\n}\nbaz();\n\nfunction test({p: [_q, r]}) {\n    r;\n}\ntest();\n\nlet _m, n;\nfoo.forEach(item => {\n    [_m, n] = item;\n    console.log(n);\n});\n\nlet _o, p;\n_o = 1;\n[_o, p] = foo;\np;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-vars: [\"error\", { \"caughtErrors\": \"none\" }]*/\n\ntry {\n    //...\n} catch (err) {\n    console.error(\"errors\");\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-vars: [\"error\", { \"caughtErrors\": \"all\" }]*/\n\n// 1 error\n// \"err\" is defined but never used\ntry {\n    //...\n} catch (err) {\n    console.error(\"errors\");\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-vars: [\"error\", { \"caughtErrorsIgnorePattern\": \"^ignore\" }]*/\n\ntry {\n    //...\n} catch (ignoreErr) {\n    console.error(\"errors\");\n}"
            }
        ]
    },
    {
        "name": "no-use-before-define",
        "url": "https://eslint.org/docs/latest/rules/no-use-before-define",
        "description": "Disallow the use of variables before they are definedIn JavaScript, prior to ES6, variable and function declarations are hoisted to the top of a scope, so it’s possible to use identifiers before their formal declarations in code. This can be confusing and some believe it is best to always declare variables and functions before using them.In ES6, block-level bindings (let and const) introduce a “temporal dead zone” where a ReferenceError will be thrown with any attempt to access the variable before its declaration.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-use-before-define: \"error\"*/\n\nalert(a);\nvar a = 10;\n\nf();\nfunction f() {}\n\nfunction g() {\n    return b;\n}\nvar b = 1;\n\n{\n    alert(c);\n    let c = 1;\n}\n\n{\n    class C extends C {}\n}\n\n{\n    class C {\n        static x = \"foo\";\n        [C.x]() {}\n    }\n}\n\n{\n    const C = class {\n        static x = C;\n    }\n}\n\n{\n    const C = class {\n        static {\n            C.x = \"foo\";\n        }\n    }\n}\n\nexport { foo };\nconst foo = 1;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-use-before-define: \"error\"*/\n\nvar a;\na = 10;\nalert(a);\n\nfunction f() {}\nf(1);\n\nvar b = 1;\nfunction g() {\n    return b;\n}\n\n{\n    let c;\n    c++;\n}\n\n{\n    class C {\n        static x = C;\n    }\n}\n\n{\n    const C = class C {\n        static x = C;\n    }\n}\n\n{\n    const C = class {\n        x = C;\n    }\n}\n\n{\n    const C = class C {\n        static {\n            C.x = \"foo\";\n        }\n    }\n}\n\nconst foo = 1;\nexport { foo };"
            },
            {
                "type": "correct",
                "content": "/*eslint no-use-before-define: [\"error\", { \"functions\": false }]*/\n\nf();\nfunction f() {}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-use-before-define: [\"error\", { \"classes\": false }]*/\n\nnew A();\nclass A {\n}\n\n{\n    class C extends C {}\n}\n\n{\n    class C extends D {}\n    class D {}\n}\n\n{\n    class C {\n        static x = \"foo\";\n        [C.x]() {}\n    }\n}\n\n{\n    class C {\n        static {\n            new D();\n        }\n    }\n    class D {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-use-before-define: [\"error\", { \"classes\": false }]*/\n\nfunction foo() {\n    return new A();\n}\n\nclass A {\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-use-before-define: [\"error\", { \"variables\": false }]*/\n\nconsole.log(foo);\nvar foo = 1;\n\nf();\nconst f = () => {};\n\ng();\nconst g = function() {};\n\n{\n    const C = class {\n        static x = C;\n    }\n}\n\n{\n    const C = class {\n        static x = foo;\n    }\n    const foo = 1;\n}\n\n{\n    class C {\n        static {\n            this.x = foo;\n        }\n    }\n    const foo = 1;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-use-before-define: [\"error\", { \"variables\": false }]*/\n\nfunction baz() {\n    console.log(foo);\n}\nvar foo = 1;\n\nconst a = () => f();\nfunction b() { return f(); }\nconst c = function() { return f(); }\nconst f = () => {};\n\nconst e = function() { return g(); }\nconst g = function() {}\n\n{\n    const C = class {\n        x = foo;\n    }\n    const foo = 1;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-use-before-define: [\"error\", { \"allowNamedExports\": true }]*/\n\nexport { a, b, f, C };\n\nconst a = 1;\n\nlet b;\n\nfunction f () {}\n\nclass C {}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-use-before-define: [\"error\", { \"allowNamedExports\": true }]*/\n\nexport default a;\nconst a = 1;\n\nconst b = c;\nexport const c = 1;\n\nexport function foo() {\n    return d;\n}\nconst d = 1;"
            }
        ]
    },
    {
        "name": "no-useless-backreference",
        "url": "https://eslint.org/docs/latest/rules/no-useless-backreference",
        "description": "Disallow useless backreferences in regular expressionsIn JavaScript regular expressions, it’s syntactically valid to define a backreference to a group that belongs to another alternative part of the pattern, a backreference to a group that appears after the backreference, a backreference to a group that contains that backreference, or a backreference to a group that is inside a negative lookaround. However, by the specification, in any of these cases the backreference always ends up matching only zero-length (the empty string), regardless of the context in which the backreference and the group appear.Backreferences that always successfully match zero-length and cannot match anything else are useless. They are basically ignored and can be removed without changing the behavior of the regular expression.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-useless-backreference: \"error\"*/\n\n/^(?:(a)|\\1b)$/; // reference to (a) into another alternative\n\n/^(?:(a)|b(?:c|\\1))$/; // reference to (a) into another alternative\n\n/^(?:a|b(?:(c)|\\1))$/; // reference to (c) into another alternative\n\n/\\1(a)/; // forward reference to (a)\n\nRegExp('(a)\\\\2(b)'); // forward reference to (b)\n\n/(?:a)(b)\\2(c)/; // forward reference to (c)\n\n/\\k<foo>(?<foo>a)/; // forward reference to (?<foo>a)\n\n/(?<=(a)\\1)b/; // backward reference to (a) from within the same lookbehind\n\n/(?<!(a)\\1)b/; // backward reference to (a) from within the same lookbehind\n\nnew RegExp('(\\\\1)'); // nested reference to (\\1)\n\n/^((a)\\1)$/; // nested reference to ((a)\\1)\n\n/a(?<foo>(.)b\\1)/; // nested reference to (?<foo>(.)b\\1)\n\n/a(?!(b)).\\1/; // reference to (b) into a negative lookahead\n\n/(?<!(a))b\\1/; // reference to (a) into a negative lookbehind"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-backreference: \"error\"*/\n\n/^(?:(a)|(b)\\2)$/; // reference to (b)\n\n/(a)\\1/; // reference to (a)\n\nRegExp('(a)\\\\1(b)'); // reference to (a)\n\n/(a)(b)\\2(c)/; // reference to (b)\n\n/(?<foo>a)\\k<foo>/; // reference to (?<foo>a)\n\n/(?<=\\1(a))b/; // reference to (a), correctly before the group as they're in the same lookbehind\n\n/(?<=(a))b\\1/; // reference to (a), correctly after the group as the backreference isn't in the lookbehind\n\nnew RegExp('(.)\\\\1'); // reference to (.)\n\n/^(?:(a)\\1)$/; // reference to (a)\n\n/^((a)\\2)$/; // reference to (a)\n\n/a(?<foo>(.)b\\2)/; // reference to (.)\n\n/a(?!(b|c)\\1)./; // reference to (b|c), correct as it's from within the same negative lookahead\n\n/(?<!\\1(a))b/; // reference to (a), correct as it's from within the same negative lookbehind"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-backreference: \"error\"*/\n\n// comments describe behavior in a browser\n\n/^[\\1](a)$/.test(\"\\x01a\"); // true. In a character class, \\1 is treated as an octal escape sequence.\n/^\\1$/.test(\"\\x01\"); // true. Since the group 1 doesn't exist, \\1 is treated as an octal escape sequence.\n/^(a)\\1\\2$/.test(\"aa\\x02\"); // true. In this case, \\1 is a backreference, \\2 is an octal escape sequence."
            }
        ]
    },
    {
        "name": "require-atomic-updates",
        "url": "https://eslint.org/docs/latest/rules/require-atomic-updates",
        "description": "Disallow assignments that can lead to race conditions due to usage of await or yieldWhen writing asynchronous code, it is possible to create subtle race condition bugs. Consider the following example:This code looks like it will sum the results of calling getPageLength(1) and getPageLength(2), but in reality the final value of totalLength will only be the length of one of the two pages. The bug is in the statement totalLength += await getPageLength(pageNum);. This statement first reads an initial value of totalLength, then calls getPageLength(pageNum) and waits for that Promise to fulfill. Finally, it sets the value of totalLength to the sum of await getPageLength(pageNum) and the initial value of totalLength. If the totalLength variable is updated in a separate function call during the time that the getPageLength(pageNum) Promise is pending, that update will be lost because the new value is overwritten without being read.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint require-atomic-updates: error */\n\nlet result;\n\nasync function foo() {\n    result += await something;\n}\n\nasync function bar() {\n    result = result + await something;\n}\n\nasync function baz() {\n    result = result + doSomething(await somethingElse);\n}\n\nasync function qux() {\n    if (!result) {\n        result = await initialize();\n    }\n}\n\nfunction* generator() {\n    result += yield;\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint require-atomic-updates: error */\n\nlet result;\n\nasync function foobar() {\n    result = await something + result;\n}\n\nasync function baz() {\n    const tmp = doSomething(await somethingElse);\n    result += tmp;\n}\n\nasync function qux() {\n    if (!result) {\n        const tmp = await initialize();\n        if (!result) {\n            result = tmp;\n        }\n    }\n}\n\nasync function quux() {\n    let localVariable = 0;\n    localVariable += await something;\n}\n\nfunction* generator() {\n    result = (yield) + result;\n}"
            },
            {
                "type": "incorrect",
                "content": "/* eslint require-atomic-updates: error */\n\nasync function foo(obj) {\n    if (!obj.done) {\n        obj.something = await getSomething();\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint require-atomic-updates: error */\n\nasync function foo(obj) {\n    if (!obj.done) {\n        const tmp = await getSomething();\n        if (!obj.done) {\n            obj.something = tmp;\n        }\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint require-atomic-updates: [\"error\", { \"allowProperties\": true }] */\n\nasync function foo(obj) {\n    if (!obj.done) {\n        obj.something = await getSomething();\n    }\n}"
            }
        ]
    },
    {
        "name": "use-isnan",
        "url": "https://eslint.org/docs/latest/rules/use-isnan",
        "description": "Require calls to isNaN() when checking for NaNIn JavaScript, NaN is a special value of the Number type. It’s used to represent any of the “not-a-number” values represented by the double-precision 64-bit format as specified by the IEEE Standard for Binary Floating-Point Arithmetic.Because NaN is unique in JavaScript by not being equal to anything, including itself, the results of comparisons to NaN are confusing:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint use-isnan: \"error\"*/\n\nif (foo == NaN) {\n    // ...\n}\n\nif (foo != NaN) {\n    // ...\n}\n\nif (foo == Number.NaN) {\n    // ...\n}\n\nif (foo != Number.NaN) {\n    // ...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint use-isnan: \"error\"*/\n\nif (isNaN(foo)) {\n    // ...\n}\n\nif (!isNaN(foo)) {\n    // ...\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint use-isnan: [\"error\", {\"enforceForSwitchCase\": true}]*/\n\nswitch (foo) {\n    case NaN:\n        bar();\n        break;\n    case 1:\n        baz();\n        break;\n    // ...\n}\n\nswitch (NaN) {\n    case a:\n        bar();\n        break;\n    case b:\n        baz();\n        break;\n    // ...\n}\n\nswitch (foo) {\n    case Number.NaN:\n        bar();\n        break;\n    case 1:\n        baz();\n        break;\n    // ...\n}\n\nswitch (Number.NaN) {\n    case a:\n        bar();\n        break;\n    case b:\n        baz();\n        break;\n    // ...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint use-isnan: [\"error\", {\"enforceForSwitchCase\": true}]*/\n\nif (Number.isNaN(foo)) {\n    bar();\n} else {\n    switch (foo) {\n        case 1:\n            baz();\n            break;\n        // ...\n    }\n}\n\nif (Number.isNaN(a)) {\n    bar();\n} else if (Number.isNaN(b)) {\n    baz();\n} // ..."
            },
            {
                "type": "correct",
                "content": "/*eslint use-isnan: [\"error\", {\"enforceForSwitchCase\": false}]*/\n\nswitch (foo) {\n    case NaN:\n        bar();\n        break;\n    case 1:\n        baz();\n        break;\n    // ...\n}\n\nswitch (NaN) {\n    case a:\n        bar();\n        break;\n    case b:\n        baz();\n        break;\n    // ...\n}\n\nswitch (foo) {\n    case Number.NaN:\n        bar();\n        break;\n    case 1:\n        baz();\n        break;\n    // ...\n}\n\nswitch (Number.NaN) {\n    case a:\n        bar();\n        break;\n    case b:\n        baz();\n        break;\n    // ...\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint use-isnan: [\"error\", {\"enforceForIndexOf\": true}]*/\n\nvar hasNaN = myArray.indexOf(NaN) >= 0;\n\nvar firstIndex = myArray.indexOf(NaN);\n\nvar lastIndex = myArray.lastIndexOf(NaN);"
            },
            {
                "type": "correct",
                "content": "/*eslint use-isnan: [\"error\", {\"enforceForIndexOf\": true}]*/\n\nfunction myIsNaN(val) {\n    return typeof val === \"number\" && isNaN(val);\n}\n\nfunction indexOfNaN(arr) {\n    for (var i = 0; i < arr.length; i++) {\n        if (myIsNaN(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nfunction lastIndexOfNaN(arr) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n        if (myIsNaN(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvar hasNaN = myArray.some(myIsNaN);\n\nvar hasNaN = indexOfNaN(myArray) >= 0;\n\nvar firstIndex = indexOfNaN(myArray);\n\nvar lastIndex = lastIndexOfNaN(myArray);\n\n// ES2015\nvar hasNaN = myArray.some(Number.isNaN);\n\n// ES2015\nvar firstIndex = myArray.findIndex(Number.isNaN);\n\n// ES2016\nvar hasNaN = myArray.includes(NaN);"
            }
        ]
    },
    {
        "name": "valid-typeof",
        "url": "https://eslint.org/docs/latest/rules/valid-typeof",
        "description": "Enforce comparing typeof expressions against valid stringsFor a vast majority of use cases, the result of the typeof operator is one of the following string literals: \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"symbol\", and \"bigint\". It is usually a typing mistake to compare the result of a typeof operator to other string literals.This rule enforces comparing typeof expressions to valid string literals.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint valid-typeof: \"error\"*/\n\ntypeof foo === \"strnig\"\ntypeof foo == \"undefimed\"\ntypeof bar != \"nunber\"\ntypeof bar !== \"fucntion\""
            },
            {
                "type": "correct",
                "content": "/*eslint valid-typeof: \"error\"*/\n\ntypeof foo === \"string\"\ntypeof bar == \"undefined\"\ntypeof foo === baz\ntypeof bar === typeof qux"
            },
            {
                "type": "incorrect",
                "content": "/*eslint valid-typeof: [\"error\", { \"requireStringLiterals\": true }]*/\n\ntypeof foo === undefined\ntypeof bar == Object\ntypeof baz === \"strnig\"\ntypeof qux === \"some invalid type\"\ntypeof baz === anotherVariable\ntypeof foo == 5"
            },
            {
                "type": "correct",
                "content": "/*eslint valid-typeof: [\"error\", { \"requireStringLiterals\": true }]*/\n\ntypeof foo === \"undefined\"\ntypeof bar == \"object\"\ntypeof baz === \"string\"\ntypeof bar === typeof qux"
            }
        ]
    },
    {
        "name": "accessor-pairs",
        "url": "https://eslint.org/docs/latest/rules/accessor-pairs",
        "description": "Enforce getter and setter pairs in objects and classesIt’s a common mistake in JavaScript to create an object with just a setter for a property but never have a corresponding getter defined for it. Without a getter, you cannot read the property, so it ends up not being used.Here are some examples:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint accessor-pairs: \"error\"*/\n\nvar o = {\n    set a(value) {\n        this.val = value;\n    }\n};\n\n\nvar o = {d: 1};\nObject.defineProperty(o, 'c', {\n    set: function(value) {\n        this.val = value;\n    }\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint accessor-pairs: \"error\"*/\n\nvar o = {\n    set a(value) {\n        this.val = value;\n    },\n    get a() {\n        return this.val;\n    }\n};\n\nvar o = {d: 1};\nObject.defineProperty(o, 'c', {\n    set: function(value) {\n        this.val = value;\n    },\n    get: function() {\n        return this.val;\n    }\n});\n"
            },
            {
                "type": "incorrect",
                "content": "/*eslint accessor-pairs: [\"error\", { \"getWithoutSet\": true }]*/\n\nvar o = {\n    set a(value) {\n        this.val = value;\n    }\n};\n\nvar o = {\n    get a() {\n        return this.val;\n    }\n};\n\nvar o = {d: 1};\nObject.defineProperty(o, 'c', {\n    set: function(value) {\n        this.val = value;\n    }\n});\n\nvar o = {d: 1};\nObject.defineProperty(o, 'c', {\n    get: function() {\n        return this.val;\n    }\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint accessor-pairs: [\"error\", { \"getWithoutSet\": true }]*/\nvar o = {\n    set a(value) {\n        this.val = value;\n    },\n    get a() {\n        return this.val;\n    }\n};\n\nvar o = {d: 1};\nObject.defineProperty(o, 'c', {\n    set: function(value) {\n        this.val = value;\n    },\n    get: function() {\n        return this.val;\n    }\n});\n"
            },
            {
                "type": "incorrect",
                "content": "/*eslint accessor-pairs: [\"error\", { \"getWithoutSet\": true, \"enforceForClassMembers\": true }]*/\n\nclass Foo {\n    get a() {\n        return this.val;\n    }\n}\n\nclass Bar {\n    static get a() {\n        return this.val;\n    }\n}\n\nconst Baz = class {\n    get a() {\n        return this.val;\n    }\n    static set a(value) {\n        this.val = value;\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint accessor-pairs: [\"error\", { \"setWithoutGet\": true, \"enforceForClassMembers\": true }]*/\n\nclass Foo {\n    set a(value) {\n        this.val = value;\n    }\n}\n\nconst Bar = class {\n    static set a(value) {\n        this.val = value;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint accessor-pairs: [\"error\", {\n    \"getWithoutSet\": true, \"setWithoutGet\": true, \"enforceForClassMembers\": false\n}]*/\n\nclass Foo {\n    get a() {\n        return this.val;\n    }\n}\n\nclass Bar {\n    static set a(value) {\n        this.val = value;\n    }\n}\n\nconst Baz = class {\n    static get a() {\n        return this.val;\n    }\n}\n\nconst Quux = class {\n    set a(value) {\n        this.val = value;\n    }\n}"
            }
        ]
    },
    {
        "name": "arrow-body-style",
        "url": "https://eslint.org/docs/latest/rules/arrow-body-style",
        "description": "Require braces around arrow function bodiesArrow functions have two syntactic forms for their function bodies. They may be defined with a block body (denoted by curly braces) () => { ... } or with a single expression () => ..., whose value is implicitly returned.This rule can enforce or disallow the use of braces around arrow function body.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint arrow-body-style: [\"error\", \"always\"]*/\n/*eslint-env es6*/\nlet foo = () => 0;"
            },
            {
                "type": "correct",
                "content": "let foo = () => {\n    return 0;\n};\nlet foo = (retv, name) => {\n    retv[name] = true;\n    return retv;\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint arrow-body-style: [\"error\", \"as-needed\"]*/\n/*eslint-env es6*/\n\nlet foo = () => {\n    return 0;\n};\nlet foo = () => {\n    return {\n       bar: {\n            foo: 1,\n            bar: 2,\n        }\n    };\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint arrow-body-style: [\"error\", \"as-needed\"]*/\n/*eslint-env es6*/\n\nlet foo = () => 0;\nlet foo = (retv, name) => {\n    retv[name] = true;\n    return retv;\n};\nlet foo = () => ({\n    bar: {\n        foo: 1,\n        bar: 2,\n    }\n});\nlet foo = () => { bar(); };\nlet foo = () => {};\nlet foo = () => { /* do nothing */ };\nlet foo = () => {\n    // do nothing.\n};\nlet foo = () => ({ bar: 0 });"
            },
            {
                "type": "incorrect",
                "content": "/*eslint arrow-body-style: [\"error\", \"as-needed\", { \"requireReturnForObjectLiteral\": true }]*/\n/*eslint-env es6*/\nlet foo = () => ({});\nlet foo = () => ({ bar: 0 });"
            },
            {
                "type": "correct",
                "content": "/*eslint arrow-body-style: [\"error\", \"as-needed\", { \"requireReturnForObjectLiteral\": true }]*/\n/*eslint-env es6*/\n\nlet foo = () => {};\nlet foo = () => { return { bar: 0 }; };"
            },
            {
                "type": "incorrect",
                "content": "/*eslint arrow-body-style: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nlet foo = () => {\n    return 0;\n};\nlet foo = (retv, name) => {\n    retv[name] = true;\n    return retv;\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint arrow-body-style: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nlet foo = () => 0;\nlet foo = () => ({ foo: 0 });"
            }
        ]
    },
    {
        "name": "block-scoped-var",
        "url": "https://eslint.org/docs/latest/rules/block-scoped-var",
        "description": "Enforce the use of variables within the scope they are definedThe block-scoped-var rule generates warnings when variables are used outside of the block in which they were defined. This emulates C-style block scope.This rule aims to reduce the usage of variables outside of their binding context and emulate traditional block scope from other languages. This is to help newcomers to the language avoid difficult bugs with variable hoisting.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint block-scoped-var: \"error\"*/\n\nfunction doIf() {\n    if (true) {\n        var build = true;\n    }\n\n    console.log(build);\n}\n\nfunction doIfElse() {\n    if (true) {\n        var build = true;\n    } else {\n        var build = false;\n    }\n}\n\nfunction doTryCatch() {\n    try {\n        var build = 1;\n    } catch (e) {\n        var f = build;\n    }\n}\n\nfunction doFor() {\n    for (var x = 1; x < 10; x++) {\n        var y = f(x);\n    }\n    console.log(y);\n}\n\nclass C {\n    static {\n        if (something) {\n            var build = true;\n        }\n        build = false;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint block-scoped-var: \"error\"*/\n\nfunction doIf() {\n    var build;\n\n    if (true) {\n        build = true;\n    }\n\n    console.log(build);\n}\n\nfunction doIfElse() {\n    var build;\n\n    if (true) {\n        build = true;\n    } else {\n        build = false;\n    }\n}\n\nfunction doTryCatch() {\n    var build;\n    var f;\n\n    try {\n        build = 1;\n    } catch (e) {\n        f = build;\n    }\n}\n\nfunction doFor() {\n    for (var x = 1; x < 10; x++) {\n        var y = f(x);\n        console.log(y);\n    }\n}\n\nclass C {\n    static {\n        var build = false;\n        if (something) {\n            build = true;\n        }\n    }\n}"
            }
        ]
    },
    {
        "name": "camelcase",
        "url": "https://eslint.org/docs/latest/rules/camelcase",
        "description": "Enforce camelcase naming conventionWhen it comes to naming variables, style guides generally fall into one of two camps: camelcase (variableName) and underscores (variable_name). This rule focuses on using the camelcase approach. If your style guide calls for camelCasing your variable names, then this rule is for you!This rule looks for any underscores (_) located within the source code. It ignores leading and trailing underscores and only checks those in the middle of a variable name. If ESLint decides that the variable is a constant (all uppercase), then no warning will be thrown. Otherwise, a warning will be thrown. This rule only flags definitions and assignments but not function calls. In case of ES6 import statements, this rule only targets the name of the variable that will be imported into the local module scope.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint camelcase: \"error\"*/\n\nimport { no_camelcased } from \"external-module\"\n\nvar my_favorite_color = \"#112C85\";\n\nfunction do_something() {\n    // ...\n}\n\nobj.do_something = function() {\n    // ...\n};\n\nfunction foo({ no_camelcased }) {\n    // ...\n};\n\nfunction foo({ isCamelcased: no_camelcased }) {\n    // ...\n}\n\nfunction foo({ no_camelcased = 'default value' }) {\n    // ...\n};\n\nvar obj = {\n    my_pref: 1\n};\n\nvar { category_id = 1 } = query;\n\nvar { foo: no_camelcased } = bar;\n\nvar { foo: bar_baz = 1 } = quz;"
            },
            {
                "type": "correct",
                "content": "/*eslint camelcase: \"error\"*/\n\nimport { no_camelcased as camelCased } from \"external-module\";\n\nvar myFavoriteColor   = \"#112C85\";\nvar _myFavoriteColor  = \"#112C85\";\nvar myFavoriteColor_  = \"#112C85\";\nvar MY_FAVORITE_COLOR = \"#112C85\";\nvar foo = bar.baz_boom;\nvar foo = { qux: bar.baz_boom };\n\nobj.do_something();\ndo_something();\nnew do_something();\n\nvar { category_id: category } = query;\n\nfunction foo({ isCamelCased }) {\n    // ...\n};\n\nfunction foo({ isCamelCased: isAlsoCamelCased }) {\n    // ...\n}\n\nfunction foo({ isCamelCased = 'default value' }) {\n    // ...\n};\n\nvar { categoryId = 1 } = query;\n\nvar { foo: isCamelCased } = bar;\n\nvar { foo: isCamelCased = 1 } = quz;\n"
            },
            {
                "type": "correct",
                "content": "/*eslint camelcase: [\"error\", {properties: \"never\"}]*/\n\nvar obj = {\n    my_pref: 1\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint camelcase: \"error\"*/\n\nvar { category_id } = query;\n\nvar { category_id = 1 } = query;\n\nvar { category_id: category_id } = query;\n\nvar { category_id: category_alias } = query;\n\nvar { category_id: categoryId, ...other_props } = query;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint camelcase: [\"error\", {ignoreDestructuring: true}]*/\n\nvar { category_id: category_alias } = query;\n\nvar { category_id, ...other_props } = query;"
            },
            {
                "type": "correct",
                "content": "/*eslint camelcase: [\"error\", {ignoreDestructuring: true}]*/\n\nvar { category_id } = query;\n\nvar { category_id = 1 } = query;\n\nvar { category_id: category_id } = query;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint camelcase: [\"error\", {ignoreDestructuring: true}]*/\n\nvar { some_property } = obj; // allowed by {ignoreDestructuring: true}\nvar foo = some_property + 1; // error, ignoreDestructuring does not apply to this statement"
            },
            {
                "type": "correct",
                "content": "/*eslint camelcase: [\"error\", {ignoreDestructuring: true}]*/\n\nvar { some_property, ...rest } = obj;\n// do something with 'rest', nothing with 'some_property'"
            },
            {
                "type": "correct",
                "content": "/*eslint camelcase: [\"error\", {\"properties\": \"never\", ignoreDestructuring: true}]*/\n\nvar { some_property } = obj;\ndoSomething({ some_property });"
            },
            {
                "type": "incorrect",
                "content": "/*eslint camelcase: \"error\"*/\n\nimport { snake_cased } from 'mod';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint camelcase: [\"error\", {ignoreImports: true}]*/\n\nimport default_import from 'mod';\n\nimport * as namespaced_import from 'mod';"
            },
            {
                "type": "correct",
                "content": "/*eslint camelcase: [\"error\", {ignoreImports: true}]*/\n\nimport { snake_cased } from 'mod';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint camelcase: [\"error\", {ignoreGlobals: false}]*/\n/* global no_camelcased */\n\nconst foo = no_camelcased;"
            },
            {
                "type": "correct",
                "content": "/*eslint camelcase: [\"error\", {ignoreGlobals: true}]*/\n/* global no_camelcased */\n\nconst foo = no_camelcased;"
            },
            {
                "type": "correct",
                "content": "/*eslint camelcase: [\"error\", {allow: [\"UNSAFE_componentWillMount\"]}]*/\n\nfunction UNSAFE_componentWillMount() {\n    // ...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint camelcase: [\"error\", {allow: [\"^UNSAFE_\"]}]*/\n\nfunction UNSAFE_componentWillMount() {\n    // ...\n}\n\nfunction UNSAFE_componentWillMount() {\n    // ...\n}"
            }
        ]
    },
    {
        "name": "capitalized-comments",
        "url": "https://eslint.org/docs/latest/rules/capitalized-comments",
        "description": "Enforce or disallow capitalization of the first letter of a commentComments are useful for leaving information for future developers. In order for that information to be useful and not distracting, it is sometimes desirable for comments to follow a particular style. One element of comment formatting styles is whether the first word of a comment should be capitalized or lowercase.In general, no comment style is any more or less valid than any others, but many developers would agree that a consistent style can improve a project’s maintainability.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint capitalized-comments: [\"error\"] */\n\n// lowercase comment\n"
            },
            {
                "type": "correct",
                "content": "\n// Capitalized comment\n\n// 1. Non-letter at beginning of comment\n\n// 丈 Non-Latin character at beginning of comment\n\n/* eslint semi:off */\n/* eslint-env node */\n/* eslint-disable */\n/* eslint-enable */\n/* istanbul ignore next */\n/* jscs:enable */\n/* jshint asi:true */\n/* global foo */\n/* globals foo */\n/* exported myVar */\n// eslint-disable-line\n// eslint-disable-next-line\n// https://github.com\n"
            },
            {
                "type": "incorrect",
                "content": "/* eslint capitalized-comments: [\"error\", \"always\"] */\n\n// lowercase comment\n"
            },
            {
                "type": "correct",
                "content": "/* eslint capitalized-comments: [\"error\", \"always\"] */\n\n// Capitalized comment\n\n// 1. Non-letter at beginning of comment\n\n// 丈 Non-Latin character at beginning of comment\n\n/* eslint semi:off */\n/* eslint-env node */\n/* eslint-disable */\n/* eslint-enable */\n/* istanbul ignore next */\n/* jscs:enable */\n/* jshint asi:true */\n/* global foo */\n/* globals foo */\n/* exported myVar */\n// eslint-disable-line\n// eslint-disable-next-line\n// https://github.com\n"
            },
            {
                "type": "incorrect",
                "content": "/* eslint capitalized-comments: [\"error\", \"never\"] */\n\n// Capitalized comment\n"
            },
            {
                "type": "correct",
                "content": "/* eslint capitalized-comments: [\"error\", \"never\"] */\n\n// lowercase comment\n\n// 1. Non-letter at beginning of comment\n\n// 丈 Non-Latin character at beginning of comment\n"
            },
            {
                "type": "correct",
                "content": "/* eslint capitalized-comments: [\"error\", \"always\", { \"ignorePattern\": \"pragma\" }] */\n\nfunction foo() {\n    /* pragma wrap(true) */\n}\n"
            },
            {
                "type": "correct",
                "content": "/* eslint capitalized-comments: [\"error\", \"always\", { \"ignoreInlineComments\": true }] */\n\nfunction foo(/* ignored */ a) {\n}\n"
            },
            {
                "type": "correct",
                "content": "/* eslint capitalized-comments: [\"error\", \"always\", { \"ignoreConsecutiveComments\": true }] */\n\n// This comment is valid since it has the correct capitalization.\n// this comment is ignored since it follows another comment,\n// and this one as well because it follows yet another comment.\n\n/* Here is a block comment which has the correct capitalization, */\n/* but this one is ignored due to being consecutive; */\n/*\n * in fact, even if any of these are multi-line, that is fine too.\n */"
            },
            {
                "type": "incorrect",
                "content": "/* eslint capitalized-comments: [\"error\", \"always\", { \"ignoreConsecutiveComments\": true }] */\n\n// this comment is invalid, but only on this line.\n// this comment does NOT get reported, since it is a consecutive comment."
            },
            {
                "type": "incorrect",
                "content": "/* eslint capitalized-comments: [\"error\", \"always\", { \"block\": { \"ignorePattern\": \"blockignore\" } }] */\n\n// capitalized line comment, this is incorrect, blockignore does not help here\n/* lowercased block comment, this is incorrect too */\n"
            },
            {
                "type": "correct",
                "content": "/* eslint capitalized-comments: [\"error\", \"always\", { \"block\": { \"ignorePattern\": \"blockignore\" } }] */\n\n// Uppercase line comment, this is correct\n/* blockignore lowercase block comment, this is correct due to ignorePattern */\n"
            }
        ]
    },
    {
        "name": "class-methods-use-this",
        "url": "https://eslint.org/docs/latest/rules/class-methods-use-this",
        "description": "Enforce that class methods utilize thisIf a class method does not use this, it can sometimes be made into a static function. If you do convert the method into a static function, instances of the class that call that particular method have to be converted to a static call as well (MyClass.callStaticMethod())It’s possible to have a class method which doesn’t use this, such as:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint class-methods-use-this: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    foo() {\n        console.log(\"Hello World\");     /*error Expected 'this' to be used by class method 'foo'.*/\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint class-methods-use-this: \"error\"*/\n/*eslint-env es6*/\nclass A {\n    foo() {\n        this.bar = \"Hello World\"; // OK, this is used\n    }\n}\n\nclass A {\n    constructor() {\n        // OK. constructor is exempt\n    }\n}\n\nclass A {\n    static foo() {\n        // OK. static methods aren't expected to use this.\n    }\n\n    static {\n        // OK. static blocks are exempt.\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint class-methods-use-this: \"error\"*/\n\nclass A {\n    foo() {\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint class-methods-use-this: [\"error\", { \"exceptMethods\": [\"foo\", \"#bar\"] }] */\n\nclass A {\n    foo() {\n    }\n    #bar() {\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint class-methods-use-this: [\"error\", { \"enforceForClassFields\": true }] */\n\nclass A {\n    foo = () => {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint class-methods-use-this: [\"error\", { \"enforceForClassFields\": true }] */\n\nclass A {\n    foo = () => {this;}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint class-methods-use-this: [\"error\", { \"enforceForClassFields\": false }] */\n\nclass A {\n    foo = () => {}\n}"
            }
        ]
    },
    {
        "name": "complexity",
        "url": "https://eslint.org/docs/latest/rules/complexity",
        "description": "Enforce a maximum cyclomatic complexity allowed in a programCyclomatic complexity measures the number of linearly independent paths through a program’s source code. This rule allows setting a cyclomatic complexity threshold.This rule is aimed at reducing code complexity by capping the amount of cyclomatic complexity allowed in a program. As such, it will warn when the cyclomatic complexity crosses the configured threshold (default is 20).",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint complexity: [\"error\", 2]*/\n\nfunction a(x) {\n    if (true) {\n        return x;\n    } else if (false) {\n        return x+1;\n    } else {\n        return 4; // 3rd path\n    }\n}\n\nfunction b() {\n    foo ||= 1;\n    bar &&= 1;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint complexity: [\"error\", 2]*/\n\nfunction a(x) {\n    if (true) {\n        return x;\n    } else {\n        return 4;\n    }\n}\n\nfunction b() {\n    foo ||= 1;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint complexity: [\"error\", 2]*/\n\nclass C {\n    x = a || b || c; // this initializer has complexity = 3\n}\n\nclass D { // this static block has complexity = 3\n    static {\n        if (foo) {\n            bar = baz || qux;\n        }\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint complexity: [\"error\", 2]*/\n\nfunction foo() { // this function has complexity = 1\n    class C {\n        x = a + b; // this initializer has complexity = 1\n        y = c || d; // this initializer has complexity = 2\n        z = e && f; // this initializer has complexity = 2\n\n        static p = g || h; // this initializer has complexity = 2\n        static q = i ? j : k; // this initializer has complexity = 2\n\n        static { // this static block has complexity = 2\n            if (foo) {\n                baz = bar;\n            }\n        }\n\n        static { // this static block has complexity = 2\n            qux = baz || quux;\n        }\n    }\n}"
            }
        ]
    },
    {
        "name": "consistent-return",
        "url": "https://eslint.org/docs/latest/rules/consistent-return",
        "description": "Require return statements to either always or never specify valuesUnlike statically-typed languages which enforce that a function returns a specified type of value, JavaScript allows different code paths in a function to return different types of values.A confusing aspect of JavaScript is that a function returns undefined if any of the following are true:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint consistent-return: \"error\"*/\n\nfunction doSomething(condition) {\n    if (condition) {\n        return true;\n    } else {\n        return;\n    }\n}\n\nfunction doSomething(condition) {\n    if (condition) {\n        return true;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint consistent-return: \"error\"*/\n\nfunction doSomething(condition) {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction Foo() {\n    if (!(this instanceof Foo)) {\n        return new Foo();\n    }\n\n    this.a = 0;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint consistent-return: [\"error\", { \"treatUndefinedAsUnspecified\": false }]*/\n\nfunction foo(callback) {\n    if (callback) {\n        return void callback();\n    }\n    // no return statement\n}\n\nfunction bar(condition) {\n    if (condition) {\n        return undefined;\n    }\n    // no return statement\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint consistent-return: [\"error\", { \"treatUndefinedAsUnspecified\": true }]*/\n\nfunction foo(callback) {\n    if (callback) {\n        return void callback();\n    }\n    return true;\n}\n\nfunction bar(condition) {\n    if (condition) {\n        return undefined;\n    }\n    return true;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint consistent-return: [\"error\", { \"treatUndefinedAsUnspecified\": true }]*/\n\nfunction foo(callback) {\n    if (callback) {\n        return void callback();\n    }\n    // no return statement\n}\n\nfunction bar(condition) {\n    if (condition) {\n        return undefined;\n    }\n    // no return statement\n}"
            }
        ]
    },
    {
        "name": "consistent-this",
        "url": "https://eslint.org/docs/latest/rules/consistent-this",
        "description": "Enforce consistent naming when capturing the current execution contextIt is often necessary to capture the current execution context in order to make it available subsequently. A prominent example of this are jQuery callbacks:There are many commonly used aliases for this such as that, self or me. It is desirable to ensure that whichever alias the team agrees upon is used consistently throughout the application.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint consistent-this: [\"error\", \"that\"]*/\n\nvar that = 42;\n\nvar self = this;\n\nthat = 42;\n\nself = this;"
            },
            {
                "type": "correct",
                "content": "/*eslint consistent-this: [\"error\", \"that\"]*/\n\nvar that = this;\n\nvar self = 42;\n\nvar self;\n\nthat = this;\n\nfoo.bar = this;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint consistent-this: [\"error\", \"that\"]*/\n\nvar that;\nfunction f() {\n    that = this;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint consistent-this: [\"error\", \"that\"]*/\n\nvar that;\nthat = this;\n\nvar foo, that;\nfoo = 42;\nthat = this;"
            }
        ]
    },
    {
        "name": "curly",
        "url": "https://eslint.org/docs/latest/rules/curly",
        "description": "Enforce consistent brace style for all control statementsJavaScript allows the omission of curly braces when a block contains only one statement. However, it is considered by many to be best practice to never omit curly braces around blocks, even when they are optional, because it can lead to bugs and reduces code clarity. So the following:Can be rewritten as:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint curly: \"error\"*/\n\nif (foo) foo++;\n\nwhile (bar)\n    baz();\n\nif (foo) {\n    baz();\n} else qux();"
            },
            {
                "type": "correct",
                "content": "/*eslint curly: \"error\"*/\n\nif (foo) {\n    foo++;\n}\n\nwhile (bar) {\n    baz();\n}\n\nif (foo) {\n    baz();\n} else {\n    qux();\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint curly: [\"error\", \"multi\"]*/\n\nif (foo) {\n    foo++;\n}\n\nif (foo) bar();\nelse {\n    foo++;\n}\n\nwhile (true) {\n    doSomething();\n}\n\nfor (var i=0; i < items.length; i++) {\n    doSomething();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint curly: [\"error\", \"multi\"]*/\n\nif (foo) foo++;\n\nelse foo();\n\nwhile (true) {\n    doSomething();\n    doSomethingElse();\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint curly: [\"error\", \"multi-line\"]*/\n\nif (foo)\n  doSomething();\nelse\n  doSomethingElse();\n\nif (foo) foo(\n  bar,\n  baz);"
            },
            {
                "type": "correct",
                "content": "/*eslint curly: [\"error\", \"multi-line\"]*/\n\nif (foo) foo++; else doSomething();\n\nif (foo) foo++;\nelse if (bar) baz()\nelse doSomething();\n\ndo something();\nwhile (foo);\n\nwhile (foo\n  && bar) baz();\n\nif (foo) {\n    foo++;\n}\n\nif (foo) { foo++; }\n\nwhile (true) {\n    doSomething();\n    doSomethingElse();\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint curly: [\"error\", \"multi-or-nest\"]*/\n\nif (!foo)\n    foo = {\n        bar: baz,\n        qux: foo\n    };\n\nwhile (true)\n  if(foo)\n      doSomething();\n  else\n      doSomethingElse();\n\nif (foo) {\n    foo++;\n}\n\nwhile (true) {\n    doSomething();\n}\n\nfor (var i = 0; foo; i++) {\n    doSomething();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint curly: [\"error\", \"multi-or-nest\"]*/\n\nif (!foo) {\n    foo = {\n        bar: baz,\n        qux: foo\n    };\n}\n\nwhile (true) {\n  if(foo)\n      doSomething();\n  else\n      doSomethingElse();\n}\n\nif (foo)\n    foo++;\n\nwhile (true)\n    doSomething();\n\nfor (var i = 0; foo; i++)\n    doSomething();"
            },
            {
                "type": "correct",
                "content": "/*eslint curly: [\"error\", \"multi-or-nest\"]*/\n\nif (foo)\n    // some comment\n    bar();\n\nif (foo) {\n    // some comment\n    bar();\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint curly: [\"error\", \"multi\", \"consistent\"]*/\n\nif (foo) {\n    bar();\n    baz();\n} else\n    buz();\n\nif (foo)\n    bar();\nelse if (faa)\n    bor();\nelse {\n    other();\n    things();\n}\n\nif (true)\n    foo();\nelse {\n    baz();\n}\n\nif (foo) {\n    foo++;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint curly: [\"error\", \"multi\", \"consistent\"]*/\n\nif (foo) {\n    bar();\n    baz();\n} else {\n    buz();\n}\n\nif (foo) {\n    bar();\n} else if (faa) {\n    bor();\n} else {\n    other();\n    things();\n}\n\nif (true)\n    foo();\nelse\n    baz();\n\nif (foo)\n    foo++;\n"
            }
        ]
    },
    {
        "name": "default-case",
        "url": "https://eslint.org/docs/latest/rules/default-case",
        "description": "Require default cases in switch statementsSome code conventions require that all switch statements have a default case, even if the default case is empty, such as:The thinking is that it’s better to always explicitly state what the default behavior should be so that it’s clear whether or not the developer forgot to include the default behavior by mistake.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint default-case: \"error\"*/\n\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n}\n"
            },
            {
                "type": "correct",
                "content": "/*eslint default-case: \"error\"*/\n\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n\n    default:\n        /* code */\n        break;\n}\n\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n\n    // no default\n}\n\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n\n    // No Default\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint default-case: [\"error\", { \"commentPattern\": \"^skip\\\\sdefault\" }]*/\n\nswitch(a) {\n    case 1:\n        /* code */\n        break;\n\n    // skip default\n}\n\nswitch(a) {\n    case 1:\n        /* code */\n        break;\n\n    // skip default case\n}"
            }
        ]
    },
    {
        "name": "default-case-last",
        "url": "https://eslint.org/docs/latest/rules/default-case-last",
        "description": "Enforce default clauses in switch statements to be lastA switch statement can optionally have a default clause.If present, it’s usually the last clause, but it doesn’t need to be. It is also allowed to put the default clause before all case clauses, or anywhere between. The behavior is mostly the same as if it was the last clause. The default block will be still executed only if there is no match in the case clauses (including those defined after the default), but there is also the ability to “fall through” from the default clause to the following clause in the list. However, such flow is not common and it would be confusing to the readers.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint default-case-last: \"error\"*/\n\nswitch (foo) {\n    default:\n        bar();\n        break;\n    case \"a\":\n        baz();\n        break;\n}\n\nswitch (foo) {\n    case 1:\n        bar();\n        break;\n    default:\n        baz();\n        break;\n    case 2:\n        quux();\n        break;\n}\n\nswitch (foo) {\n    case \"x\":\n        bar();\n        break;\n    default:\n    case \"y\":\n        baz();\n        break;\n}\n\nswitch (foo) {\n    default:\n        break;\n    case -1:\n        bar();\n        break;\n}\n\nswitch (foo) {\n  default:\n    doSomethingIfNotZero();\n  case 0:\n    doSomethingAnyway();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint default-case-last: \"error\"*/\n\nswitch (foo) {\n    case \"a\":\n        baz();\n        break;\n    default:\n        bar();\n        break;\n}\n\nswitch (foo) {\n    case 1:\n        bar();\n        break;\n    case 2:\n        quux();\n        break;\n    default:\n        baz();\n        break;\n}\n\nswitch (foo) {\n    case \"x\":\n        bar();\n        break;\n    case \"y\":\n    default:\n        baz();\n        break;\n}\n\nswitch (foo) {\n    case -1:\n        bar();\n        break;\n}\n\nif (foo !== 0) {\n    doSomethingIfNotZero();\n}\ndoSomethingAnyway();"
            }
        ]
    },
    {
        "name": "default-param-last",
        "url": "https://eslint.org/docs/latest/rules/default-param-last",
        "description": "Enforce default parameters to be lastPutting default parameter at last allows function calls to omit optional tail arguments.This rule enforces default parameters to be the last of parameters.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint default-param-last: [\"error\"] */\n\nfunction f(a = 0, b) {}\n\nfunction f(a, b = 0, c) {}"
            },
            {
                "type": "correct",
                "content": "/* eslint default-param-last: [\"error\"] */\n\nfunction f(a, b = 0) {}"
            }
        ]
    },
    {
        "name": "dot-notation",
        "url": "https://eslint.org/docs/latest/rules/dot-notation",
        "description": "Enforce dot notation whenever possibleIn JavaScript, one can access properties using the dot notation (foo.bar) or square-bracket notation (foo[\"bar\"]). However, the dot notation is often preferred because it is easier to read, less verbose, and works better with aggressive JavaScript minimizers.This rule is aimed at maintaining code consistency and improving code readability by encouraging use of the dot notation style whenever possible. As such, it will warn when it encounters an unnecessary use of square-bracket notation.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint dot-notation: \"error\"*/\n\nvar x = foo[\"bar\"];"
            },
            {
                "type": "correct",
                "content": "/*eslint dot-notation: \"error\"*/\n\nvar x = foo.bar;\n\nvar x = foo[bar];    // Property name is a variable, square-bracket notation required"
            },
            {
                "type": "correct",
                "content": "/*eslint dot-notation: [\"error\", { \"allowKeywords\": false }]*/\n\nvar foo = { \"class\": \"CS 101\" }\nvar x = foo[\"class\"]; // Property name is a reserved word, square-bracket notation required"
            },
            {
                "type": "correct",
                "content": "/*eslint dot-notation: [\"error\", { \"allowKeywords\": false }]*/\n\nclass C {\n    #in;\n    foo() {\n        this.#in; // Dot notation is required for private identifiers\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint camelcase: \"error\"*/\n/*eslint dot-notation: [\"error\", { \"allowPattern\": \"^[a-z]+(_[a-z]+)+$\" }]*/\n\nvar data = {};\ndata.foo_bar = 42;\n\nvar data = {};\ndata[\"fooBar\"] = 42;\n\nvar data = {};\ndata[\"foo_bar\"] = 42; // no warning"
            }
        ]
    },
    {
        "name": "eqeqeq",
        "url": "https://eslint.org/docs/latest/rules/eqeqeq",
        "description": "Require the use of === and !==It is considered good practice to use the type-safe equality operators === and !== instead of their regular counterparts == and !=.The reason for this is that == and != do type coercion which follows the rather obscure Abstract Equality Comparison Algorithm. For instance, the following statements are all considered true:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint eqeqeq: \"error\"*/\n\nif (x == 42) { }\n\nif (\"\" == text) { }\n\nif (obj.getStuff() != undefined) { }"
            },
            {
                "type": "incorrect",
                "content": "/*eslint eqeqeq: [\"error\", \"always\"]*/\n\na == b\nfoo == true\nbananas != 1\nvalue == undefined\ntypeof foo == 'undefined'\n'hello' != 'world'\n0 == 0\ntrue == true\nfoo == null\n"
            },
            {
                "type": "correct",
                "content": "/*eslint eqeqeq: [\"error\", \"always\"]*/\n\na === b\nfoo === true\nbananas !== 1\nvalue === undefined\ntypeof foo === 'undefined'\n'hello' !== 'world'\n0 === 0\ntrue === true\nfoo === null\n"
            },
            {
                "type": "incorrect",
                "content": "/*eslint eqeqeq: [\"error\", \"smart\"]*/\n\n// comparing two variables requires ===\na == b\n\n// only one side is a literal\nfoo == true\nbananas != 1\n\n// comparing to undefined requires ===\nvalue == undefined"
            },
            {
                "type": "correct",
                "content": "/*eslint eqeqeq: [\"error\", \"smart\"]*/\n\ntypeof foo == 'undefined'\n'hello' != 'world'\n0 == 0\ntrue == true\nfoo == null"
            }
        ]
    },
    {
        "name": "func-name-matching",
        "url": "https://eslint.org/docs/latest/rules/func-name-matching",
        "description": "Require function names to match the name of the variable or property to which they are assignedThis rule requires function names to match the name of the variable or property to which they are assigned. The rule will ignore property assignments where the property name is a literal that is not a valid identifier in the ECMAScript version specified in your configuration (default ES5).Examples of incorrect code for this rule:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint func-name-matching: \"error\"*/\n\nvar foo = function bar() {};\nfoo = function bar() {};\nobj.foo = function bar() {};\nobj['foo'] = function bar() {};\nvar obj = {foo: function bar() {}};\n({['foo']: function bar() {}});\n\nclass C {\n    foo = function bar() {};\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-name-matching: [\"error\", \"never\"] */\n\nvar foo = function foo() {};\nfoo = function foo() {};\nobj.foo = function foo() {};\nobj['foo'] = function foo() {};\nvar obj = {foo: function foo() {}};\n({['foo']: function foo() {}});\n\nclass C {\n    foo = function foo() {};\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint func-name-matching: \"error\"*/\n/*eslint func-name-matching: [\"error\", \"always\"]*/ // these are equivalent\n/*eslint-env es6*/\n\nvar foo = function foo() {};\nvar foo = function() {};\nvar foo = () => {};\nfoo = function foo() {};\n\nobj.foo = function foo() {};\nobj['foo'] = function foo() {};\nobj['foo//bar'] = function foo() {};\nobj[foo] = function bar() {};\n\nvar obj = {foo: function foo() {}};\nvar obj = {[foo]: function bar() {}};\nvar obj = {'foo//bar': function foo() {}};\nvar obj = {foo: function() {}};\n\nobj['x' + 2] = function bar(){};\nvar [ bar ] = [ function bar(){} ];\n({[foo]: function bar() {}})\n\nclass C {\n    foo = function foo() {};\n    baz = function() {};\n}\n\n// private names are ignored\nclass D {\n    #foo = function foo() {};\n    #bar = function foo() {};\n    baz() {\n        this.#foo = function foo() {};\n        this.#foo = function bar() {};\n    }\n}\n\nmodule.exports = function foo(name) {};\nmodule['exports'] = function foo(name) {};"
            },
            {
                "type": "correct",
                "content": "/*eslint func-name-matching: [\"error\", \"never\"] */\n/*eslint-env es6*/\n\nvar foo = function bar() {};\nvar foo = function() {};\nvar foo = () => {};\nfoo = function bar() {};\n\nobj.foo = function bar() {};\nobj['foo'] = function bar() {};\nobj['foo//bar'] = function foo() {};\nobj[foo] = function foo() {};\n\nvar obj = {foo: function bar() {}};\nvar obj = {[foo]: function foo() {}};\nvar obj = {'foo//bar': function foo() {}};\nvar obj = {foo: function() {}};\n\nobj['x' + 2] = function bar(){};\nvar [ bar ] = [ function bar(){} ];\n({[foo]: function bar() {}})\n\nclass C {\n    foo = function bar() {};\n    baz = function() {};\n}\n\n// private names are ignored\nclass D {\n    #foo = function foo() {};\n    #bar = function foo() {};\n    baz() {\n        this.#foo = function foo() {};\n        this.#foo = function bar() {};\n    }\n}\n\nmodule.exports = function foo(name) {};\nmodule['exports'] = function foo(name) {};"
            },
            {
                "type": "correct",
                "content": "/*eslint func-name-matching: [\"error\", { \"considerPropertyDescriptor\": true }]*/\n/*eslint func-name-matching: [\"error\", \"always\", { \"considerPropertyDescriptor\": true }]*/ // these are equivalent\nvar obj = {};\nObject.create(obj, {foo:{value: function foo() {}}});\nObject.defineProperty(obj, 'bar', {value: function bar() {}});\nObject.defineProperties(obj, {baz:{value: function baz() {} }});\nReflect.defineProperty(obj, 'foo', {value: function foo() {}});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-name-matching: [\"error\", { \"considerPropertyDescriptor\": true }]*/\n/*eslint func-name-matching: [\"error\", \"always\", { \"considerPropertyDescriptor\": true }]*/ // these are equivalent\nvar obj = {};\nObject.create(obj, {foo:{value: function bar() {}}});\nObject.defineProperty(obj, 'bar', {value: function baz() {}});\nObject.defineProperties(obj, {baz:{value: function foo() {} }});\nReflect.defineProperty(obj, 'foo', {value: function value() {}});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-name-matching: [\"error\", { \"includeCommonJSModuleExports\": true }]*/\n/*eslint func-name-matching: [\"error\", \"always\", { \"includeCommonJSModuleExports\": true }]*/ // these are equivalent\n\nmodule.exports = function foo(name) {};\nmodule['exports'] = function foo(name) {};"
            }
        ]
    },
    {
        "name": "func-names",
        "url": "https://eslint.org/docs/latest/rules/func-names",
        "description": "Require or disallow named function expressionsA pattern that’s becoming more common is to give function expressions names to aid in debugging. For example:Adding the second bar in the above example is optional. If you leave off the function name then when the function throws an exception you are likely to get something similar to anonymous function in the stack trace. If you provide the optional name for a function expression then you will get the name of the function expression in the stack trace.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint func-names: [\"error\", \"always\"]*/\n\nFoo.prototype.bar = function() {};\n\nconst cat = {\n  meow: function() {}\n}\n\n(function() {\n    // ...\n}())\n\nexport default function() {}"
            },
            {
                "type": "correct",
                "content": "/*eslint func-names: [\"error\", \"always\"]*/\n\nFoo.prototype.bar = function bar() {};\n\nconst cat = {\n  meow() {}\n}\n\n(function bar() {\n    // ...\n}())\n\nexport default function foo() {}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-names: [\"error\", \"as-needed\"]*/\n\nFoo.prototype.bar = function() {};\n\n(function() {\n    // ...\n}())\n\nexport default function() {}"
            },
            {
                "type": "correct",
                "content": "/*eslint func-names: [\"error\", \"as-needed\"]*/\n\nvar bar = function() {};\n\nconst cat = {\n  meow: function() {}\n}\n\nclass C {\n    #bar = function() {};\n    baz = function() {};\n}\n\nquux ??= function() {};\n\n(function bar() {\n    // ...\n}())\n\nexport default function foo() {}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-names: [\"error\", \"never\"]*/\n\nFoo.prototype.bar = function bar() {};\n\n(function bar() {\n    // ...\n}())"
            },
            {
                "type": "correct",
                "content": "/*eslint func-names: [\"error\", \"never\"]*/\n\nFoo.prototype.bar = function() {};\n\n(function() {\n    // ...\n}())"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-names: [\"error\", \"always\", { \"generators\": \"as-needed\" }]*/\n\n(function*() {\n    // ...\n}())"
            },
            {
                "type": "correct",
                "content": "/*eslint func-names: [\"error\", \"always\", { \"generators\": \"as-needed\" }]*/\n\nvar foo = function*() {};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-names: [\"error\", \"always\", { \"generators\": \"never\" }]*/\n\nvar foo = bar(function *baz() {});"
            },
            {
                "type": "correct",
                "content": "/*eslint func-names: [\"error\", \"always\", { \"generators\": \"never\" }]*/\n\nvar foo = bar(function *() {});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-names: [\"error\", \"as-needed\", { \"generators\": \"never\" }]*/\n\nvar foo = bar(function *baz() {});"
            },
            {
                "type": "correct",
                "content": "/*eslint func-names: [\"error\", \"as-needed\", { \"generators\": \"never\" }]*/\n\nvar foo = bar(function *() {});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-names: [\"error\", \"never\", { \"generators\": \"always\" }]*/\n\nvar foo = bar(function *() {});"
            },
            {
                "type": "correct",
                "content": "/*eslint func-names: [\"error\", \"never\", { \"generators\": \"always\" }]*/\n\nvar foo = bar(function *baz() {});"
            }
        ]
    },
    {
        "name": "func-style",
        "url": "https://eslint.org/docs/latest/rules/func-style",
        "description": "Enforce the consistent use of either function declarations or expressionsThere are two ways of defining functions in JavaScript: function declarations and function expressions. Declarations contain the function keyword first, followed by a name and then its arguments and the function body, for example:Equivalent function expressions begin with the var keyword, followed by a name and then the function itself, such as:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint func-style: [\"error\", \"expression\"]*/\n\nfunction foo() {\n    // ...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint func-style: [\"error\", \"expression\"]*/\n\nvar foo = function() {\n    // ...\n};\n\nvar foo = () => {};\n\n// allowed as allowArrowFunctions : false is applied only for declaration"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-style: [\"error\", \"declaration\"]*/\n\nvar foo = function() {\n    // ...\n};\n\nvar foo = () => {};"
            },
            {
                "type": "correct",
                "content": "/*eslint func-style: [\"error\", \"declaration\"]*/\n\nfunction foo() {\n    // ...\n}\n\n// Methods (functions assigned to objects) are not checked by this rule\nSomeObject.foo = function() {\n    // ...\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint func-style: [\"error\", \"declaration\", { \"allowArrowFunctions\": true }]*/\n\nvar foo = () => {};"
            }
        ]
    },
    {
        "name": "grouped-accessor-pairs",
        "url": "https://eslint.org/docs/latest/rules/grouped-accessor-pairs",
        "description": "Require grouped accessor pairs in object literals and classesA getter and setter for the same property don’t necessarily have to be defined adjacent to each other.For example, the following statements would create the same object:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint grouped-accessor-pairs: \"error\"*/\n\nvar foo = {\n    get a() {\n        return this.val;\n    },\n    b: 1,\n    set a(value) {\n        this.val = value;\n    }\n};\n\nvar bar = {\n    set b(value) {\n        this.val = value;\n    },\n    a: 1,\n    get b() {\n        return this.val;\n    }\n}\n\nclass Foo {\n    set a(value) {\n        this.val = value;\n    }\n    b(){}\n    get a() {\n        return this.val;\n    }\n}\n\nconst Bar = class {\n    static get a() {\n        return this.val;\n    }\n    b(){}\n    static set a(value) {\n        this.val = value;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint grouped-accessor-pairs: \"error\"*/\n\nvar foo = {\n    get a() {\n        return this.val;\n    },\n    set a(value) {\n        this.val = value;\n    },\n    b: 1\n};\n\nvar bar = {\n    set b(value) {\n        this.val = value;\n    },\n    get b() {\n        return this.val;\n    },\n    a: 1\n}\n\nclass Foo {\n    set a(value) {\n        this.val = value;\n    }\n    get a() {\n        return this.val;\n    }\n    b(){}\n}\n\nconst Bar = class {\n    static get a() {\n        return this.val;\n    }\n    static set a(value) {\n        this.val = value;\n    }\n    b(){}\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint grouped-accessor-pairs: [\"error\", \"getBeforeSet\"]*/\n\nvar foo = {\n    set a(value) {\n        this.val = value;\n    },\n    get a() {\n        return this.val;\n    }\n};\n\nclass Foo {\n    set a(value) {\n        this.val = value;\n    }\n    get a() {\n        return this.val;\n    }\n}\n\nconst Bar = class {\n    static set a(value) {\n        this.val = value;\n    }\n    static get a() {\n        return this.val;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint grouped-accessor-pairs: [\"error\", \"getBeforeSet\"]*/\n\nvar foo = {\n    get a() {\n        return this.val;\n    },\n    set a(value) {\n        this.val = value;\n    }\n};\n\nclass Foo {\n    get a() {\n        return this.val;\n    }\n    set a(value) {\n        this.val = value;\n    }\n}\n\nconst Bar = class {\n    static get a() {\n        return this.val;\n    }\n    static set a(value) {\n        this.val = value;\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint grouped-accessor-pairs: [\"error\", \"setBeforeGet\"]*/\n\nvar foo = {\n    get a() {\n        return this.val;\n    },\n    set a(value) {\n        this.val = value;\n    }\n};\n\nclass Foo {\n    get a() {\n        return this.val;\n    }\n    set a(value) {\n        this.val = value;\n    }\n}\n\nconst Bar = class {\n    static get a() {\n        return this.val;\n    }\n    static set a(value) {\n        this.val = value;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint grouped-accessor-pairs: [\"error\", \"setBeforeGet\"]*/\n\nvar foo = {\n    set a(value) {\n        this.val = value;\n    },\n    get a() {\n        return this.val;\n    }\n};\n\nclass Foo {\n    set a(value) {\n        this.val = value;\n    }\n    get a() {\n        return this.val;\n    }\n}\n\nconst Bar = class {\n    static set a(value) {\n        this.val = value;\n    }\n    static get a() {\n        return this.val;\n    }\n}"
            }
        ]
    },
    {
        "name": "guard-for-in",
        "url": "https://eslint.org/docs/latest/rules/guard-for-in",
        "description": "Require for-in loops to include an if statementLooping over objects with a for in loop will include properties that are inherited through the prototype chain. This behavior can lead to unexpected items in your for loop.Note that simply checking foo.hasOwnProperty(key) is likely to cause an error in some cases; see no-prototype-builtins.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint guard-for-in: \"error\"*/\n\nfor (key in foo) {\n    doSomething(key);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint guard-for-in: \"error\"*/\n\nfor (key in foo) {\n    if (Object.prototype.hasOwnProperty.call(foo, key)) {\n        doSomething(key);\n    }\n}\n\nfor (key in foo) {\n    if ({}.hasOwnProperty.call(foo, key)) {\n        doSomething(key);\n    }\n}"
            }
        ]
    },
    {
        "name": "id-denylist",
        "url": "https://eslint.org/docs/latest/rules/id-denylist",
        "description": "Disallow specified identifiersGeneric names can lead to hard-to-decipher code. This rule allows you to specify a deny list of disallowed identifier names to avoid this practice.This rule disallows specified identifiers in assignments and function definitions.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint id-denylist: [\"error\", \"data\", \"callback\"] */\n\nvar data = {...};\n\nfunction callback() {\n    // ...\n}\n\nelement.callback = function() {\n    // ...\n};\n\nvar itemSet = {\n    data: [...]\n};\n\nclass Foo {\n    data = [];\n}\n\nclass Foo {\n    #data = [];\n}\n\nclass Foo {\n    callback( {);\n}\n\nclass Foo {\n    #callback( {);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint id-denylist: [\"error\", \"data\", \"callback\"] */\n\nvar encodingOptions = {...};\n\nfunction processFileResult() {\n    // ...\n}\n\nelement.successHandler = function() {\n    // ...\n};\n\nvar itemSet = {\n    entities: [...]\n};\n\ncallback(); // all function calls are ignored\n\nfoo.callback(); // all function calls are ignored\n\nfoo.data; // all property names that are not assignments are ignored\n\nclass Foo {\n    items = [];\n}\n\nclass Foo {\n    #items = [];\n}\n\nclass Foo {\n    method( {);\n}\n\nclass Foo {\n    #method( {);\n}"
            }
        ]
    },
    {
        "name": "id-length",
        "url": "https://eslint.org/docs/latest/rules/id-length",
        "description": "Enforce minimum and maximum identifier lengthsVery short identifier names like e, x, _t or very long ones like hashGeneratorResultOutputContainerObject can make code harder to read and potentially less maintainable. To prevent this, one may enforce a minimum and/or maximum identifier length.This rule enforces a minimum and/or maximum identifier length convention.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint id-length: \"error\"*/     // default is minimum 2-chars ({ \"min\": 2 })\n/*eslint-env es6*/\n\nvar x = 5;\nobj.e = document.body;\nvar foo = function (e) { };\ntry {\n    dangerousStuff();\n} catch (e) {\n    // ignore as many do\n}\nvar myObj = { a: 1 };\n(a) => { a * a };\nclass x { }\nclass Foo { x() {} }\nclass Foo { #x() {} }\nclass Foo { x = 1 }\nclass Foo { #x = 1 }\nfunction foo(...x) { }\nfunction foo([x]) { }\nvar [x] = arr;\nvar { prop: [x]} = {};\nfunction foo({x}) { }\nvar { x } = {};\nvar { prop: a} = {};\n({ prop: obj.x } = {});"
            },
            {
                "type": "correct",
                "content": "/*eslint id-length: \"error\"*/     // default is minimum 2-chars ({ \"min\": 2 })\n/*eslint-env es6*/\n\nvar num = 5;\nfunction _f() { return 42; }\nfunction _func() { return 42; }\nobj.el = document.body;\nvar foo = function (evt) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (error) {\n    // ignore as many do\n}\nvar myObj = { apple: 1 };\n(num) => { num * num };\nfunction foo(num = 0) { }\nclass MyClass { }\nclass Foo { method() {} }\nclass Foo { #method() {} }\nclass Foo { field = 1 }\nclass Foo { #field = 1 }\nfunction foo(...args) { }\nfunction foo([longName]) { }\nvar { prop } = {};\nvar { prop: [longName] } = {};\nvar [longName] = arr;\nfunction foo({ prop }) { }\nfunction foo({ a: prop }) { }\nvar { prop } = {};\nvar { a: prop } = {};\n({ prop: obj.longName } = {});\nvar data = { \"x\": 1 };  // excused because of quotes\ndata[\"y\"] = 3;  // excused because of calculated property access"
            },
            {
                "type": "incorrect",
                "content": "/*eslint id-length: [\"error\", { \"min\": 4 }]*/\n/*eslint-env es6*/\n\nvar val = 5;\nobj.e = document.body;\nfunction foo (e) { };\ntry {\n    dangerousStuff();\n} catch (e) {\n    // ignore as many do\n}\nvar myObj = { a: 1 };\n(val) => { val * val };\nclass x { }\nclass Foo { x() {} }\nfunction foo(...x) { }\nvar { x } = {};\nvar { prop: a} = {};\nvar [x] = arr;\nvar { prop: [x]} = {};\n({ prop: obj.x } = {});"
            },
            {
                "type": "correct",
                "content": "/*eslint id-length: [\"error\", { \"min\": 4 }]*/\n/*eslint-env es6*/\n\nvar value = 5;\nfunction func() { return 42; }\nobj.element = document.body;\nvar foobar = function (event) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (error) {\n    // ignore as many do\n}\nvar myObj = { apple: 1 };\n(value) => { value * value };\nfunction foobar(value = 0) { }\nclass MyClass { }\nclass Foobar { method() {} }\nfunction foobar(...args) { }\nvar { prop } = {};\nvar [longName] = foo;\nvar { a: [prop] } = {};\nvar { a: longName } = {};\n({ prop: obj.name } = {});\nvar data = { \"x\": 1 };  // excused because of quotes\ndata[\"y\"] = 3;  // excused because of calculated property access"
            },
            {
                "type": "incorrect",
                "content": "/*eslint id-length: [\"error\", { \"max\": 10 }]*/\n/*eslint-env es6*/\n\nvar reallyLongVarName = 5;\nfunction reallyLongFuncName() { return 42; }\nobj.reallyLongPropName = document.body;\nvar foo = function (reallyLongArgName) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (reallyLongErrorName) {\n    // ignore as many do\n}\n(reallyLongArgName) => { return !reallyLongArgName; };\nvar [reallyLongFirstElementName] = arr;"
            },
            {
                "type": "correct",
                "content": "/*eslint id-length: [\"error\", { \"max\": 10 }]*/\n/*eslint-env es6*/\n\nvar varName = 5;\nfunction funcName() { return 42; }\nobj.propName = document.body;\nvar foo = function (arg) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (error) {\n    // ignore as many do\n}\n(arg) => { return !arg; };\nvar [first] = arr;"
            },
            {
                "type": "correct",
                "content": "/*eslint id-length: [\"error\", { \"properties\": \"never\" }]*/\n/*eslint-env es6*/\n\nvar myObj = { a: 1 };\n({ a: obj.x.y.z } = {});\n({ prop: obj.i } = {});"
            },
            {
                "type": "correct",
                "content": "/*eslint id-length: [\"error\", { \"exceptions\": [\"x\"] }]*/\n/*eslint-env es6*/\n\nvar x = 5;\nfunction x() { return 42; }\nobj.x = document.body;\nvar foo = function (x) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (x) {\n    // ignore as many do\n}\n(x) => { return x * x; };\nvar [x] = arr;\nconst { x } = foo;\nconst { a: x } = foo;"
            },
            {
                "type": "correct",
                "content": "/*eslint id-length: [\"error\", { \"exceptionPatterns\": [\"E|S\", \"[x-z]\"] }]*/\n/*eslint-env es6*/\n\nvar E = 5;\nfunction S() { return 42; }\nobj.x = document.body;\nvar foo = function (x) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (x) {\n    // ignore as many do\n}\n(y) => {return  y * y};\nvar [E] = arr;\nconst { y } = foo;\nconst { a: z } = foo;"
            }
        ]
    },
    {
        "name": "id-match",
        "url": "https://eslint.org/docs/latest/rules/id-match",
        "description": "Require identifiers to match a specified regular expressionNaming things consistently in a project is an often underestimated aspect of code creation. When done correctly, it can save your team hours of unnecessary head scratching and misdirections. This rule allows you to precisely define and enforce the variables and function names on your team should use. No more limiting yourself to camelCase, snake_case, PascalCase or oHungarianNotation. Id-match has all your needs covered!This rule requires identifiers in assignments and function definitions to match a specified regular expression.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint id-match: [\"error\", \"^[a-z]+([A-Z][a-z]+)*$\"]*/\n\nvar my_favorite_color = \"#112C85\";\nvar _myFavoriteColor  = \"#112C85\";\nvar myFavoriteColor_  = \"#112C85\";\nvar MY_FAVORITE_COLOR = \"#112C85\";\nfunction do_something() {\n    // ...\n}\n\nobj.do_something = function() {\n    // ...\n};\n\nclass My_Class {}\n\nclass myClass {\n    do_something() {}\n}\n\nclass myClass {\n    #do_something() {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint id-match: [\"error\", \"^[a-z]+([A-Z][a-z]+)*$\"]*/\n\nvar myFavoriteColor   = \"#112C85\";\nvar foo = bar.baz_boom;\nvar foo = { qux: bar.baz_boom };\ndo_something();\nvar obj = {\n    my_pref: 1\n};\n\nclass myClass {}\n\nclass myClass {\n    doSomething() {}\n}\n\nclass myClass {\n    #doSomething() {}\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint id-match: [\"error\", \"^[a-z]+([A-Z][a-z]+)*$\", { \"properties\": true }]*/\n\nvar obj = {\n    my_pref: 1\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint id-match: [\"error\", \"^[a-z]+([A-Z][a-z]+)*$\", { \"properties\": true }]*/\n\nclass myClass {\n    my_pref = 1;\n}\n\nclass myClass {\n    #my_pref = 1;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint id-match: [2, \"^[a-z]+([A-Z][a-z]+)*$\", { \"onlyDeclarations\": true }]*/\n\ndo_something(__dirname);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint id-match: [2, \"^[^_]+$\", { \"ignoreDestructuring\": false }]*/\n\nvar { category_id } = query;\n\nvar { category_id = 1 } = query;\n\nvar { category_id: category_id } = query;\n\nvar { category_id: category_alias } = query;\n\nvar { category_id: categoryId, ...other_props } = query;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint id-match: [2, \"^[^_]+$\", { \"ignoreDestructuring\": true }]*/\n\nvar { category_id: category_alias } = query;\n\nvar { category_id, ...other_props } = query;"
            },
            {
                "type": "correct",
                "content": "/*eslint id-match: [2, \"^[^_]+$\", { \"ignoreDestructuring\": true }]*/\n\nvar { category_id } = query;\n\nvar { category_id = 1 } = query;\n\nvar { category_id: category_id } = query;"
            }
        ]
    },
    {
        "name": "init-declarations",
        "url": "https://eslint.org/docs/latest/rules/init-declarations",
        "description": "Require or disallow initialization in variable declarationsIn JavaScript, variables can be assigned during declaration, or at any point afterwards using an assignment statement. For example, in the following code, foo is initialized during declaration, while bar is initialized later.This rule is aimed at enforcing or eliminating variable initializations during declaration. For example, in the following code, foo is initialized during declaration, while bar is not.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint init-declarations: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar;\n    let baz;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint init-declarations: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar = 1;\n    let baz = 2;\n    const qux = 3;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint init-declarations: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar = 1;\n    let baz = 2;\n\n    for (var i = 0; i < 1; i++) {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint init-declarations: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar;\n    let baz;\n    const buzz = 1;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint init-declarations: [\"error\", \"never\", { \"ignoreForLoopInit\": true }]*/\nfor (var i = 0; i < 1; i++) {}"
            }
        ]
    },
    {
        "name": "logical-assignment-operators",
        "url": "https://eslint.org/docs/latest/rules/logical-assignment-operators",
        "description": "Require or disallow logical assignment logical operator shorthandES2021 introduces the assignment operator shorthand for the logical operators ||, && and ??. Before, this was only allowed for mathematical operations such as + or * (see the rule operator-assignment). The shorthand can be used if the assignment target and the left expression of a logical expression are the same. For example a = a || b can be shortened to a ||= b.This rule requires or disallows logical assignment operator shorthand.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint logical-assignment-operators: [\"error\", \"always\"]*/\n\na = a || b\na = a && b\na = a ?? b\na || (a = b)\na && (a = b)\na ?? (a = b)"
            },
            {
                "type": "correct",
                "content": "/*eslint logical-assignment-operators: [\"error\", \"always\"]*/\n\na = b\na += b\na ||= b\na = b || c\na || (b = c)\n\nif (a) a = b"
            },
            {
                "type": "incorrect",
                "content": "/*eslint logical-assignment-operators: [\"error\", \"never\"]*/\n\na ||= b\na &&= b\na ??= b"
            },
            {
                "type": "correct",
                "content": "/*eslint logical-assignment-operators: [\"error\", \"never\"]*/\n\na = a || b\na = a && b\na = a ?? b"
            },
            {
                "type": "incorrect",
                "content": "Examples of incorrect code for this rule with the [\"always\", { enforceForIfStatements: true }] option:\n\n/*eslint logical-assignment-operators: [\"error\", \"always\", { enforceForIfStatements: true }]*/\n\nif (a) a = b // <=> a &&= b\nif (!a) a = b // <=> a ||= b\n\nif (a == null) a = b // <=> a ??= b\nif (a === null || a === undefined) a = b // <=> a ??= b"
            },
            {
                "type": "correct",
                "content": "/*eslint logical-assignment-operators: [\"error\", \"always\", { enforceForIfStatements: true }]*/\n\nif (a) b = c\nif (a === 0) a = b"
            }
        ]
    },
    {
        "name": "max-classes-per-file",
        "url": "https://eslint.org/docs/latest/rules/max-classes-per-file",
        "description": "Enforce a maximum number of classes per fileFiles containing multiple classes can often result in a less navigable and poorly structured codebase. Best practice is to keep each file limited to a single responsibility.This rule enforces that each file may contain only a particular number of classes and no more.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint max-classes-per-file: \"error\"*/\n\nclass Foo {}\nclass Bar {}"
            },
            {
                "type": "correct",
                "content": "/*eslint max-classes-per-file: \"error\"*/\n\nclass Foo {}"
            },
            {
                "type": "correct",
                "content": "/* eslint max-classes-per-file: [\"error\", 2] */\n\nclass Foo {}\nclass Bar {}"
            },
            {
                "type": "correct",
                "content": "/* eslint max-classes-per-file: [\"error\", { ignoreExpressions: true }] */\n\nclass VisitorFactory {\n    forDescriptor(descriptor) {\n        return class {\n            visit(node) {\n                return `Visiting ${descriptor}.`;\n            }\n        };\n    }\n}"
            }
        ]
    },
    {
        "name": "max-depth",
        "url": "https://eslint.org/docs/latest/rules/max-depth",
        "description": "Enforce a maximum depth that blocks can be nestedMany developers consider code difficult to read if blocks are nested beyond a certain depth.This rule enforces a maximum depth that blocks can be nested to reduce code complexity.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint max-depth: [\"error\", 4]*/\n\nfunction foo() {\n    for (;;) { // Nested 1 deep\n        while (true) { // Nested 2 deep\n            if (true) { // Nested 3 deep\n                if (true) { // Nested 4 deep\n                    if (true) { // Nested 5 deep\n                    }\n                }\n            }\n        }\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint max-depth: [\"error\", 4]*/\n\nfunction foo() {\n    for (;;) { // Nested 1 deep\n        while (true) { // Nested 2 deep\n            if (true) { // Nested 3 deep\n                if (true) { // Nested 4 deep\n                }\n            }\n        }\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-depth: [\"error\", 2]*/\n\nfunction foo() {\n    if (true) { // Nested 1 deep\n        class C {\n            static {\n                if (true) { // Nested 1 deep\n                    if (true) { // Nested 2 deep\n                        if (true) { // Nested 3 deep\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint max-depth: [\"error\", 2]*/\n\nfunction foo() {\n    if (true) { // Nested 1 deep\n        class C {\n            static {\n                if (true) { // Nested 1 deep\n                    if (true) { // Nested 2 deep\n                    }\n                }\n            }\n        }\n    }\n}"
            }
        ]
    },
    {
        "name": "max-lines",
        "url": "https://eslint.org/docs/latest/rules/max-lines",
        "description": "Enforce a maximum number of lines per fileSome people consider large files a code smell. Large files tend to do a lot of things and can make it hard following what’s going. While there is not an objective maximum number of lines considered acceptable in a file, most people would agree it should not be in the thousands. Recommendations usually range from 100 to 500 lines.This rule enforces a maximum number of lines per file, in order to aid in maintainability and reduce complexity.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint max-lines: [\"error\", 2]*/\nvar a,\n    b,\n    c;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-lines: [\"error\", 2]*/\n\nvar a,\n    b,c;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-lines: [\"error\", 2]*/\n// a comment\nvar a,\n    b,c;"
            },
            {
                "type": "correct",
                "content": "/*eslint max-lines: [\"error\", 2]*/\nvar a,\n    b, c;"
            },
            {
                "type": "correct",
                "content": "/*eslint max-lines: [\"error\", 2]*/\n\nvar a, b, c;"
            },
            {
                "type": "correct",
                "content": "/*eslint max-lines: [\"error\", 2]*/\n// a comment\nvar a, b, c;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-lines: [\"error\", {\"max\": 2, \"skipBlankLines\": true}]*/\n\nvar a,\n    b,\n    c;"
            },
            {
                "type": "correct",
                "content": "/*eslint max-lines: [\"error\", {\"max\": 2, \"skipBlankLines\": true}]*/\n\nvar a,\n    b, c;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-lines: [\"error\", {\"max\": 2, \"skipComments\": true}]*/\n// a comment\nvar a,\n    b,\n    c;"
            },
            {
                "type": "correct",
                "content": "/*eslint max-lines: [\"error\", {\"max\": 2, \"skipComments\": true}]*/\n// a comment\nvar a,\n    b, c;"
            }
        ]
    },
    {
        "name": "max-lines-per-function",
        "url": "https://eslint.org/docs/latest/rules/max-lines-per-function",
        "description": "Enforce a maximum number of lines of code in a functionSome people consider large functions a code smell. Large functions tend to do a lot of things and can make it hard following what’s going on. Many coding style guides dictate a limit of the number of lines that a function can comprise of. This rule can help enforce that style.This rule enforces a maximum number of lines per function, in order to aid in maintainability and reduce complexity.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint max-lines-per-function: [\"error\", 2]*/\nfunction foo() {\n    var x = 0;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-lines-per-function: [\"error\", 2]*/\nfunction foo() {\n    // a comment\n    var x = 0;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-lines-per-function: [\"error\", 2]*/\nfunction foo() {\n    // a comment followed by a blank line\n\n    var x = 0;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint max-lines-per-function: [\"error\", 3]*/\nfunction foo() {\n    var x = 0;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint max-lines-per-function: [\"error\", 3]*/\nfunction foo() {\n    // a comment\n    var x = 0;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint max-lines-per-function: [\"error\", 3]*/\nfunction foo() {\n    // a comment followed by a blank line\n\n    var x = 0;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-lines-per-function: [\"error\", {\"max\": 2, \"skipBlankLines\": true}]*/\nfunction foo() {\n\n    var x = 0;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint max-lines-per-function: [\"error\", {\"max\": 3, \"skipBlankLines\": true}]*/\nfunction foo() {\n\n    var x = 0;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-lines-per-function: [\"error\", {\"max\": 2, \"skipComments\": true}]*/\nfunction foo() {\n    // a comment\n    var x = 0;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint max-lines-per-function: [\"error\", {\"max\": 3, \"skipComments\": true}]*/\nfunction foo() {\n    // a comment\n    var x = 0;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-lines-per-function: [\"error\", {\"max\": 2, \"IIFEs\": true}]*/\n(function(){\n    var x = 0;\n}());\n\n(() => {\n    var x = 0;\n})();"
            },
            {
                "type": "correct",
                "content": "/*eslint max-lines-per-function: [\"error\", {\"max\": 3, \"IIFEs\": true}]*/\n(function(){\n    var x = 0;\n}());\n\n(() => {\n    var x = 0;\n})();"
            }
        ]
    },
    {
        "name": "max-nested-callbacks",
        "url": "https://eslint.org/docs/latest/rules/max-nested-callbacks",
        "description": "Enforce a maximum depth that callbacks can be nestedMany JavaScript libraries use the callback pattern to manage asynchronous operations. A program of any complexity will most likely need to manage several asynchronous operations at various levels of concurrency. A common pitfall that is easy to fall into is nesting callbacks, which makes code more difficult to read the deeper the callbacks are nested.This rule enforces a maximum depth that callbacks can be nested to increase code clarity.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint max-nested-callbacks: [\"error\", 3]*/\n\nfoo1(function() {\n    foo2(function() {\n        foo3(function() {\n            foo4(function() {\n                // Do something\n            });\n        });\n    });\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint max-nested-callbacks: [\"error\", 3]*/\n\nfoo1(handleFoo1);\n\nfunction handleFoo1() {\n    foo2(handleFoo2);\n}\n\nfunction handleFoo2() {\n    foo3(handleFoo3);\n}\n\nfunction handleFoo3() {\n    foo4(handleFoo4);\n}\n\nfunction handleFoo4() {\n    foo5();\n}"
            }
        ]
    },
    {
        "name": "max-params",
        "url": "https://eslint.org/docs/latest/rules/max-params",
        "description": "Enforce a maximum number of parameters in function definitionsFunctions that take numerous parameters can be difficult to read and write because it requires the memorization of what each parameter is, its type, and the order they should appear in. As a result, many coders adhere to a convention that caps the number of parameters a function can take.This rule enforces a maximum number of parameters allowed in function definitions.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint max-params: [\"error\", 3]*/\n/*eslint-env es6*/\n\nfunction foo (bar, baz, qux, qxx) {\n    doSomething();\n}\n\nlet foo = (bar, baz, qux, qxx) => {\n    doSomething();\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint max-params: [\"error\", 3]*/\n/*eslint-env es6*/\n\nfunction foo (bar, baz, qux) {\n    doSomething();\n}\n\nlet foo = (bar, baz, qux) => {\n    doSomething();\n};"
            }
        ]
    },
    {
        "name": "max-statements",
        "url": "https://eslint.org/docs/latest/rules/max-statements",
        "description": "Enforce a maximum number of statements allowed in function blocksThe max-statements rule allows you to specify the maximum number of statements allowed in a function.This rule enforces a maximum number of statements allowed in function blocks.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint max-statements: [\"error\", 10]*/\n/*eslint-env es6*/\n\nfunction foo() {\n  var foo1 = 1;\n  var foo2 = 2;\n  var foo3 = 3;\n  var foo4 = 4;\n  var foo5 = 5;\n  var foo6 = 6;\n  var foo7 = 7;\n  var foo8 = 8;\n  var foo9 = 9;\n  var foo10 = 10;\n\n  var foo11 = 11; // Too many.\n}\n\nlet foo = () => {\n  var foo1 = 1;\n  var foo2 = 2;\n  var foo3 = 3;\n  var foo4 = 4;\n  var foo5 = 5;\n  var foo6 = 6;\n  var foo7 = 7;\n  var foo8 = 8;\n  var foo9 = 9;\n  var foo10 = 10;\n\n  var foo11 = 11; // Too many.\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint max-statements: [\"error\", 10]*/\n/*eslint-env es6*/\n\nfunction foo() {\n  var foo1 = 1;\n  var foo2 = 2;\n  var foo3 = 3;\n  var foo4 = 4;\n  var foo5 = 5;\n  var foo6 = 6;\n  var foo7 = 7;\n  var foo8 = 8;\n  var foo9 = 9;\n  var foo10 = 10;\n  return function () {\n\n    // The number of statements in the inner function does not count toward the\n    // statement maximum.\n\n    return 42;\n  };\n}\n\nlet foo = () => {\n  var foo1 = 1;\n  var foo2 = 2;\n  var foo3 = 3;\n  var foo4 = 4;\n  var foo5 = 5;\n  var foo6 = 6;\n  var foo7 = 7;\n  var foo8 = 8;\n  var foo9 = 9;\n  var foo10 = 10;\n  return function () {\n\n    // The number of statements in the inner function does not count toward the\n    // statement maximum.\n\n    return 42;\n  };\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint max-statements: [\"error\", 2]*/\n\nfunction foo() {\n    let one;\n    let two = class {\n        static {\n            let three;\n            let four;\n            let five;\n            if (six) {\n                let seven;\n                let eight;\n                let nine;\n            }\n        }\n    };\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint max-statements: [\"error\", 10, { \"ignoreTopLevelFunctions\": true }]*/\n\nfunction foo() {\n  var foo1 = 1;\n  var foo2 = 2;\n  var foo3 = 3;\n  var foo4 = 4;\n  var foo5 = 5;\n  var foo6 = 6;\n  var foo7 = 7;\n  var foo8 = 8;\n  var foo9 = 9;\n  var foo10 = 10;\n  var foo11 = 11;\n}"
            }
        ]
    },
    {
        "name": "multiline-comment-style",
        "url": "https://eslint.org/docs/latest/rules/multiline-comment-style",
        "description": "Enforce a particular style for multiline commentsMany style guides require a particular style for comments that span multiple lines. For example, some style guides prefer the use of a single block comment for multiline comments, whereas other style guides prefer consecutive line comments.This rule aims to enforce a particular style for multiline comments.",
        "examples": [
            {
                "type": "incorrect",
                "content": "\n/* eslint multiline-comment-style: [\"error\", \"starred-block\"] */\n\n// this line\n// calls foo()\nfoo();\n\n/* this line\ncalls foo() */\nfoo();\n\n/* this comment\n * is missing a newline after /*\n */\n\n/*\n * this comment\n * is missing a newline at the end */\n\n/*\n* the star in this line should have a space before it\n */\n\n/*\n * the star on the following line should have a space before it\n*/\n"
            },
            {
                "type": "correct",
                "content": "/* eslint multiline-comment-style: [\"error\", \"starred-block\"] */\n\n/*\n * this line\n * calls foo()\n */\nfoo();\n\n// single-line comment"
            },
            {
                "type": "incorrect",
                "content": "/* eslint multiline-comment-style: [\"error\", \"bare-block\"] */\n\n// this line\n// calls foo()\nfoo();\n\n/*\n * this line\n * calls foo()\n */\nfoo();"
            },
            {
                "type": "correct",
                "content": "/* eslint multiline-comment-style: [\"error\", \"bare-block\"] */\n\n/* this line\n   calls foo() */\nfoo();"
            },
            {
                "type": "incorrect",
                "content": "\n/* eslint multiline-comment-style: [\"error\", \"separate-lines\"] */\n\n/* This line\ncalls foo() */\nfoo();\n\n/*\n * This line\n * calls foo()\n */\nfoo();\n"
            },
            {
                "type": "correct",
                "content": "/* eslint multiline-comment-style: [\"error\", \"separate-lines\"] */\n\n// This line\n// calls foo()\nfoo();\n"
            }
        ]
    },
    {
        "name": "new-cap",
        "url": "https://eslint.org/docs/latest/rules/new-cap",
        "description": "Require constructor names to begin with a capital letterThe new operator in JavaScript creates a new instance of a particular type of object. That type of object is represented by a constructor function. Since constructor functions are just regular functions, the only defining characteristic is that new is being used as part of the call. Native JavaScript functions begin with an uppercase letter to distinguish those functions that are to be used as constructors from functions that are not. Many style guides recommend following this pattern to more easily determine which functions are to be used as constructors.This rule requires constructor names to begin with a capital letter. Certain built-in identifiers are exempt from this rule. These identifiers are:",
        "examples": [
            {
                "type": "correct",
                "content": "/*eslint new-cap: \"error\"*/\n\nfunction foo(arg) {\n    return Boolean(arg);\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint new-cap: [\"error\", { \"newIsCap\": true }]*/\n\nvar friend = new person();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"newIsCap\": true }]*/\n\nvar friend = new Person();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"newIsCap\": false }]*/\n\nvar friend = new person();"
            },
            {
                "type": "incorrect",
                "content": "/*eslint new-cap: [\"error\", { \"capIsNew\": true }]*/\n\nvar colleague = Person();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"capIsNew\": true }]*/\n\nvar colleague = new Person();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"capIsNew\": false }]*/\n\nvar colleague = Person();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"newIsCapExceptions\": [\"events\"] }]*/\n\nvar events = require('events');\n\nvar emitter = new events();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"newIsCapExceptionPattern\": \"^person\\\\..\" }]*/\n\nvar friend = new person.acquaintance();\n\nvar bestFriend = new person.friend();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"newIsCapExceptionPattern\": \"\\\\.bar$\" }]*/\n\nvar friend = new person.bar();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"capIsNewExceptions\": [\"Person\"] }]*/\n\nfunction foo(arg) {\n    return Person(arg);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"capIsNewExceptionPattern\": \"^person\\\\..\" }]*/\n\nvar friend = person.Acquaintance();\nvar bestFriend = person.Friend();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"capIsNewExceptionPattern\": \"\\\\.Bar$\" }]*/\n\nfoo.Bar();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"capIsNewExceptionPattern\": \"^Foo\" }]*/\n\nvar x = Foo(42);\n\nvar y = Foobar(42);\n\nvar z = Foo.Bar(42);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint new-cap: [\"error\", { \"properties\": true }]*/\n\nvar friend = new person.acquaintance();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"properties\": true }]*/\n\nvar friend = new person.Acquaintance();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-cap: [\"error\", { \"properties\": false }]*/\n\nvar friend = new person.acquaintance();"
            }
        ]
    },
    {
        "name": "no-alert",
        "url": "https://eslint.org/docs/latest/rules/no-alert",
        "description": "Disallow the use of alert, confirm, and promptJavaScript’s alert, confirm, and prompt functions are widely considered to be obtrusive as UI elements and should be replaced by a more appropriate custom UI implementation. Furthermore, alert is often used while debugging code, which should be removed before deployment to production.This rule is aimed at catching debugging code that should be removed and popup UI elements that should be replaced with less obtrusive, custom UIs. As such, it will warn when it encounters alert, prompt, and confirm function calls which are not shadowed.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-alert: \"error\"*/\n\nalert(\"here!\");\n\nconfirm(\"Are you sure?\");\n\nprompt(\"What's your name?\", \"John Doe\");"
            },
            {
                "type": "correct",
                "content": "/*eslint no-alert: \"error\"*/\n\ncustomAlert(\"Something happened!\");\n\ncustomConfirm(\"Are you sure?\");\n\ncustomPrompt(\"Who are you?\");\n\nfunction foo() {\n    var alert = myCustomLib.customAlert;\n    alert();\n}"
            }
        ]
    },
    {
        "name": "no-array-constructor",
        "url": "https://eslint.org/docs/latest/rules/no-array-constructor",
        "description": "Disallow Array constructorsUse of the Array constructor to construct a new array is generally discouraged in favor of array literal notation because of the single-argument pitfall and because the Array global may be redefined. The exception is when the Array constructor is used to intentionally create sparse arrays of a specified size by giving the constructor a single numeric argument.This rule disallows Array constructors.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-array-constructor: \"error\"*/\n\nArray(0, 1, 2)\n\nnew Array(0, 1, 2)"
            },
            {
                "type": "correct",
                "content": "/*eslint no-array-constructor: \"error\"*/\n\nArray(500)\n\nnew Array(someOtherArray.length)\n\n[0, 1, 2]"
            }
        ]
    },
    {
        "name": "no-bitwise",
        "url": "https://eslint.org/docs/latest/rules/no-bitwise",
        "description": "Disallow bitwise operatorsThe use of bitwise operators in JavaScript is very rare and often & or | is simply a mistyped && or ||, which will lead to unexpected behavior.This rule disallows bitwise operators.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-bitwise: \"error\"*/\n\nvar x = y | z;\n\nvar x = y & z;\n\nvar x = y ^ z;\n\nvar x = ~ z;\n\nvar x = y << z;\n\nvar x = y >> z;\n\nvar x = y >>> z;\n\nx |= y;\n\nx &= y;\n\nx ^= y;\n\nx <<= y;\n\nx >>= y;\n\nx >>>= y;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-bitwise: \"error\"*/\n\nvar x = y || z;\n\nvar x = y && z;\n\nvar x = y > z;\n\nvar x = y < z;\n\nx += y;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-bitwise: [\"error\", { \"allow\": [\"~\"] }] */\n\n~[1,2,3].indexOf(1) === -1;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-bitwise: [\"error\", { \"int32Hint\": true }] */\n\nvar b = a|0;"
            }
        ]
    },
    {
        "name": "no-caller",
        "url": "https://eslint.org/docs/latest/rules/no-caller",
        "description": "Disallow the use of arguments.caller or arguments.calleeThe use of arguments.caller and arguments.callee make several code optimizations impossible. They have been deprecated in future versions of JavaScript and their use is forbidden in ECMAScript 5 while in strict mode.This rule is aimed at discouraging the use of deprecated and sub-optimal code by disallowing the use of arguments.caller and arguments.callee. As such, it will warn when arguments.caller and arguments.callee are used.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-caller: \"error\"*/\n\nfunction foo(n) {\n    if (n <= 0) {\n        return;\n    }\n\n    arguments.callee(n - 1);\n}\n\n[1,2,3,4,5].map(function(n) {\n    return !(n > 1) ? 1 : arguments.callee(n - 1) * n;\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint no-caller: \"error\"*/\n\nfunction foo(n) {\n    if (n <= 0) {\n        return;\n    }\n\n    foo(n - 1);\n}\n\n[1,2,3,4,5].map(function factorial(n) {\n    return !(n > 1) ? 1 : factorial(n - 1) * n;\n});"
            }
        ]
    },
    {
        "name": "no-case-declarations",
        "url": "https://eslint.org/docs/latest/rules/no-case-declarations",
        "description": "Disallow lexical declarations in case clausesThis rule disallows lexical declarations (let, const, function and class) in case/default clauses. The reason is that the lexical declaration is visible in the entire switch block but it only gets initialized when it is assigned, which will only happen if the case where it is defined is reached.To ensure that the lexical declaration only applies to the current case clause wrap your clauses in blocks.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-case-declarations: \"error\"*/\n/*eslint-env es6*/\n\nswitch (foo) {\n    case 1:\n        let x = 1;\n        break;\n    case 2:\n        const y = 2;\n        break;\n    case 3:\n        function f() {}\n        break;\n    default:\n        class C {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-case-declarations: \"error\"*/\n/*eslint-env es6*/\n\n// Declarations outside switch-statements are valid\nconst a = 0;\n\nswitch (foo) {\n    // The following case clauses are wrapped into blocks using brackets\n    case 1: {\n        let x = 1;\n        break;\n    }\n    case 2: {\n        const y = 2;\n        break;\n    }\n    case 3: {\n        function f() {}\n        break;\n    }\n    case 4:\n        // Declarations using var without brackets are valid due to function-scope hoisting\n        var z = 4;\n        break;\n    default: {\n        class C {}\n    }\n}"
            }
        ]
    },
    {
        "name": "no-confusing-arrow",
        "url": "https://eslint.org/docs/latest/rules/no-confusing-arrow",
        "description": "Disallow arrow functions where they could be confused with comparisonsArrow functions (=>) are similar in syntax to some comparison operators (>, <, <=, and >=). This rule warns against using the arrow function syntax in places where it could be confused with a comparison operator.Here’s an example where the usage of => could be confusing:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-confusing-arrow: \"error\"*/\n/*eslint-env es6*/\n\nvar x = a => 1 ? 2 : 3;\nvar x = (a) => 1 ? 2 : 3;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-confusing-arrow: \"error\"*/\n/*eslint-env es6*/\nvar x = a => (1 ? 2 : 3);\nvar x = (a) => (1 ? 2 : 3);\nvar x = (a) => {\n    return 1 ? 2 : 3;\n};\nvar x = a => { return 1 ? 2 : 3; };"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-confusing-arrow: [\"error\", {\"allowParens\": false}]*/\n/*eslint-env es6*/\nvar x = a => (1 ? 2 : 3);\nvar x = (a) => (1 ? 2 : 3);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-confusing-arrow: [\"error\", {\"onlyOneSimpleParam\": true}]*/\n/*eslint-env es6*/\n() => 1 ? 2 : 3;\n(a, b) => 1 ? 2 : 3;\n(a = b) => 1 ? 2 : 3;\n({ a }) => 1 ? 2 : 3;\n([a]) => 1 ? 2 : 3;\n(...a) => 1 ? 2 : 3;"
            }
        ]
    },
    {
        "name": "no-console",
        "url": "https://eslint.org/docs/latest/rules/no-console",
        "description": "Disallow the use of consoleIn JavaScript that is designed to be executed in the browser, it’s considered a best practice to avoid using methods on console. Such messages are considered to be for debugging purposes and therefore not suitable to ship to the client. In general, calls using console should be stripped before being pushed to production.This rule disallows calls or assignments to methods of the console object.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint no-console: \"error\" */\n\nconsole.log(\"Log a debug level message.\");\nconsole.warn(\"Log a warn level message.\");\nconsole.error(\"Log an error level message.\");\nconsole.log = foo();"
            },
            {
                "type": "correct",
                "content": "/* eslint no-console: \"error\" */\n\n// custom console\nConsole.log(\"Hello world!\");"
            },
            {
                "type": "correct",
                "content": "/* eslint no-console: [\"error\", { allow: [\"warn\", \"error\"] }] */\n\nconsole.warn(\"Log a warn level message.\");\nconsole.error(\"Log an error level message.\");"
            }
        ]
    },
    {
        "name": "no-continue",
        "url": "https://eslint.org/docs/latest/rules/no-continue",
        "description": "Disallow continue statementsThe continue statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration. When used incorrectly it makes code less testable, less readable and less maintainable. Structured control flow statements such as if should be used instead.This rule disallows continue statements.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-continue: \"error\"*/\n\nvar sum = 0,\n    i;\n\nfor(i = 0; i < 10; i++) {\n    if(i >= 5) {\n        continue;\n    }\n\n    a += i;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-continue: \"error\"*/\n\nvar sum = 0,\n    i;\n\nlabeledLoop: for(i = 0; i < 10; i++) {\n    if(i >= 5) {\n        continue labeledLoop;\n    }\n\n    a += i;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-continue: \"error\"*/\n\nvar sum = 0,\n    i;\n\nfor(i = 0; i < 10; i++) {\n    if(i < 5) {\n       a += i;\n    }\n}"
            }
        ]
    },
    {
        "name": "no-delete-var",
        "url": "https://eslint.org/docs/latest/rules/no-delete-var",
        "description": "Disallow deleting variablesThe purpose of the delete operator is to remove a property from an object. Using the delete operator on a variable might lead to unexpected behavior.This rule disallows the use of the delete operator on variables.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-delete-var: \"error\"*/\n\nvar x;\ndelete x;"
            }
        ]
    },
    {
        "name": "no-div-regex",
        "url": "https://eslint.org/docs/latest/rules/no-div-regex",
        "description": "Disallow division operators explicitly at the beginning of regular expressionsRequire regex literals to escape division operators.This is used to disambiguate the division operator to not confuse users.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-div-regex: \"error\"*/\n\nfunction bar() { return /=foo/; }"
            },
            {
                "type": "correct",
                "content": "/*eslint no-div-regex: \"error\"*/\n\nfunction bar() { return /[=]foo/; }"
            }
        ]
    },
    {
        "name": "no-else-return",
        "url": "https://eslint.org/docs/latest/rules/no-else-return",
        "description": "Disallow else blocks after return statements in if statementsIf an if block contains a return statement, the else block becomes unnecessary. Its contents can be placed outside of the block.This rule is aimed at highlighting an unnecessary block of code following an if containing a return statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a return statement.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-else-return: \"error\"*/\n\nfunction foo() {\n    if (x) {\n        return y;\n    } else {\n        return z;\n    }\n}\n\nfunction foo() {\n    if (x) {\n        return y;\n    } else if (z) {\n        return w;\n    } else {\n        return t;\n    }\n}\n\nfunction foo() {\n    if (x) {\n        return y;\n    } else {\n        var t = \"foo\";\n    }\n\n    return t;\n}\n\nfunction foo() {\n    if (error) {\n        return 'It failed';\n    } else {\n        if (loading) {\n            return \"It's still loading\";\n        }\n    }\n}\n\n// Two warnings for nested occurrences\nfunction foo() {\n    if (x) {\n        if (y) {\n            return y;\n        } else {\n            return x;\n        }\n    } else {\n        return z;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-else-return: \"error\"*/\n\nfunction foo() {\n    if (x) {\n        return y;\n    }\n\n    return z;\n}\n\nfunction foo() {\n    if (x) {\n        return y;\n    } else if (z) {\n        var t = \"foo\";\n    } else {\n        return w;\n    }\n}\n\nfunction foo() {\n    if (x) {\n        if (z) {\n            return y;\n        }\n    } else {\n        return z;\n    }\n}\n\nfunction foo() {\n    if (error) {\n        return 'It failed';\n    } else if (loading) {\n        return \"It's still loading\";\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-else-return: [\"error\", {allowElseIf: false}]*/\n\nfunction foo() {\n    if (error) {\n        return 'It failed';\n    } else if (loading) {\n        return \"It's still loading\";\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-else-return: [\"error\", {allowElseIf: false}]*/\n\nfunction foo() {\n    if (error) {\n        return 'It failed';\n    }\n\n    if (loading) {\n        return \"It's still loading\";\n    }\n}"
            }
        ]
    },
    {
        "name": "no-empty",
        "url": "https://eslint.org/docs/latest/rules/no-empty",
        "description": "Disallow empty block statementsEmpty block statements, while not technically errors, usually occur due to refactoring that wasn’t completed. They can cause confusion when reading code.This rule disallows empty block statements. This rule ignores block statements which contain a comment (for example, in an empty catch or finally block of a try statement to indicate that execution should continue regardless of errors).",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-empty: \"error\"*/\n\nif (foo) {\n}\n\nwhile (foo) {\n}\n\nswitch(foo) {\n}\n\ntry {\n    doSomething();\n} catch(ex) {\n\n} finally {\n\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty: \"error\"*/\n\nif (foo) {\n    // empty\n}\n\nwhile (foo) {\n    /* empty */\n}\n\ntry {\n    doSomething();\n} catch (ex) {\n    // continue regardless of error\n}\n\ntry {\n    doSomething();\n} finally {\n    /* continue regardless of error */\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\ntry {\n    doSomething();\n} catch (ex) {}\n\ntry {\n    doSomething();\n}\ncatch (ex) {}\nfinally {\n    /* continue regardless of error */\n}"
            }
        ]
    },
    {
        "name": "no-empty-function",
        "url": "https://eslint.org/docs/latest/rules/no-empty-function",
        "description": "Disallow empty functionsEmpty functions can reduce readability because readers need to guess whether it’s intentional or not. So writing a clear comment for empty functions is a good practice.Especially, the empty block of arrow functions might be confusing developers. It’s very similar to an empty object literal.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-empty-function: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo() {}\n\nvar foo = function() {};\n\nvar foo = () => {};\n\nfunction* foo() {}\n\nvar foo = function*() {};\n\nvar obj = {\n    foo: function() {},\n\n    foo: function*() {},\n\n    foo() {},\n\n    *foo() {},\n\n    get foo() {},\n\n    set foo(value) {}\n};\n\nclass A {\n    constructor() {}\n\n    foo() {}\n\n    *foo() {}\n\n    get foo() {}\n\n    set foo(value) {}\n\n    static foo() {}\n\n    static *foo() {}\n\n    static get foo() {}\n\n    static set foo(value) {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-function: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // do nothing.\n}\n\nvar foo = function() {\n    // any clear comments.\n};\n\nvar foo = () => {\n    bar();\n};\n\nfunction* foo() {\n    // do nothing.\n}\n\nvar foo = function*() {\n    // do nothing.\n};\n\nvar obj = {\n    foo: function() {\n        // do nothing.\n    },\n\n    foo: function*() {\n        // do nothing.\n    },\n\n    foo() {\n        // do nothing.\n    },\n\n    *foo() {\n        // do nothing.\n    },\n\n    get foo() {\n        // do nothing.\n    },\n\n    set foo(value) {\n        // do nothing.\n    }\n};\n\nclass A {\n    constructor() {\n        // do nothing.\n    }\n\n    foo() {\n        // do nothing.\n    }\n\n    *foo() {\n        // do nothing.\n    }\n\n    get foo() {\n        // do nothing.\n    }\n\n    set foo(value) {\n        // do nothing.\n    }\n\n    static foo() {\n        // do nothing.\n    }\n\n    static *foo() {\n        // do nothing.\n    }\n\n    static get foo() {\n        // do nothing.\n    }\n\n    static set foo(value) {\n        // do nothing.\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-function: [\"error\", { \"allow\": [\"functions\"] }]*/\n\nfunction foo() {}\n\nvar foo = function() {};\n\nvar obj = {\n    foo: function() {}\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-function: [\"error\", { \"allow\": [\"arrowFunctions\"] }]*/\n/*eslint-env es6*/\n\nvar foo = () => {};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-function: [\"error\", { \"allow\": [\"generatorFunctions\"] }]*/\n/*eslint-env es6*/\n\nfunction* foo() {}\n\nvar foo = function*() {};\n\nvar obj = {\n    foo: function*() {}\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-function: [\"error\", { \"allow\": [\"methods\"] }]*/\n/*eslint-env es6*/\n\nvar obj = {\n    foo() {}\n};\n\nclass A {\n    foo() {}\n    static foo() {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-function: [\"error\", { \"allow\": [\"generatorMethods\"] }]*/\n/*eslint-env es6*/\n\nvar obj = {\n    *foo() {}\n};\n\nclass A {\n    *foo() {}\n    static *foo() {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-function: [\"error\", { \"allow\": [\"getters\"] }]*/\n/*eslint-env es6*/\n\nvar obj = {\n    get foo() {}\n};\n\nclass A {\n    get foo() {}\n    static get foo() {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-function: [\"error\", { \"allow\": [\"setters\"] }]*/\n/*eslint-env es6*/\n\nvar obj = {\n    set foo(value) {}\n};\n\nclass A {\n    set foo(value) {}\n    static set foo(value) {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-function: [\"error\", { \"allow\": [\"constructors\"] }]*/\n/*eslint-env es6*/\n\nclass A {\n    constructor() {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-function: [\"error\", { \"allow\": [\"asyncFunctions\"] }]*/\n/*eslint-env es2017*/\n\nasync function a(){}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-function: [\"error\", { \"allow\": [\"asyncMethods\"] }]*/\n/*eslint-env es2017*/\n\nvar obj = {\n    async foo() {}\n};\n\nclass A {\n    async foo() {}\n    static async foo() {}\n}"
            }
        ]
    },
    {
        "name": "no-empty-static-block",
        "url": "https://eslint.org/docs/latest/rules/no-empty-static-block",
        "description": "Disallow empty static blocksEmpty static blocks, while not technically errors, usually occur due to refactoring that wasn’t completed. They can cause confusion when reading code.This rule disallows empty static blocks. This rule ignores static blocks which contain a comment.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-empty-static-block: \"error\"*/\n\nclass Foo {\n    static {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-empty-static-block: \"error\"*/\n\nclass Foo {\n    static {\n        bar();\n    }\n}\n\nclass Foo {\n    static {\n        // comment\n    }\n}"
            }
        ]
    },
    {
        "name": "no-eq-null",
        "url": "https://eslint.org/docs/latest/rules/no-eq-null",
        "description": "Disallow null comparisons without type-checking operatorsComparing to null without a type-checking operator (== or !=), can have unintended results as the comparison will evaluate to true when comparing to not just a null, but also an undefined value.The no-eq-null rule aims reduce potential bug and unwanted behavior by ensuring that comparisons to null only match null, and not also undefined. As such it will flag comparisons to null when using == and !=.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-eq-null: \"error\"*/\n\nif (foo == null) {\n  bar();\n}\n\nwhile (qux != null) {\n  baz();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-eq-null: \"error\"*/\n\nif (foo === null) {\n  bar();\n}\n\nwhile (qux !== null) {\n  baz();\n}"
            }
        ]
    },
    {
        "name": "no-eval",
        "url": "https://eslint.org/docs/latest/rules/no-eval",
        "description": "Disallow the use of eval()JavaScript’s eval() function is potentially dangerous and is often misused. Using eval() on untrusted code can open a program up to several different injection attacks. The use of eval() in most contexts can be substituted for a better, alternative approach to a problem.This rule is aimed at preventing potentially dangerous, unnecessary, and slow code by disallowing the use of the eval() function. As such, it will warn whenever the eval() function is used.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-eval: \"error\"*/\n\nvar obj = { x: \"foo\" },\n    key = \"x\",\n    value = eval(\"obj.\" + key);\n\n(0, eval)(\"var a = 0\");\n\nvar foo = eval;\nfoo(\"var a = 0\");\n\n// This `this` is the global object.\nthis.eval(\"var a = 0\");"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-eval: \"error\"*/\n/*eslint-env browser*/\n\nwindow.eval(\"var a = 0\");"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-eval: \"error\"*/\n/*eslint-env node*/\n\nglobal.eval(\"var a = 0\");"
            },
            {
                "type": "correct",
                "content": "/*eslint no-eval: \"error\"*/\n/*eslint-env es6*/\n\nvar obj = { x: \"foo\" },\n    key = \"x\",\n    value = obj[key];\n\nclass A {\n    foo() {\n        // This is a user-defined method.\n        this.eval(\"var a = 0\");\n    }\n\n    eval() {\n    }\n\n    static {\n        // This is a user-defined static method.\n        this.eval(\"var a = 0\");\n    }\n\n    static eval() {\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-eval: \"error\"*/\n\nvar obj = { x: \"foo\" },\n    key = \"x\",\n    value = eval(\"obj.\" + key);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-eval: \"error\"*/\n\n(0, eval)(\"var a = 0\");\n\nvar foo = eval;\nfoo(\"var a = 0\");\n\nthis.eval(\"var a = 0\");"
            },
            {
                "type": "correct",
                "content": "/*eslint no-eval: \"error\"*/\n/*eslint-env browser*/\n\nwindow.eval(\"var a = 0\");"
            },
            {
                "type": "correct",
                "content": "/*eslint no-eval: \"error\"*/\n/*eslint-env node*/\n\nglobal.eval(\"var a = 0\");"
            }
        ]
    },
    {
        "name": "no-extend-native",
        "url": "https://eslint.org/docs/latest/rules/no-extend-native",
        "description": "Disallow extending native typesIn JavaScript, you can extend any object, including builtin or “native” objects. Sometimes people change the behavior of these native objects in ways that break the assumptions made about them in other parts of the code.For example here we are overriding a builtin method that will then affect all Objects, even other builtins.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-extend-native: \"error\"*/\n\nObject.prototype.a = \"a\";\nObject.defineProperty(Array.prototype, \"times\", { value: 999 });"
            },
            {
                "type": "correct",
                "content": "/*eslint no-extend-native: [\"error\", { \"exceptions\": [\"Object\"] }]*/\n\nObject.prototype.a = \"a\";"
            }
        ]
    },
    {
        "name": "no-extra-bind",
        "url": "https://eslint.org/docs/latest/rules/no-extra-bind",
        "description": "Disallow unnecessary calls to .bind()The bind() method is used to create functions with specific this values and, optionally, binds arguments to specific values. When used to specify the value of this, it’s important that the function actually uses this in its function body. For example:This code is an example of a good use of bind() for setting the value of this.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-extra-bind: \"error\"*/\n/*eslint-env es6*/\n\nvar x = function () {\n    foo();\n}.bind(bar);\n\nvar x = (() => {\n    foo();\n}).bind(bar);\n\nvar x = (() => {\n    this.foo();\n}).bind(bar);\n\nvar x = function () {\n    (function () {\n      this.foo();\n    }());\n}.bind(bar);\n\nvar x = function () {\n    function foo() {\n      this.bar();\n    }\n}.bind(baz);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-extra-bind: \"error\"*/\n\nvar x = function () {\n    this.foo();\n}.bind(bar);\n\nvar x = function (a) {\n    return a + 1;\n}.bind(foo, bar);"
            }
        ]
    },
    {
        "name": "no-extra-boolean-cast",
        "url": "https://eslint.org/docs/latest/rules/no-extra-boolean-cast",
        "description": "Disallow unnecessary boolean castsIn contexts such as an if statement’s test where the result of the expression will already be coerced to a Boolean, casting to a Boolean via double negation (!!) or a Boolean call is unnecessary. For example, these if statements are equivalent:This rule disallows unnecessary boolean casts.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-extra-boolean-cast: \"error\"*/\n\nvar foo = !!!bar;\n\nvar foo = !!bar ? baz : bat;\n\nvar foo = Boolean(!!bar);\n\nvar foo = new Boolean(!!bar);\n\nif (!!foo) {\n    // ...\n}\n\nif (Boolean(foo)) {\n    // ...\n}\n\nwhile (!!foo) {\n    // ...\n}\n\ndo {\n    // ...\n} while (Boolean(foo));\n\nfor (; !!foo; ) {\n    // ...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-extra-boolean-cast: \"error\"*/\n\nvar foo = !!bar;\nvar foo = Boolean(bar);\n\nfunction foo() {\n    return !!bar;\n}\n\nvar foo = bar ? !!baz : !!bat;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-extra-boolean-cast: [\"error\", {\"enforceForLogicalOperands\": true}]*/\n\nif (!!foo || bar) {\n    //...\n}\n\nwhile (!!foo && bar) {\n    //...\n}\n\nif ((!!foo || bar) && baz) {\n    //...\n}\n\nfoo && Boolean(bar) ? baz : bat\n\nvar foo = new Boolean(!!bar || baz)"
            },
            {
                "type": "correct",
                "content": "/*eslint no-extra-boolean-cast: [\"error\", {\"enforceForLogicalOperands\": true}]*/\n\nif (foo || bar) {\n    //...\n}\n\nwhile (foo && bar) {\n    //...\n}\n\nif ((foo || bar) && baz) {\n    //...\n}\n\nfoo && bar ? baz : bat\n\nvar foo = new Boolean(bar || baz)\n\nvar foo = !!bar || baz;"
            }
        ]
    },
    {
        "name": "no-extra-label",
        "url": "https://eslint.org/docs/latest/rules/no-extra-label",
        "description": "Disallow unnecessary labelsIf a loop contains no nested loops or switches, labeling the loop is unnecessary.You can achieve the same result by removing the label and using break or continue without a label. Probably those labels would confuse developers because they expect labels to jump to further.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-extra-label: \"error\"*/\n\nA: while (a) {\n    break A;\n}\n\nB: for (let i = 0; i < 10; ++i) {\n    break B;\n}\n\nC: switch (a) {\n    case 0:\n        break C;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-extra-label: \"error\"*/\n\nwhile (a) {\n    break;\n}\n\nfor (let i = 0; i < 10; ++i) {\n    break;\n}\n\nswitch (a) {\n    case 0:\n        break;\n}\n\nA: {\n    break A;\n}\n\nB: while (a) {\n    while (b) {\n        break B;\n    }\n}\n\nC: switch (a) {\n    case 0:\n        while (b) {\n            break C;\n        }\n        break;\n}"
            }
        ]
    },
    {
        "name": "no-extra-semi",
        "url": "https://eslint.org/docs/latest/rules/no-extra-semi",
        "description": "Disallow unnecessary semicolonsTyping mistakes and misunderstandings about where semicolons are required can lead to semicolons that are unnecessary. While not technically an error, extra semicolons can cause confusion when reading code.This rule disallows unnecessary semicolons.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-extra-semi: \"error\"*/\n\nvar x = 5;;\n\nfunction foo() {\n    // code\n};\n\nclass C {\n    field;;\n\n    method() {\n        // code\n    };\n\n    static {\n        // code\n    };\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-extra-semi: \"error\"*/\n\nvar x = 5;\n\nfunction foo() {\n    // code\n}\n\nvar bar = function() {\n    // code\n};\n\nclass C {\n    field;\n\n    method() {\n        // code\n    }\n\n    static {\n        // code\n    }\n}"
            }
        ]
    },
    {
        "name": "no-floating-decimal",
        "url": "https://eslint.org/docs/latest/rules/no-floating-decimal",
        "description": "Disallow leading or trailing decimal points in numeric literalsFloat values in JavaScript contain a decimal point, and there is no requirement that the decimal point be preceded or followed by a number. For example, the following are all valid JavaScript numbers:Although not a syntax error, this format for numbers can make it difficult to distinguish between true decimal numbers and the dot operator. For this reason, some recommend that you should always include a number before and after a decimal point to make it clear the intent is to create a decimal number.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-floating-decimal: \"error\"*/\n\nvar num = .5;\nvar num = 2.;\nvar num = -.7;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-floating-decimal: \"error\"*/\n\nvar num = 0.5;\nvar num = 2.0;\nvar num = -0.7;"
            }
        ]
    },
    {
        "name": "no-global-assign",
        "url": "https://eslint.org/docs/latest/rules/no-global-assign",
        "description": "Disallow assignments to native objects or read-only global variablesJavaScript environments contain a number of built-in global variables, such as window in browsers and process in Node.js. In almost all cases, you don’t want to assign a value to these global variables as doing so could result in losing access to important functionality. For example, you probably don’t want to do this in browser code:While examples such as window are obvious, there are often hundreds of built-in global objects provided by JavaScript environments. It can be hard to know if you’re assigning to a global variable or not.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-global-assign: \"error\"*/\n\nObject = null\nundefined = 1"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-global-assign: \"error\"*/\n/*eslint-env browser*/\n\nwindow = {}\nlength = 1\ntop = 1"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-global-assign: \"error\"*/\n/*global a:readonly*/\n\na = 1"
            },
            {
                "type": "correct",
                "content": "/*eslint no-global-assign: \"error\"*/\n\na = 1\nvar b = 1\nb = 2"
            },
            {
                "type": "correct",
                "content": "/*eslint no-global-assign: \"error\"*/\n/*eslint-env browser*/\n\nonload = function() {}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-global-assign: \"error\"*/\n/*global a:writable*/\n\na = 1"
            }
        ]
    },
    {
        "name": "no-implicit-coercion",
        "url": "https://eslint.org/docs/latest/rules/no-implicit-coercion",
        "description": "Disallow shorthand type conversionsIn JavaScript, there are a lot of different ways to convert value types. Some of them might be hard to read and understand.Such as:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-implicit-coercion: \"error\"*/\n\nvar b = !!foo;\nvar b = ~foo.indexOf(\".\");\n// bitwise not is incorrect only with `indexOf`/`lastIndexOf` method calling."
            },
            {
                "type": "correct",
                "content": "/*eslint no-implicit-coercion: \"error\"*/\n\nvar b = Boolean(foo);\nvar b = foo.indexOf(\".\") !== -1;\n\nvar n = ~foo; // This is a just bitwise not."
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-implicit-coercion: \"error\"*/\n\nvar n = +foo;\nvar n = 1 * foo;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-implicit-coercion: \"error\"*/\n\nvar n = Number(foo);\nvar n = parseFloat(foo);\nvar n = parseInt(foo, 10);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-implicit-coercion: \"error\"*/\n\nvar s = \"\" + foo;\nvar s = `` + foo;\nfoo += \"\";\nfoo += ``;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-implicit-coercion: \"error\"*/\n\nvar s = String(foo);\nfoo = String(foo);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-implicit-coercion: [\"error\", { \"disallowTemplateShorthand\": true }]*/\n\nvar s = `${foo}`;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-implicit-coercion: [\"error\", { \"disallowTemplateShorthand\": true }]*/\n\nvar s = String(foo);\n\nvar s = `a${foo}`;\n\nvar s = `${foo}b`;\n\nvar s = `${foo}${bar}`;\n\nvar s = tag`${foo}`;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-implicit-coercion: [\"error\", { \"disallowTemplateShorthand\": false }]*/\n\nvar s = `${foo}`;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-implicit-coercion: [2, { \"allow\": [\"!!\", \"~\"] } ]*/\n\nvar b = !!foo;\nvar b = ~foo.indexOf(\".\");"
            }
        ]
    },
    {
        "name": "no-implicit-globals",
        "url": "https://eslint.org/docs/latest/rules/no-implicit-globals",
        "description": "Disallow declarations in the global scopeIt is the best practice to avoid ‘polluting’ the global scope with variables that are intended to be local to the script.Global variables created from a script can produce name collisions with global variables created from another script, which will usually lead to runtime errors or unexpected behavior.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-implicit-globals: \"error\"*/\n\nvar foo = 1;\n\nfunction bar() {}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-implicit-globals: \"error\"*/\n\n// explicitly set on window\nwindow.foo = 1;\nwindow.bar = function() {};\n\n// intended to be scope to this file\n(function() {\n  var foo = 1;\n\n  function bar() {}\n})();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-implicit-globals: \"error\"*/\n\n// foo and bar are local to module\nvar foo = 1;\nfunction bar() {}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-implicit-globals: \"error\"*/\n\nfoo = 1;\n\nBar.prototype.baz = function () {\n    a = 1; // Intended to be this.a = 1;\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-implicit-globals: \"error\"*/\n\n/*global foo:readonly*/\n\nfoo = 1;\n\nArray = [];\nvar Object;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-implicit-globals: [\"error\", {\"lexicalBindings\": false}]*/\n\nconst foo = 1;\n\nlet baz;\n\nclass Bar {}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-implicit-globals: [\"error\", {\"lexicalBindings\": true}]*/\n\nconst foo = 1;\n\nlet baz;\n\nclass Bar {}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-implicit-globals: [\"error\", {\"lexicalBindings\": true}]*/\n\n{\n    const foo = 1;\n    let baz;\n    class Bar {}\n}\n\n(function() {\n    const foo = 1;\n    let baz;\n    class Bar {}\n}());"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-implicit-globals: [\"error\", {\"lexicalBindings\": true}]*/\n\nconst MyGlobalFunction = (function() {\n    const a = 1;\n    let b = 2;\n    return function() {\n        return a + b;\n    }\n}());"
            },
            {
                "type": "correct",
                "content": "/*eslint no-implicit-globals: [\"error\", {\"lexicalBindings\": true}]*/\n\nwindow.MyGlobalFunction = (function() {\n    const a = 1;\n    let b = 2;\n    return function() {\n        return a + b;\n    }\n}());"
            },
            {
                "type": "correct",
                "content": "/* exported global_var */\n\nvar global_var = 42;"
            }
        ]
    },
    {
        "name": "no-implied-eval",
        "url": "https://eslint.org/docs/latest/rules/no-implied-eval",
        "description": "Disallow the use of eval()-like methodsIt’s considered a good practice to avoid using eval() in JavaScript. There are security and performance implications involved with doing so, which is why many linters (including ESLint) recommend disallowing eval(). However, there are some other ways to pass a string and have it interpreted as JavaScript code that have similar concerns.The first is using setTimeout(), setInterval() or execScript() (Internet Explorer only), all of which can accept a string of JavaScript code as their first argument. For example:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-implied-eval: \"error\"*/\n\nsetTimeout(\"alert('Hi!');\", 100);\n\nsetInterval(\"alert('Hi!');\", 100);\n\nexecScript(\"alert('Hi!')\");\n\nwindow.setTimeout(\"count = 5\", 10);\n\nwindow.setInterval(\"foo = bar\", 10);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-implied-eval: \"error\"*/\n\nsetTimeout(function() {\n    alert(\"Hi!\");\n}, 100);\n\nsetInterval(function() {\n    alert(\"Hi!\");\n}, 100);"
            }
        ]
    },
    {
        "name": "no-inline-comments",
        "url": "https://eslint.org/docs/latest/rules/no-inline-comments",
        "description": "Disallow inline comments after codeSome style guides disallow comments on the same line as code. Code can become difficult to read if comments immediately follow the code on the same line. On the other hand, it is sometimes faster and more obvious to put comments immediately following code.This rule disallows comments on the same line as code.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-inline-comments: \"error\"*/\n\nvar a = 1; // declaring a to 1\n\nfunction getRandomNumber(){\n    return 4; // chosen by fair dice roll.\n              // guaranteed to be random.\n}\n\n/* A block comment before code */ var b = 2;\n\nvar c = 3; /* A block comment after code */"
            },
            {
                "type": "correct",
                "content": "/*eslint no-inline-comments: \"error\"*/\n\n// This is a comment above a line of code\nvar foo = 5;\n\nvar bar = 5;\n//This is a comment below a line of code"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-inline-comments: \"error\"*/\n\nvar foo = <div>{ /* On the same line with other code */ }<h1>Some heading</h1></div>;\n\nvar bar = (\n    <div>\n    {   // These braces are not just for the comment, so it can't be on the same line\n        baz\n    }\n    </div>\n);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-inline-comments: \"error\"*/\n\nvar foo = (\n    <div>\n      {/* These braces are just for this comment and there is nothing else on this line */}\n      <h1>Some heading</h1>\n    </div>\n)\n\nvar bar = (\n    <div>\n    {\n        // There is nothing else on this line\n        baz\n    }\n    </div>\n);\n\nvar quux = (\n    <div>\n      {/*\n        Multiline\n        comment\n      */}\n      <h1>Some heading</h1>\n    </div>\n)"
            },
            {
                "type": "correct",
                "content": "/*eslint no-inline-comments: [\"error\", { \"ignorePattern\": \"webpackChunkName:\\\\s.+\" }]*/\n\nimport(/* webpackChunkName: \"my-chunk-name\" */ './locale/en');"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-inline-comments: [\"error\", { \"ignorePattern\": \"something\" }] */\n\nvar foo = 4; // other thing"
            }
        ]
    },
    {
        "name": "no-invalid-this",
        "url": "https://eslint.org/docs/latest/rules/no-invalid-this",
        "description": "Disallow use of this in contexts where the value of this is undefinedUnder the strict mode, this keywords outside of classes or class-like objects might be undefined and raise a TypeError.This rule aims to flag usage of this keywords in contexts where the value of this is undefined.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-invalid-this: \"error\"*/\n/*eslint-env es6*/\n\n\"use strict\";\n\n(function() {\n    this.a = 0;\n    baz(() => this);\n})();\n\nfunction foo() {\n    this.a = 0;\n    baz(() => this);\n}\n\nvar foo = function() {\n    this.a = 0;\n    baz(() => this);\n};\n\nfoo(function() {\n    this.a = 0;\n    baz(() => this);\n});\n\nvar obj = {\n    aaa: function() {\n        return function foo() {\n            // There is in a method `aaa`, but `foo` is not a method.\n            this.a = 0;\n            baz(() => this);\n        };\n    }\n};\n\nfoo.forEach(function() {\n    this.a = 0;\n    baz(() => this);\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint no-invalid-this: \"error\"*/\n/*eslint-env es6*/\n\n\"use strict\";\n\nthis.a = 0;\nbaz(() => this);\n\nfunction Foo() {\n    // OK, this is in a legacy style constructor.\n    this.a = 0;\n    baz(() => this);\n}\n\nclass Foo {\n    constructor() {\n        // OK, this is in a constructor.\n        this.a = 0;\n        baz(() => this);\n    }\n}\n\nvar obj = {\n    foo: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }\n};\n\nvar obj = {\n    foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }\n};\n\nvar obj = {\n    get foo() {\n        // OK, this is in a method (this function is on object literal).\n        return this.a;\n    }\n};\n\nvar obj = Object.create(null, {\n    foo: {value: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }}\n});\n\nObject.defineProperty(obj, \"foo\", {\n    value: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }\n});\n\nObject.defineProperties(obj, {\n    foo: {value: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }}\n});\n\nfunction Foo() {\n    this.foo = function foo() {\n        // OK, this is in a method (this function assigns to a property).\n        this.a = 0;\n        baz(() => this);\n    };\n}\n\nobj.foo = function foo() {\n    // OK, this is in a method (this function assigns to a property).\n    this.a = 0;\n};\n\nFoo.prototype.foo = function foo() {\n    // OK, this is in a method (this function assigns to a property).\n    this.a = 0;\n};\n\nclass Foo {\n\n    // OK, this is in a class field initializer.\n    a = this.b;\n\n    // OK, static initializers also have valid this.\n    static a = this.b;\n\n    foo() {\n        // OK, this is in a method.\n        this.a = 0;\n        baz(() => this);\n    }\n\n    static foo() {\n        // OK, this is in a method (static methods also have valid this).\n        this.a = 0;\n        baz(() => this);\n    }\n\n    static {\n        // OK, static blocks also have valid this.\n        this.a = 0;\n        baz(() => this);\n    }\n}\n\nvar foo = (function foo() {\n    // OK, the `bind` method of this function is called directly.\n    this.a = 0;\n}).bind(obj);\n\nfoo.forEach(function() {\n    // OK, `thisArg` of `.forEach()` is given.\n    this.a = 0;\n    baz(() => this);\n}, thisArg);\n\n/** @this Foo */\nfunction foo() {\n    // OK, this function has a `@this` tag in its JSDoc comment.\n    this.a = 0;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-invalid-this: [\"error\", { \"capIsConstructor\": false }]*/\n\n\"use strict\";\n\nfunction Foo() {\n    this.a = 0;\n}\n\nvar bar = function Foo() {\n    this.a = 0;\n}\n\nvar Bar = function() {\n    this.a = 0;\n};\n\nBaz = function() {\n    this.a = 0;\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-invalid-this: [\"error\", { \"capIsConstructor\": false }]*/\n\n\"use strict\";\n\nobj.Foo = function Foo() {\n    // OK, this is in a method.\n    this.a = 0;\n};"
            }
        ]
    },
    {
        "name": "no-iterator",
        "url": "https://eslint.org/docs/latest/rules/no-iterator",
        "description": "Disallow the use of the __iterator__ propertyThe __iterator__ property was a SpiderMonkey extension to JavaScript that could be used to create custom iterators that are compatible with JavaScript’s for in and for each constructs. However, this property is now obsolete, so it should not be used. Here’s an example of how this used to work:You should use ECMAScript 6 iterators and generators instead.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-iterator: \"error\"*/\n\nFoo.prototype.__iterator__ = function() {\n    return new FooIterator(this);\n};\n\nfoo.__iterator__ = function () {};\n\nfoo[\"__iterator__\"] = function () {};\n"
            },
            {
                "type": "correct",
                "content": "/*eslint no-iterator: \"error\"*/\n\nvar __iterator__ = foo; // Not using the `__iterator__` property."
            }
        ]
    },
    {
        "name": "no-label-var",
        "url": "https://eslint.org/docs/latest/rules/no-label-var",
        "description": "Disallow labels that share a name with a variableThis rule aims to create clearer code by disallowing the bad practice of creating a label that shares a name with a variable that is in scope.Examples of incorrect code for this rule:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-label-var: \"error\"*/\n\nvar x = foo;\nfunction bar() {\nx:\n  for (;;) {\n    break x;\n  }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-label-var: \"error\"*/\n\n// The variable that has the same name as the label is not in scope.\n\nfunction foo() {\n  var q = t;\n}\n\nfunction bar() {\nq:\n  for(;;) {\n    break q;\n  }\n}"
            }
        ]
    },
    {
        "name": "no-labels",
        "url": "https://eslint.org/docs/latest/rules/no-labels",
        "description": "Disallow labeled statementsLabeled statements in JavaScript are used in conjunction with break and continue to control flow around multiple loops. For example:The break outer statement ensures that this code will not result in an infinite loop because control is returned to the next statement after the outer label was applied. If this statement was changed to be just break, control would flow back to the outer while statement and an infinite loop would result.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-labels: \"error\"*/\n\nlabel:\n    while(true) {\n        // ...\n    }\n\nlabel:\n    while(true) {\n        break label;\n    }\n\nlabel:\n    while(true) {\n        continue label;\n    }\n\nlabel:\n    switch (a) {\n    case 0:\n        break label;\n    }\n\nlabel:\n    {\n        break label;\n    }\n\nlabel:\n    if (a) {\n        break label;\n    }"
            },
            {
                "type": "correct",
                "content": "/*eslint no-labels: \"error\"*/\n\nvar f = {\n    label: \"foo\"\n};\n\nwhile (true) {\n    break;\n}\n\nwhile (true) {\n    continue;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-labels: [\"error\", { \"allowLoop\": true }]*/\n\nlabel:\n    while (true) {\n        break label;\n    }"
            },
            {
                "type": "correct",
                "content": "/*eslint no-labels: [\"error\", { \"allowSwitch\": true }]*/\n\nlabel:\n    switch (a) {\n        case 0:\n            break label;\n    }"
            }
        ]
    },
    {
        "name": "no-lone-blocks",
        "url": "https://eslint.org/docs/latest/rules/no-lone-blocks",
        "description": "Disallow unnecessary nested blocksIn JavaScript, prior to ES6, standalone code blocks delimited by curly braces do not create a new scope and have no use. For example, these curly braces do nothing to foo:In ES6, code blocks may create a new scope if a block-level binding (let and const), a class declaration or a function declaration (in strict mode) are present. A block is not considered redundant in these cases.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-lone-blocks: \"error\"*/\n\n{}\n\nif (foo) {\n    bar();\n    {\n        baz();\n    }\n}\n\nfunction bar() {\n    {\n        baz();\n    }\n}\n\n{\n    function foo() {}\n}\n\n{\n    aLabel: {\n    }\n}\n\nclass C {\n    static {\n        {\n            foo();\n        }\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-lone-blocks: \"error\"*/\n/*eslint-env es6*/\n\nwhile (foo) {\n    bar();\n}\n\nif (foo) {\n    if (bar) {\n        baz();\n    }\n}\n\nfunction bar() {\n    baz();\n}\n\n{\n    let x = 1;\n}\n\n{\n    const y = 1;\n}\n\n{\n    class Foo {}\n}\n\naLabel: {\n}\n\nclass C {\n    static {\n        lbl: {\n            if (something) {\n                break lbl;\n            }\n\n            foo();\n        }\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-lone-blocks: \"error\"*/\n/*eslint-env es6*/\n\n\"use strict\";\n\n{\n    function foo() {}\n}"
            }
        ]
    },
    {
        "name": "no-lonely-if",
        "url": "https://eslint.org/docs/latest/rules/no-lonely-if",
        "description": "Disallow if statements as the only statement in else blocksIf an if statement is the only statement in the else block, it is often clearer to use an else if form.should be rewritten as",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-lonely-if: \"error\"*/\n\nif (condition) {\n    // ...\n} else {\n    if (anotherCondition) {\n        // ...\n    }\n}\n\nif (condition) {\n    // ...\n} else {\n    if (anotherCondition) {\n        // ...\n    } else {\n        // ...\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-lonely-if: \"error\"*/\n\nif (condition) {\n    // ...\n} else if (anotherCondition) {\n    // ...\n}\n\nif (condition) {\n    // ...\n} else if (anotherCondition) {\n    // ...\n} else {\n    // ...\n}\n\nif (condition) {\n    // ...\n} else {\n    if (anotherCondition) {\n        // ...\n    }\n    doSomething();\n}"
            }
        ]
    },
    {
        "name": "no-loop-func",
        "url": "https://eslint.org/docs/latest/rules/no-loop-func",
        "description": "Disallow function declarations that contain unsafe references inside loop statementsWriting functions within loops tends to result in errors due to the way the function creates a closure around the loop. For example:In this case, you would expect each function created within the loop to return a different number. In reality, each function returns 10, because that was the last value of i in the scope.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-loop-func: \"error\"*/\n/*eslint-env es6*/\n\nfor (var i=10; i; i--) {\n    (function() { return i; })();\n}\n\nwhile(i) {\n    var a = function() { return i; };\n    a();\n}\n\ndo {\n    function a() { return i; };\n    a();\n} while (i);\n\nlet foo = 0;\nfor (let i = 0; i < 10; ++i) {\n    //Bad, `foo` is not in the loop-block's scope and `foo` is modified in/after the loop\n    setTimeout(() => console.log(foo));\n    foo += 1;\n}\n\nfor (let i = 0; i < 10; ++i) {\n    //Bad, `foo` is not in the loop-block's scope and `foo` is modified in/after the loop\n    setTimeout(() => console.log(foo));\n}\nfoo = 100;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-loop-func: \"error\"*/\n/*eslint-env es6*/\n\nvar a = function() {};\n\nfor (var i=10; i; i--) {\n    a();\n}\n\nfor (var i=10; i; i--) {\n    var a = function() {}; // OK, no references to variables in the outer scopes.\n    a();\n}\n\nfor (let i=10; i; i--) {\n    var a = function() { return i; }; // OK, all references are referring to block scoped variables in the loop.\n    a();\n}\n\nvar foo = 100;\nfor (let i=10; i; i--) {\n    var a = function() { return foo; }; // OK, all references are referring to never modified variables.\n    a();\n}\n//... no modifications of foo after this loop ..."
            }
        ]
    },
    {
        "name": "no-magic-numbers",
        "url": "https://eslint.org/docs/latest/rules/no-magic-numbers",
        "description": "Disallow magic numbers‘Magic numbers’ are numbers that occur multiple times in code without an explicit meaning. They should preferably be replaced by named constants.The no-magic-numbers rule aims to make code more readable and refactoring easier by ensuring that special numbers are declared as constants to make their meaning explicit.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-magic-numbers: \"error\"*/\n\nvar dutyFreePrice = 100,\n    finalPrice = dutyFreePrice + (dutyFreePrice * 0.25);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-magic-numbers: \"error\"*/\n\nvar data = ['foo', 'bar', 'baz'];\n\nvar dataLast = data[2];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-magic-numbers: \"error\"*/\n\nvar SECONDS;\n\nSECONDS = 60;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-magic-numbers: \"error\"*/\n\nvar TAX = 0.25;\n\nvar dutyFreePrice = 100,\n    finalPrice = dutyFreePrice + (dutyFreePrice * TAX);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-magic-numbers: [\"error\", { \"ignore\": [1] }]*/\n\nvar data = ['foo', 'bar', 'baz'];\nvar dataLast = data.length && data[data.length - 1];"
            },
            {
                "type": "correct",
                "content": "/*eslint no-magic-numbers: [\"error\", { \"ignore\": [\"1n\"] }]*/\n\nfoo(1n);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-magic-numbers: [\"error\", { \"ignoreArrayIndexes\": true }]*/\n\nvar item = data[2];\n\ndata[100] = a;\n\nf(data[0]);\n\na = data[-0]; // same as data[0], -0 will be coerced to \"0\"\n\na = data[0xAB];\n\na = data[5.6e1];\n\na = data[10n]; // same as data[10], 10n will be coerced to \"10\"\n\na = data[4294967294]; // max array index"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-magic-numbers: [\"error\", { \"ignoreArrayIndexes\": true }]*/\n\nf(2); // not used as array index\n\na = data[-1];\n\na = data[2.5];\n\na = data[5.67e1];\n\na = data[-10n];\n\na = data[4294967295]; // above the max array index\n\na = data[1e500]; // same as data[\"Infinity\"]"
            },
            {
                "type": "correct",
                "content": "/*eslint no-magic-numbers: [\"error\", { \"ignoreDefaultValues\": true }]*/\n\nconst { tax = 0.25 } = accountancy;\n\nfunction mapParallel(concurrency = 3) { /***/ }"
            },
            {
                "type": "correct",
                "content": "/*eslint no-magic-numbers: [\"error\", { \"ignoreDefaultValues\": true }]*/\n\nlet head;\n[head = 100] = []"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-magic-numbers: [\"error\", { \"enforceConst\": true }]*/\n\nvar TAX = 0.25;\n\nvar dutyFreePrice = 100,\n    finalPrice = dutyFreePrice + (dutyFreePrice * TAX);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-magic-numbers: [\"error\", { \"detectObjects\": true }]*/\n\nvar magic = {\n  tax: 0.25\n};\n\nvar dutyFreePrice = 100,\n    finalPrice = dutyFreePrice + (dutyFreePrice * magic.tax);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-magic-numbers: [\"error\", { \"detectObjects\": true }]*/\n\nvar TAX = 0.25;\n\nvar magic = {\n  tax: TAX\n};\n\nvar dutyFreePrice = 100,\n    finalPrice = dutyFreePrice + (dutyFreePrice * magic.tax);"
            }
        ]
    },
    {
        "name": "no-mixed-operators",
        "url": "https://eslint.org/docs/latest/rules/no-mixed-operators",
        "description": "Disallow mixed binary operatorsEnclosing complex expressions by parentheses clarifies the developer’s intention, which makes the code more readable. This rule warns when different operators are used consecutively without parentheses in an expression.Note: It is expected for this rule to emit one error for each mixed operator in a pair. As a result, for each two consecutive mixed operators used, a distinct error will be displayed, pointing to where the specific operator that breaks the rule is used:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-mixed-operators: \"error\"*/\n\nvar foo = a && b < 0 || c > 0 || d + 1 === 0;\nvar foo = a + b * c;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-mixed-operators: \"error\"*/\n\nvar foo = a || b || c;\nvar foo = a && b && c;\nvar foo = (a && b < 0) || c > 0 || d + 1 === 0;\nvar foo = a && (b < 0 || c > 0 || d + 1 === 0);\nvar foo = a + (b * c);\nvar foo = (a + b) * c;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-mixed-operators: [\"error\", {\"groups\": [[\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"], [\"&&\", \"||\"]]}]*/\n\nvar foo = a && b < 0 || c > 0 || d + 1 === 0;\nvar foo = a & b | c;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-mixed-operators: [\"error\", {\"groups\": [[\"&&\", \"||\", \"?:\"]]}]*/\n\nvar foo = a || b ? c : d;\n\nvar bar = a ? b || c : d;\n\nvar baz = a ? b : c || d;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-mixed-operators: [\"error\", {\"groups\": [[\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"], [\"&&\", \"||\"]]}]*/\n\nvar foo = a || b > 0 || c + 1 === 0;\nvar foo = a && b > 0 && c + 1 === 0;\nvar foo = (a && b < 0) || c > 0 || d + 1 === 0;\nvar foo = a && (b < 0 ||  c > 0 || d + 1 === 0);\nvar foo = (a & b) | c;\nvar foo = a & (b | c);\nvar foo = a + b * c;\nvar foo = a + (b * c);\nvar foo = (a + b) * c;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-mixed-operators: [\"error\", {\"groups\": [[\"&&\", \"||\", \"?:\"]]}]*/\n\nvar foo = (a || b) ? c : d;\nvar foo = a || (b ? c : d);\n\nvar bar = a ? (b || c) : d;\n\nvar baz = a ? b : (c || d);\nvar baz = (a ? b : c) || d;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-mixed-operators: [\"error\", {\"allowSamePrecedence\": true}]*/\n\n// + and - have the same precedence.\nvar foo = a + b - c;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-mixed-operators: [\"error\", {\"allowSamePrecedence\": false}]*/\n\n// + and - have the same precedence.\nvar foo = a + b - c;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-mixed-operators: [\"error\", {\"allowSamePrecedence\": false}]*/\n\n// + and - have the same precedence.\nvar foo = (a + b) - c;"
            }
        ]
    },
    {
        "name": "no-multi-assign",
        "url": "https://eslint.org/docs/latest/rules/no-multi-assign",
        "description": "Disallow use of chained assignment expressionsChaining the assignment of variables can lead to unexpected results and be difficult to read.This rule disallows using multiple assignments within a single statement.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-multi-assign: \"error\"*/\n\nvar a = b = c = 5;\n\nconst foo = bar = \"baz\";\n\nlet a =\n    b =\n    c;\n\nclass Foo {\n    a = b = 10;\n}\n\na = b = \"quux\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multi-assign: \"error\"*/\n\nvar a = 5;\nvar b = 5;\nvar c = 5;\n\nconst foo = \"baz\";\nconst bar = \"baz\";\n\nlet a = c;\nlet b = c;\n\nclass Foo {\n    a = 10;\n    b = 10;\n}\n\na = \"quux\";\nb = \"quux\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multi-assign: [\"error\", { \"ignoreNonDeclaration\": true }]*/\n\nlet a;\nlet b;\na = b = \"baz\";\n\nconst x = {};\nconst y = {};\nx.one = y.one = 1;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-multi-assign: [\"error\", { \"ignoreNonDeclaration\": true }]*/\n\nlet a = b = \"baz\";\n\nconst foo = bar = 1;\n\nclass Foo {\n    a = b = 10;\n}"
            }
        ]
    },
    {
        "name": "no-multi-str",
        "url": "https://eslint.org/docs/latest/rules/no-multi-str",
        "description": "Disallow multiline stringsIt’s possible to create multiline strings in JavaScript by using a slash before a newline, such as:Some consider this to be a bad practice as it was an undocumented feature of JavaScript that was only formalized later.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-multi-str: \"error\"*/\n\nvar x = \"some very \\\nlong text\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multi-str: \"error\"*/\n\nvar x = \"some very long text\";\n\nvar x = \"some very \" +\n        \"long text\";"
            }
        ]
    },
    {
        "name": "no-negated-condition",
        "url": "https://eslint.org/docs/latest/rules/no-negated-condition",
        "description": "Disallow negated conditionsNegated conditions are more difficult to understand. Code can be made more readable by inverting the condition instead.This rule disallows negated conditions in either of the following:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-negated-condition: \"error\"*/\n\nif (!a) {\n    doSomething();\n} else {\n    doSomethingElse();\n}\n\nif (a != b) {\n    doSomething();\n} else {\n    doSomethingElse();\n}\n\nif (a !== b) {\n    doSomething();\n} else {\n    doSomethingElse();\n}\n\n!a ? c : b"
            },
            {
                "type": "correct",
                "content": "/*eslint no-negated-condition: \"error\"*/\n\nif (!a) {\n    doSomething();\n}\n\nif (!a) {\n    doSomething();\n} else if (b) {\n    doSomething();\n}\n\nif (a != b) {\n    doSomething();\n}\n\na ? b : c"
            }
        ]
    },
    {
        "name": "no-nested-ternary",
        "url": "https://eslint.org/docs/latest/rules/no-nested-ternary",
        "description": "Disallow nested ternary expressionsNesting ternary expressions can make code more difficult to understand.The no-nested-ternary rule disallows nested ternary expressions.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-nested-ternary: \"error\"*/\n\nvar thing = foo ? bar : baz === qux ? quxx : foobar;\n\nfoo ? baz === qux ? quxx() : foobar() : bar();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-nested-ternary: \"error\"*/\n\nvar thing = foo ? bar : foobar;\n\nvar thing;\n\nif (foo) {\n  thing = bar;\n} else if (baz === qux) {\n  thing = quxx;\n} else {\n  thing = foobar;\n}"
            }
        ]
    },
    {
        "name": "no-new",
        "url": "https://eslint.org/docs/latest/rules/no-new",
        "description": "Disallow new operators outside of assignments or comparisonsThe goal of using new with a constructor is typically to create an object of a particular type and store that object in a variable, such as:It’s less common to use new and not store the result, such as:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-new: \"error\"*/\n\nnew Thing();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-new: \"error\"*/\n\nvar thing = new Thing();\n\nThing();"
            }
        ]
    },
    {
        "name": "no-new-func",
        "url": "https://eslint.org/docs/latest/rules/no-new-func",
        "description": "Disallow new operators with the Function objectIt’s possible to create functions in JavaScript from strings at runtime using the Function constructor, such as:This is considered by many to be a bad practice due to the difficulty in debugging and reading these types of functions. In addition, Content-Security-Policy (CSP) directives may disallow the use of eval() and similar methods for creating code from strings.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-new-func: \"error\"*/\n\nvar x = new Function(\"a\", \"b\", \"return a + b\");\nvar x = Function(\"a\", \"b\", \"return a + b\");\nvar x = Function.call(null, \"a\", \"b\", \"return a + b\");\nvar x = Function.apply(null, [\"a\", \"b\", \"return a + b\"]);\nvar x = Function.bind(null, \"a\", \"b\", \"return a + b\")();\nvar f = Function.bind(null, \"a\", \"b\", \"return a + b\"); // assuming that the result of Function.bind(...) will be eventually called."
            },
            {
                "type": "correct",
                "content": "/*eslint no-new-func: \"error\"*/\n\nvar x = function (a, b) {\n    return a + b;\n};"
            }
        ]
    },
    {
        "name": "no-new-object",
        "url": "https://eslint.org/docs/latest/rules/no-new-object",
        "description": "Disallow Object constructorsThe Object constructor is used to create new generic objects in JavaScript, such as:However, this is no different from using the more concise object literal syntax:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-new-object: \"error\"*/\n\nvar myObject = new Object();\n\nnew Object();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-new-object: \"error\"*/\n\nvar myObject = new CustomObject();\n\nvar myObject = {};\n\nvar Object = function Object() {};\nnew Object();"
            }
        ]
    },
    {
        "name": "no-new-wrappers",
        "url": "https://eslint.org/docs/latest/rules/no-new-wrappers",
        "description": "Disallow new operators with the String, Number, and Boolean objectsThere are three primitive types in JavaScript that have wrapper objects: string, number, and boolean. These are represented by the constructors String, Number, and Boolean, respectively. The primitive wrapper types are used whenever one of these primitive values is read, providing them with object-like capabilities such as methods. Behind the scenes, an object of the associated wrapper type is created and then destroyed, which is why you can call methods on primitive values, such as:Behind the scenes in this example, a String object is constructed. The substring() method exists on String.prototype and so is accessible to the string instance.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-new-wrappers: \"error\"*/\n\nvar stringObject = new String(\"Hello world\");\nvar numberObject = new Number(33);\nvar booleanObject = new Boolean(false);\n\nvar stringObject = new String;\nvar numberObject = new Number;\nvar booleanObject = new Boolean;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-new-wrappers: \"error\"*/\n\nvar text = String(someValue);\nvar num = Number(someValue);\n\nvar object = new MyString();"
            }
        ]
    },
    {
        "name": "no-nonoctal-decimal-escape",
        "url": "https://eslint.org/docs/latest/rules/no-nonoctal-decimal-escape",
        "description": "Disallow \\8 and \\9 escape sequences in string literalsAlthough not being specified in the language until ECMAScript 2021, \\8 and \\9 escape sequences in string literals were allowed in most JavaScript engines, and treated as “useless” escapes:Since ECMAScript 2021, these escape sequences are specified as non-octal decimal escape sequences, retaining the same behavior.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-nonoctal-decimal-escape: \"error\"*/\n\n\"\\8\";\n\n\"\\9\";\n\nvar foo = \"w\\8less\";\n\nvar bar = \"December 1\\9\";\n\nvar baz = \"Don't use \\8 and \\9 escapes.\";\n\nvar quux = \"\\0\\8\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-nonoctal-decimal-escape: \"error\"*/\n\n\"8\";\n\n\"9\";\n\nvar foo = \"w8less\";\n\nvar bar = \"December 19\";\n\nvar baz = \"Don't use \\\\8 and \\\\9 escapes.\";\n\nvar quux = \"\\0\\u0038\";"
            }
        ]
    },
    {
        "name": "no-octal",
        "url": "https://eslint.org/docs/latest/rules/no-octal",
        "description": "Disallow octal literalsOctal literals are numerals that begin with a leading zero, such as:Because the leading zero which identifies an octal literal has been a source of confusion and error in JavaScript code, ECMAScript 5 deprecates the use of octal numeric literals.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-octal: \"error\"*/\n\nvar num = 071;\nvar result = 5 + 07;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-octal: \"error\"*/\n\nvar num  = \"071\";"
            }
        ]
    },
    {
        "name": "no-octal-escape",
        "url": "https://eslint.org/docs/latest/rules/no-octal-escape",
        "description": "Disallow octal escape sequences in string literalsAs of the ECMAScript 5 specification, octal escape sequences in string literals are deprecated and should not be used. Unicode escape sequences should be used instead.This rule disallows octal escape sequences in string literals.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-octal-escape: \"error\"*/\n\nvar foo = \"Copyright \\251\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-octal-escape: \"error\"*/\n\nvar foo = \"Copyright \\u00A9\";   // unicode\n\nvar foo = \"Copyright \\xA9\";     // hexadecimal"
            }
        ]
    },
    {
        "name": "no-param-reassign",
        "url": "https://eslint.org/docs/latest/rules/no-param-reassign",
        "description": "Disallow reassigning function parametersAssignment to variables declared as function parameters can be misleading and lead to confusing behavior, as modifying function parameters will also mutate the arguments object. Often, assignment to function parameters is unintended and indicative of a mistake or programmer error.This rule can be also configured to fail when function parameters are modified. Side effects on parameters can cause counter-intuitive execution flow and make errors difficult to track down.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-param-reassign: \"error\"*/\n\nfunction foo(bar) {\n    bar = 13;\n}\n\nfunction foo(bar) {\n    bar++;\n}\n\nfunction foo(bar) {\n    for (bar in baz) {}\n}\n\nfunction foo(bar) {\n    for (bar of baz) {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-param-reassign: \"error\"*/\n\nfunction foo(bar) {\n    var baz = bar;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-param-reassign: [\"error\", { \"props\": false }]*/\n\nfunction foo(bar) {\n    bar.prop = \"value\";\n}\n\nfunction foo(bar) {\n    delete bar.aaa;\n}\n\nfunction foo(bar) {\n    bar.aaa++;\n}\n\nfunction foo(bar) {\n    for (bar.aaa in baz) {}\n}\n\nfunction foo(bar) {\n    for (bar.aaa of baz) {}\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-param-reassign: [\"error\", { \"props\": true }]*/\n\nfunction foo(bar) {\n    bar.prop = \"value\";\n}\n\nfunction foo(bar) {\n    delete bar.aaa;\n}\n\nfunction foo(bar) {\n    bar.aaa++;\n}\n\nfunction foo(bar) {\n    for (bar.aaa in baz) {}\n}\n\nfunction foo(bar) {\n    for (bar.aaa of baz) {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-param-reassign: [\"error\", { \"props\": true, \"ignorePropertyModificationsFor\": [\"bar\"] }]*/\n\nfunction foo(bar) {\n    bar.prop = \"value\";\n}\n\nfunction foo(bar) {\n    delete bar.aaa;\n}\n\nfunction foo(bar) {\n    bar.aaa++;\n}\n\nfunction foo(bar) {\n    for (bar.aaa in baz) {}\n}\n\nfunction foo(bar) {\n    for (bar.aaa of baz) {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-param-reassign: [\"error\", { \"props\": true, \"ignorePropertyModificationsForRegex\": [\"^bar\"] }]*/\n\nfunction foo(barVar) {\n    barVar.prop = \"value\";\n}\n\nfunction foo(barrito) {\n    delete barrito.aaa;\n}\n\nfunction foo(bar_) {\n    bar_.aaa++;\n}\n\nfunction foo(barBaz) {\n    for (barBaz.aaa in baz) {}\n}\n\nfunction foo(barBaz) {\n    for (barBaz.aaa of baz) {}\n}"
            }
        ]
    },
    {
        "name": "no-plusplus",
        "url": "https://eslint.org/docs/latest/rules/no-plusplus",
        "description": "Disallow the unary operators ++ and --Because the unary ++ and -- operators are subject to automatic semicolon insertion, differences in whitespace can change semantics of source code.This rule disallows the unary operators ++ and --.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-plusplus: \"error\"*/\n\nvar foo = 0;\nfoo++;\n\nvar bar = 42;\nbar--;\n\nfor (i = 0; i < l; i++) {\n    return;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-plusplus: \"error\"*/\n\nvar foo = 0;\nfoo += 1;\n\nvar bar = 42;\nbar -= 1;\n\nfor (i = 0; i < l; i += 1) {\n    return;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-plusplus: [\"error\", { \"allowForLoopAfterthoughts\": true }]*/\n\nfor (i = 0; i < l; i++) {\n    doSomething(i);\n}\n\nfor (i = l; i >= 0; i--) {\n    doSomething(i);\n}\n\nfor (i = 0, j = l; i < l; i++, j--) {\n    doSomething(i, j);\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-plusplus: [\"error\", { \"allowForLoopAfterthoughts\": true }]*/\n\nfor (i = 0; i < l; j = i++) {\n    doSomething(i, j);\n}\n\nfor (i = l; i--;) {\n    doSomething(i);\n}\n\nfor (i = 0; i < l;) i++;"
            }
        ]
    },
    {
        "name": "no-proto",
        "url": "https://eslint.org/docs/latest/rules/no-proto",
        "description": "Disallow the use of the __proto__ property__proto__ property has been deprecated as of ECMAScript 3.1 and shouldn’t be used in the code. Use Object.getPrototypeOf and Object.setPrototypeOf instead.When an object is created with the new operator, __proto__ is set to the original “prototype” property of the object’s constructor function. Object.getPrototypeOf is the preferred method of getting the object’s prototype. To change an object’s prototype, use Object.setPrototypeOf.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-proto: \"error\"*/\n\nvar a = obj.__proto__;\n\nvar a = obj[\"__proto__\"];\n\nobj.__proto__ = b;\n\nobj[\"__proto__\"] = b;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-proto: \"error\"*/\n\nvar a = Object.getPrototypeOf(obj);\n\nObject.setPrototypeOf(obj, b);\n\nvar c = { __proto__: a };"
            }
        ]
    },
    {
        "name": "no-redeclare",
        "url": "https://eslint.org/docs/latest/rules/no-redeclare",
        "description": "Disallow variable redeclarationIn JavaScript, it’s possible to redeclare the same variable name using var. This can lead to confusion as to where the variable is actually declared and initialized.This rule is aimed at eliminating variables that have multiple declarations in the same scope.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-redeclare: \"error\"*/\n\nvar a = 3;\nvar a = 10;\n\nclass C {\n    foo() {\n        var b = 3;\n        var b = 10;\n    }\n\n    static {\n        var c = 3;\n        var c = 10;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-redeclare: \"error\"*/\n\nvar a = 3;\na = 10;\n\nclass C {\n    foo() {\n        var b = 3;\n        b = 10;\n    }\n\n    static {\n        var c = 3;\n        c = 10;\n    }\n}\n"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-redeclare: [\"error\", { \"builtinGlobals\": true }]*/\n\nvar Object = 0;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-redeclare: [\"error\", { \"builtinGlobals\": true }]*/\n/*eslint-env browser*/\n\nvar top = 0;"
            }
        ]
    },
    {
        "name": "no-regex-spaces",
        "url": "https://eslint.org/docs/latest/rules/no-regex-spaces",
        "description": "Disallow multiple spaces in regular expressionsRegular expressions can be very complex and difficult to understand, which is why it’s important to keep them as simple as possible in order to avoid mistakes. One of the more error-prone things you can do with a regular expression is to use more than one space, such as:In this regular expression, it’s very hard to tell how many spaces are intended to be matched. It’s better to use only one space and then specify how many spaces are expected, such as:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-regex-spaces: \"error\"*/\n\nvar re = /foo   bar/;\nvar re = new RegExp(\"foo   bar\");"
            },
            {
                "type": "correct",
                "content": "/*eslint no-regex-spaces: \"error\"*/\n\nvar re = /foo {3}bar/;\nvar re = new RegExp(\"foo {3}bar\");"
            }
        ]
    },
    {
        "name": "no-restricted-exports",
        "url": "https://eslint.org/docs/latest/rules/no-restricted-exports",
        "description": "Disallow specified names in exportsIn a project, certain names may be disallowed from being used as exported names for various reasons.This rule disallows specified names from being used as exported names.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-exports: [\"error\", {\n    \"restrictedNamedExports\": [\"foo\", \"bar\", \"Baz\", \"a\", \"b\", \"c\", \"d\", \"e\", \"👍\"]\n}]*/\n\nexport const foo = 1;\n\nexport function bar() {}\n\nexport class Baz {}\n\nconst a = {};\nexport { a };\n\nfunction someFunction() {}\nexport { someFunction as b };\n\nexport { c } from \"some_module\";\n\nexport { \"d\" } from \"some_module\";\n\nexport { something as e } from \"some_module\";\n\nexport { \"👍\" } from \"some_module\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-restricted-exports: [\"error\", {\n    \"restrictedNamedExports\": [\"foo\", \"bar\", \"Baz\", \"a\", \"b\", \"c\", \"d\", \"e\", \"👍\"]\n}]*/\n\nexport const quux = 1;\n\nexport function myFunction() {}\n\nexport class MyClass {}\n\nconst a = {};\nexport { a as myObject };\n\nfunction someFunction() {}\nexport { someFunction };\n\nexport { c as someName } from \"some_module\";\n\nexport { \"d\" as \" d \" } from \"some_module\";\n\nexport { something } from \"some_module\";\n\nexport { \"👍\" as thumbsUp } from \"some_module\";"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-exports: [\"error\", { \"restrictedNamedExports\": [\"default\"] }]*/\n\nfunction foo() {}\n\nexport { foo as default };"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-exports: [\"error\", { \"restrictedNamedExports\": [\"default\"] }]*/\n\nexport { default } from \"some_module\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-restricted-exports: [\"error\", { \"restrictedNamedExports\": [\"default\", \"foo\"] }]*/\n\nexport default function foo() {}"
            }
        ]
    },
    {
        "name": "no-restricted-globals",
        "url": "https://eslint.org/docs/latest/rules/no-restricted-globals",
        "description": "Disallow specified global variablesDisallowing usage of specific global variables can be useful if you want to allow a set of global variables by enabling an environment, but still want to disallow some of those.For instance, early Internet Explorer versions exposed the current DOM event as a global variable event, but using this variable has been considered as a bad practice for a long time. Restricting this will make sure this variable isn’t used in browser code.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*global event, fdescribe*/\n/*eslint no-restricted-globals: [\"error\", \"event\", \"fdescribe\"]*/\n\nfunction onClick() {\n    console.log(event);\n}\n\nfdescribe(\"foo\", function() {\n});"
            },
            {
                "type": "correct",
                "content": "/*global event*/\n/*eslint no-restricted-globals: [\"error\", \"event\"]*/\n\nimport event from \"event-module\";"
            },
            {
                "type": "correct",
                "content": "/*global event*/\n/*eslint no-restricted-globals: [\"error\", \"event\"]*/\n\nvar event = 1;"
            },
            {
                "type": "incorrect",
                "content": "/*global event*/\n/* eslint no-restricted-globals: [\"error\", { name: \"event\", message: \"Use local parameter instead.\" }] */\n\nfunction onClick() {\n    console.log(event);    // Unexpected global variable 'event'. Use local parameter instead.\n}"
            }
        ]
    },
    {
        "name": "no-restricted-imports",
        "url": "https://eslint.org/docs/latest/rules/no-restricted-imports",
        "description": "Disallow specified modules when loaded by importImports are an ES6/ES2015 standard for making the functionality of other modules available in your current module. In CommonJS this is implemented through the require() call which makes this ESLint rule roughly equivalent to its CommonJS counterpart no-restricted-modules.Why would you want to restrict imports?",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-imports: [\"error\", \"fs\"]*/\n\nimport fs from 'fs';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-imports: [\"error\", \"fs\"]*/\n\nexport { fs } from 'fs';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-imports: [\"error\", \"fs\"]*/\n\nexport * from 'fs';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-imports: [\"error\", { \"paths\": [\"cluster\"] }]*/\n\nimport cluster from 'cluster';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-imports: [\"error\", { \"patterns\": [\"lodash/*\"] }]*/\n\nimport pick from 'lodash/pick';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-imports: [\"error\", { paths: [{\n    name: \"foo\",\n    importNames: [\"default\"],\n    message: \"Please use the default import from '/bar/baz/' instead.\"\n}]}]*/\n\nimport DisallowedObject from \"foo\";"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-imports: [\"error\", { paths: [{\n    name: \"foo\",\n    importNames: [\"DisallowedObject\"],\n    message: \"Please import 'DisallowedObject' from '/bar/baz/' instead.\"\n}]}]*/\n\nimport { DisallowedObject } from \"foo\";\n\nimport { DisallowedObject as AllowedObject } from \"foo\";\n\nimport { \"DisallowedObject\" as AllowedObject } from \"foo\";"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-imports: [\"error\", { paths: [{\n    name: \"foo\",\n    importNames: [\"DisallowedObject\"],\n    message: \"Please import 'DisallowedObject' from '/bar/baz/' instead.\"\n}]}]*/\n\nimport * as Foo from \"foo\";"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-imports: [\"error\", { patterns: [{\n    group: [\"lodash/*\"],\n    message: \"Please use the default import from 'lodash' instead.\"\n}]}]*/\n\nimport pick from 'lodash/pick';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-imports: [\"error\", { patterns: [{\n    group: [\"foo[A-Z]*\"],\n    caseSensitive: true\n}]}]*/\n\nimport pick from 'fooBar';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-restricted-imports: [\"error\", { patterns: [{\n    group: [\"utils/*\"],\n    importNames: ['isEmpty'],\n    message: \"Use 'isEmpty' from lodash instead.\"\n}]}]*/\n\nimport { isEmpty } from 'utils/collection-utils';"
            },
            {
                "type": "correct",
                "content": "/*eslint no-restricted-imports: [\"error\", \"fs\"]*/\n\nimport crypto from 'crypto';\nexport { foo } from \"bar\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-restricted-imports: [\"error\", { \"paths\": [\"fs\"], \"patterns\": [\"eslint/*\"] }]*/\n\nimport crypto from 'crypto';\nimport eslint from 'eslint';\nexport * from \"path\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-restricted-imports: [\"error\", { paths: [{ name: \"foo\", importNames: [\"DisallowedObject\"] }] }]*/\n\nimport DisallowedObject from \"foo\""
            },
            {
                "type": "correct",
                "content": "/*eslint no-restricted-imports: [\"error\", { paths: [{\n    name: \"foo\",\n    importNames: [\"DisallowedObject\"],\n    message: \"Please import 'DisallowedObject' from '/bar/baz/' instead.\"\n}]}]*/\n\nimport { AllowedObject as DisallowedObject } from \"foo\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-restricted-imports: [\"error\", { patterns: [{\n    group: [\"lodash/*\"],\n    message: \"Please use the default import from 'lodash' instead.\"\n}]}]*/\n\nimport lodash from 'lodash';"
            },
            {
                "type": "correct",
                "content": "/*eslint no-restricted-imports: [\"error\", { patterns: [{\n    group: [\"foo[A-Z]*\"],\n    caseSensitive: true\n}]}]*/\n\nimport pick from 'food';"
            },
            {
                "type": "correct",
                "content": "/*eslint no-restricted-imports: [\"error\", { patterns: [{\n    group: [\"utils/*\"],\n    importNames: ['isEmpty'],\n    message: \"Use 'isEmpty' from lodash instead.\"\n}]}]*/\n\nimport { hasValues } from 'utils/collection-utils';"
            }
        ]
    },
    {
        "name": "no-restricted-properties",
        "url": "https://eslint.org/docs/latest/rules/no-restricted-properties",
        "description": "Disallow certain properties on certain objectsCertain properties on objects may be disallowed in a codebase. This is useful for deprecating an API or restricting usage of a module’s methods. For example, you may want to disallow using describe.only when using Mocha or telling people to use Object.assign instead of _.extend.This rule looks for accessing a given property key on a given object name, either when reading the property’s value or invoking it as a function. You may specify an optional message to indicate an alternative API or a reason for the restriction.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint no-restricted-properties: [2, {\n    \"object\": \"disallowedObjectName\",\n    \"property\": \"disallowedPropertyName\"\n}] */\n\nvar example = disallowedObjectName.disallowedPropertyName; /*error Disallowed object property: disallowedObjectName.disallowedPropertyName.*/\n\ndisallowedObjectName.disallowedPropertyName(); /*error Disallowed object property: disallowedObjectName.disallowedPropertyName.*/"
            },
            {
                "type": "incorrect",
                "content": "/* eslint no-restricted-properties: [2, {\n    \"property\": \"__defineGetter__\"\n}] */\n\nfoo.__defineGetter__(bar, baz);"
            },
            {
                "type": "incorrect",
                "content": "/* eslint no-restricted-properties: [2, {\n    \"object\": \"require\"\n}] */\n\nrequire.resolve('foo');"
            },
            {
                "type": "correct",
                "content": "/* eslint no-restricted-properties: [2, {\n    \"object\": \"disallowedObjectName\",\n    \"property\": \"disallowedPropertyName\"\n}] */\n\nvar example = disallowedObjectName.somePropertyName;\n\nallowedObjectName.disallowedPropertyName();"
            },
            {
                "type": "correct",
                "content": "/* eslint no-restricted-properties: [2, {\n    \"object\": \"require\"\n}] */\n\nrequire('foo');"
            }
        ]
    },
    {
        "name": "no-restricted-syntax",
        "url": "https://eslint.org/docs/latest/rules/no-restricted-syntax",
        "description": "Disallow specified syntaxJavaScript has a lot of language features, and not everyone likes all of them. As a result, some projects choose to disallow the use of certain language features altogether. For instance, you might decide to disallow the use of try-catch or class, or you might decide to disallow the use of the in operator.Rather than creating separate rules for every language feature you want to turn off, this rule allows you to configure the syntax elements you want to restrict use of. These elements are represented by their ESTree node types. For example, a function declaration is represented by FunctionDeclaration and the with statement is represented by WithStatement. You may find the full list of AST node names you can use on GitHub and use AST Explorer with the espree parser to see what type of nodes your code consists of.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint no-restricted-syntax: [\"error\", \"FunctionExpression\", \"WithStatement\", \"BinaryExpression[operator='in']\"] */\n\nwith (me) {\n    dontMess();\n}\n\nvar doSomething = function () {};\n\nfoo in bar;"
            },
            {
                "type": "correct",
                "content": "/* eslint no-restricted-syntax: [\"error\", \"FunctionExpression\", \"WithStatement\", \"BinaryExpression[operator='in']\"] */\n\nme.dontMess();\n\nfunction doSomething() {};\n\nfoo instanceof bar;"
            }
        ]
    },
    {
        "name": "no-return-assign",
        "url": "https://eslint.org/docs/latest/rules/no-return-assign",
        "description": "Disallow assignment operators in return statementsOne of the interesting, and sometimes confusing, aspects of JavaScript is that assignment can happen at almost any point. Because of this, an errant equals sign can end up causing assignment when the true intent was to do a comparison. This is especially true when using a return statement. For example:It is difficult to tell the intent of the return statement here. It’s possible that the function is meant to return the result of bar + 2, but then why is it assigning to foo? It’s also possible that the intent was to use a comparison operator such as == and that this code is an error.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-return-assign: \"error\"*/\n\nfunction doSomething() {\n    return foo = bar + 2;\n}\n\nfunction doSomething() {\n    return foo += 2;\n}\n\nconst foo = (a, b) => a = b\n\nconst bar = (a, b, c) => (a = b, c == b)\n\nfunction doSomething() {\n    return foo = bar && foo > 0;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-return-assign: \"error\"*/\n\nfunction doSomething() {\n    return foo == bar + 2;\n}\n\nfunction doSomething() {\n    return foo === bar + 2;\n}\n\nfunction doSomething() {\n    return (foo = bar + 2);\n}\n\nconst foo = (a, b) => (a = b)\n\nconst bar = (a, b, c) => ((a = b), c == b)\n\nfunction doSomething() {\n    return (foo = bar) && foo > 0;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-return-assign: [\"error\", \"always\"]*/\n\nfunction doSomething() {\n    return foo = bar + 2;\n}\n\nfunction doSomething() {\n    return foo += 2;\n}\n\nfunction doSomething() {\n    return (foo = bar + 2);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-return-assign: [\"error\", \"always\"]*/\n\nfunction doSomething() {\n    return foo == bar + 2;\n}\n\nfunction doSomething() {\n    return foo === bar + 2;\n}"
            }
        ]
    },
    {
        "name": "no-return-await",
        "url": "https://eslint.org/docs/latest/rules/no-return-await",
        "description": "Disallow unnecessary return awaitUsing return await inside an async function keeps the current function in the call stack until the Promise that is being awaited has resolved, at the cost of an extra microtask before resolving the outer Promise. return await can also be used in a try/catch statement to catch errors from another function that returns a Promise.You can avoid the extra microtask by not awaiting the return value, with the trade off of the function no longer being a part of the stack trace if an error is thrown asynchronously from the Promise being returned. This can make debugging more difficult.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-return-await: \"error\"*/\n\nasync function foo() {\n    return await bar();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-return-await: \"error\"*/\n\nasync function foo() {\n    return bar();\n}\n\nasync function foo() {\n    await bar();\n    return;\n}\n\n// This is essentially the same as `return await bar();`, but the rule checks only `await` in `return` statements\nasync function foo() {\n    const x = await bar();\n    return x;\n}\n\n// In this example the `await` is necessary to be able to catch errors thrown from `bar()`\nasync function foo() {\n    try {\n        return await bar();\n    } catch (error) {}\n}"
            }
        ]
    },
    {
        "name": "no-script-url",
        "url": "https://eslint.org/docs/latest/rules/no-script-url",
        "description": "Disallow javascript: urlsUsing javascript: URLs is considered by some as a form of eval. Code passed in javascript: URLs has to be parsed and evaluated by the browser in the same way that eval is processed.Examples of incorrect code for this rule:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-script-url: \"error\"*/\n\nlocation.href = \"javascript:void(0)\";\n\nlocation.href = `javascript:void(0)`;"
            }
        ]
    },
    {
        "name": "no-sequences",
        "url": "https://eslint.org/docs/latest/rules/no-sequences",
        "description": "Disallow comma operatorsThe comma operator includes multiple expressions where only one is expected. It evaluates each operand from left to right and returns the value of the last operand. However, this frequently obscures side effects, and its use is often an accident. Here are some examples of sequences:This rule forbids the use of the comma operator, with the following exceptions:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-sequences: \"error\"*/\n\nfoo = doSomething(), val;\n\n0, eval(\"doSomething();\");\n\ndo {} while (doSomething(), !!test);\n\nfor (; doSomething(), !!test; );\n\nif (doSomething(), !!test);\n\nswitch (val = foo(), val) {}\n\nwhile (val = foo(), val < 42);\n\nwith (doSomething(), val) {}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-sequences: \"error\"*/\n\nfoo = (doSomething(), val);\n\n(0, eval)(\"doSomething();\");\n\ndo {} while ((doSomething(), !!test));\n\nfor (i = 0, j = 10; i < j; i++, j--);\n\nif ((doSomething(), !!test));\n\nswitch ((val = foo(), val)) {}\n\nwhile ((val = foo(), val < 42));\n\nwith ((doSomething(), val)) {}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-sequences: \"error\"*/\nconst foo = (val) => (console.log('bar'), val);\n\nconst foo = () => ((bar = 123), 10);\n\nconst foo = () => { return (bar = 123), 10 }"
            },
            {
                "type": "correct",
                "content": "/*eslint no-sequences: \"error\"*/\nconst foo = (val) => ((console.log('bar'), val));\n\nconst foo = () => (((bar = 123), 10));\n\nconst foo = () => { return ((bar = 123), 10) }"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-sequences: [\"error\", { \"allowInParentheses\": false }]*/\n\nfoo = (doSomething(), val);\n\n(0, eval)(\"doSomething();\");\n\ndo {} while ((doSomething(), !!test));\n\nfor (; (doSomething(), !!test); );\n\nif ((doSomething(), !!test));\n\nswitch ((val = foo(), val)) {}\n\nwhile ((val = foo(), val < 42));\n\nwith ((doSomething(), val)) {}\n\nconst foo = (val) => ((console.log('bar'), val));"
            },
            {
                "type": "correct",
                "content": "/*eslint no-sequences: [\"error\", { \"allowInParentheses\": false }]*/\n\nfor (i = 0, j = 10; i < j; i++, j--);"
            }
        ]
    },
    {
        "name": "no-shadow",
        "url": "https://eslint.org/docs/latest/rules/no-shadow",
        "description": "Disallow variable declarations from shadowing variables declared in the outer scopeShadowing is the process by which a local variable shares the same name as a variable in its containing scope. For example:In this case, the variable a inside of b() is shadowing the variable a in the global scope. This can cause confusion while reading the code and it’s impossible to access the global variable.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-shadow: \"error\"*/\n/*eslint-env es6*/\n\nvar a = 3;\nfunction b() {\n    var a = 10;\n}\n\nvar b = function () {\n    var a = 10;\n}\n\nfunction b(a) {\n    a = 10;\n}\nb(a);\n\nif (true) {\n    let a = 5;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-shadow: [\"error\", { \"builtinGlobals\": true }]*/\n\nfunction foo() {\n    var Object = 0;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-shadow: [\"error\", { \"hoist\": \"functions\" }]*/\n/*eslint-env es6*/\n\nif (true) {\n    let b = 6;\n}\n\nfunction b() {}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-shadow: [\"error\", { \"hoist\": \"functions\" }]*/\n/*eslint-env es6*/\n\nif (true) {\n    let a = 3;\n}\n\nlet a = 5;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-shadow: [\"error\", { \"hoist\": \"all\" }]*/\n/*eslint-env es6*/\n\nif (true) {\n    let a = 3;\n    let b = 6;\n}\n\nlet a = 5;\nfunction b() {}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-shadow: [\"error\", { \"hoist\": \"never\" }]*/\n/*eslint-env es6*/\n\nif (true) {\n    let a = 3;\n    let b = 6;\n}\n\nlet a = 5;\nfunction b() {}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-shadow: [\"error\", { \"allow\": [\"done\"] }]*/\n/*eslint-env es6*/\n\nimport async from 'async';\n\nfunction foo(done) {\n  async.map([1, 2], function (e, done) {\n    done(null, e * 2)\n  }, done);\n}\n\nfoo(function (err, result) {\n  console.log({ err, result });\n});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-shadow: [\"error\", { \"ignoreOnInitialization\": true }]*/\n\nvar x = x => x;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-shadow: [\"error\", { \"ignoreOnInitialization\": true }]*/\n\nvar x = foo(x => x)\n\nvar y = (y => y)()"
            }
        ]
    },
    {
        "name": "no-shadow-restricted-names",
        "url": "https://eslint.org/docs/latest/rules/no-shadow-restricted-names",
        "description": "Disallow identifiers from shadowing restricted namesES5 §15.1.1 Value Properties of the Global Object (NaN, Infinity, undefined) as well as strict mode restricted identifiers eval and arguments are considered to be restricted names in JavaScript. Defining them to mean something else can have unintended consequences and confuse others reading the code. For example, there’s nothing preventing you from writing:Then any code used within the same scope would not get the global undefined, but rather the local version with a very different meaning.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-shadow-restricted-names: \"error\"*/\n\nfunction NaN(){}\n\n!function(Infinity){};\n\nvar undefined = 5;\n\ntry {} catch(eval){}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-shadow-restricted-names: \"error\"*/\n\nvar Object;\n\nfunction f(a, b){}\n\n// Exception: `undefined` may be shadowed if the variable is never assigned a value.\nvar undefined;"
            }
        ]
    },
    {
        "name": "no-ternary",
        "url": "https://eslint.org/docs/latest/rules/no-ternary",
        "description": "Disallow ternary operatorsThe ternary operator is used to conditionally assign a value to a variable. Some believe that the use of ternary operators leads to unclear code.This rule disallows ternary operators.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-ternary: \"error\"*/\n\nvar foo = isBar ? baz : qux;\n\nfunction quux() {\n  return foo ? bar() : baz();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-ternary: \"error\"*/\n\nvar foo;\n\nif (isBar) {\n    foo = baz;\n} else {\n    foo = qux;\n}\n\nfunction quux() {\n    if (foo) {\n        return bar();\n    } else {\n        return baz();\n    }\n}"
            }
        ]
    },
    {
        "name": "no-throw-literal",
        "url": "https://eslint.org/docs/latest/rules/no-throw-literal",
        "description": "Disallow throwing literals as exceptionsIt is considered good practice to only throw the Error object itself or an object using the Error object as base objects for user-defined exceptions. The fundamental benefit of Error objects is that they automatically keep track of where they were built and originated.This rule restricts what can be thrown as an exception. When it was first created, it only prevented literals from being thrown (hence the name), but it has now been expanded to only allow expressions which have a possibility of being an Error object.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-throw-literal: \"error\"*/\n/*eslint-env es6*/\n\nthrow \"error\";\n\nthrow 0;\n\nthrow undefined;\n\nthrow null;\n\nvar err = new Error();\nthrow \"an \" + err;\n// err is recast to a string literal\n\nvar err = new Error();\nthrow `${err}`\n"
            },
            {
                "type": "correct",
                "content": "/*eslint no-throw-literal: \"error\"*/\n\nthrow new Error();\n\nthrow new Error(\"error\");\n\nvar e = new Error(\"error\");\nthrow e;\n\ntry {\n    throw new Error(\"error\");\n} catch (e) {\n    throw e;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-throw-literal: \"error\"*/\n\nvar err = \"error\";\nthrow err;\n\nfunction foo(bar) {\n    console.log(bar);\n}\nthrow foo(\"error\");\n\nthrow new String(\"error\");\n\nvar foo = {\n    bar: \"error\"\n};\nthrow foo.bar;"
            }
        ]
    },
    {
        "name": "no-undef-init",
        "url": "https://eslint.org/docs/latest/rules/no-undef-init",
        "description": "Disallow initializing variables to undefinedIn JavaScript, a variable that is declared and not initialized to any value automatically gets the value of undefined. For example:It’s therefore unnecessary to initialize a variable to undefined, such as:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-undef-init: \"error\"*/\n\nvar foo = undefined;\nlet bar = undefined;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-undef-init: \"error\"*/\n\nvar foo;\nlet bar;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-undef-init: \"error\"*/\n\nconst foo = undefined;\n\nlet { bar = undefined } = baz;\n\n[quux = undefined] = quuux;\n\n(foo = undefined) => {};\n\nclass Foo {\n    bar = undefined;\n}"
            },
            {
                "type": "incorrect",
                "content": "for (i = 0; i < 10; i++) {\n    var x = undefined;\n    console.log(x);\n    x = i;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-undef-init: \"error\"*/\n\nfor (i = 0; i < 10; i++) {\n    var x = undefined; // eslint-disable-line no-undef-init\n    console.log(x);\n    x = i;\n}"
            }
        ]
    },
    {
        "name": "no-undefined",
        "url": "https://eslint.org/docs/latest/rules/no-undefined",
        "description": "Disallow the use of undefined as an identifierThe undefined variable in JavaScript is actually a property of the global object. As such, in ECMAScript 3 it was possible to overwrite the value of undefined. While ECMAScript 5 disallows overwriting undefined, it’s still possible to shadow undefined, such as:Because undefined can be overwritten or shadowed, reading undefined can give an unexpected value. (This is not the case for null, which is a keyword that always produces the same value.) To guard against this, you can avoid all uses of undefined, which is what some style guides recommend and what this rule enforces. Those style guides then also recommend:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-undefined: \"error\"*/\n\nvar foo = undefined;\n\nvar undefined = \"foo\";\n\nif (foo === undefined) {\n    // ...\n}\n\nfunction foo(undefined) {\n    // ...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-undefined: \"error\"*/\n\nvar foo = void 0;\n\nvar Undefined = \"foo\";\n\nif (typeof foo === \"undefined\") {\n    // ...\n}\n\nglobal.undefined = \"foo\";"
            }
        ]
    },
    {
        "name": "no-underscore-dangle",
        "url": "https://eslint.org/docs/latest/rules/no-underscore-dangle",
        "description": "Disallow dangling underscores in identifiersAs far as naming conventions for identifiers go, dangling underscores may be the most polarizing in JavaScript. Dangling underscores are underscores at either the beginning or end of an identifier, such as:There is actually a long history of using dangling underscores to indicate “private” members of objects in JavaScript (though JavaScript doesn’t have truly private members, this convention served as a warning). This began with SpiderMonkey adding nonstandard methods such as __defineGetter__(). The intent with the underscores was to make it obvious that this method was special in some way. Since that time, using a single underscore prefix has become popular as a way to indicate “private” members of objects.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-underscore-dangle: \"error\"*/\n\nvar foo_;\nvar __proto__ = {};\nfoo._bar();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-underscore-dangle: \"error\"*/\n\nvar _ = require('underscore');\nvar obj = _.contains(items, item);\nobj.__proto__ = {};\nvar file = __filename;\nfunction foo(_bar) {};\nconst foo = { onClick(_bar) {} };\nconst foo = (_bar) => {};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-underscore-dangle: [\"error\", { \"allow\": [\"foo_\", \"_bar\"] }]*/\n\nvar foo_;\nfoo._bar();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-underscore-dangle: [\"error\", { \"allowAfterThis\": true }]*/\n\nvar a = this.foo_;\nthis._bar();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-underscore-dangle: [\"error\", { \"allowAfterSuper\": true }]*/\n\nvar a = super.foo_;\nsuper._bar();"
            },
            {
                "type": "correct",
                "content": "/*eslint no-underscore-dangle: [\"error\", { \"allowAfterThisConstructor\": true }]*/\n\nvar a = this.constructor.foo_;\nthis.constructor._bar();"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-underscore-dangle: [\"error\", { \"enforceInMethodNames\": true }]*/\n\nclass Foo {\n  _bar() {}\n}\n\nclass Foo {\n  bar_() {}\n}\n\nconst o = {\n  _bar() {}\n};\n\nconst o = {\n  bar_() = {}\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-underscore-dangle: [\"error\", { \"enforceInClassFields\": true }]*/\n\nclass Foo {\n    _bar;\n}\n\nclass Foo {\n    _bar = () => {};\n}\n\nclass Foo {\n    bar_;\n}\n\nclass Foo {\n    #_bar;\n}\n\nclass Foo {\n    #bar_;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-underscore-dangle: [\"error\", { \"allowFunctionParams\": false }]*/\n\nfunction foo (_bar) {}\nfunction foo (_bar = 0) {}\nfunction foo (..._bar) {}\n\nconst foo = function onClick (_bar) {}\nconst foo = function onClick (_bar = 0) {}\nconst foo = function onClick (..._bar) {}\n\nconst foo = (_bar) => {};\nconst foo = (_bar = 0) => {};\nconst foo = (..._bar) => {};"
            }
        ]
    },
    {
        "name": "no-unneeded-ternary",
        "url": "https://eslint.org/docs/latest/rules/no-unneeded-ternary",
        "description": "Disallow ternary operators when simpler alternatives existIt’s a common mistake in JavaScript to use a conditional expression to select between two Boolean values instead of using ! to convert the test to a Boolean. Here are some examples:Another common mistake is using a single variable as both the conditional test and the consequent. In such cases, the logical OR can be used to provide the same functionality. Here is an example:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unneeded-ternary: \"error\"*/\n\nvar a = x === 2 ? true : false;\n\nvar a = x ? true : false;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unneeded-ternary: \"error\"*/\n\nvar a = x === 2 ? \"Yes\" : \"No\";\n\nvar a = x !== false;\n\nvar a = x ? \"Yes\" : \"No\";\n\nvar a = x ? y : x;\n\nf(x ? x : 1); // default assignment - would be disallowed if defaultAssignment option set to false. See option details below."
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unneeded-ternary: [\"error\", { \"defaultAssignment\": false }]*/\n\nvar a = x ? x : 1;\n\nf(x ? x : 1);"
            }
        ]
    },
    {
        "name": "no-unused-expressions",
        "url": "https://eslint.org/docs/latest/rules/no-unused-expressions",
        "description": "Disallow unused expressionsAn unused expression which has no effect on the state of the program indicates a logic error.For example, n + 1; is not a syntax error, but it might be a typing mistake where a programmer meant an assignment statement n += 1; instead. Sometimes, such unused expressions may be eliminated by some build tools in production environment, which possibly breaks application logic.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-expressions: \"error\"*/\n\n0\n\nif(0) 0\n\n{0}\n\nf(0), {}\n\na && b()\n\na, b()\n\nc = a, b;\n\na() && function namedFunctionInExpressionContext () {f();}\n\n(function anIncompleteIIFE () {});\n\ninjectGlobal`body{ color: red; }`\n"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-expressions: \"error\"*/\n\n{} // In this context, this is a block statement, not an object literal\n\n{myLabel: someVar} // In this context, this is a block statement with a label and expression, not an object literal\n\nfunction namedFunctionDeclaration () {}\n\n(function aGenuineIIFE () {}());\n\nf()\n\na = 0\n\nnew C\n\ndelete a.b\n\nvoid a"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-expressions: \"error\"*/\n\n\"use strict\";\n\"use asm\"\n\"use stricter\";\n\"use babel\"\n\"any other strings like this in the directive prologue\";\n\"this is still the directive prologue\";\n\nfunction foo() {\n    \"bar\";\n}\n\nclass Foo {\n    someMethod() {\n        \"use strict\";\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-expressions: \"error\"*/\n\ndoSomething();\n\"use strict\"; // this isn't in a directive prologue, because there is a non-directive statement before it\n\nfunction foo() {\n    \"bar\" + 1;\n}\n\nclass Foo {\n    static {\n        \"use strict\"; // class static blocks do not have directive prologues\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true }]*/\n\na || b"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true }]*/\n\na && b()\na() || (b = c)"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-expressions: [\"error\", { \"allowTernary\": true }]*/\n\na ? b : 0\na ? b : c()"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-expressions: [\"error\", { \"allowTernary\": true }]*/\n\na ? b() : c()\na ? (b = c) : d()"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true, \"allowTernary\": true }]*/\n\na ? b() || (c = d) : e()"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-expressions: [\"error\", { \"allowTaggedTemplates\": true }]*/\n\n`some untagged template string`;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-expressions: [\"error\", { \"allowTaggedTemplates\": true }]*/\n\ntag`some tagged template string`;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-expressions: [\"error\", { \"enforceForJSX\": true }]*/\n\n<MyComponent />;\n\n<></>;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-expressions: [\"error\", { \"enforceForJSX\": true }]*/\n\nvar myComponentPartial = <MyComponent />;\n\nvar myFragment = <></>;"
            }
        ]
    },
    {
        "name": "no-unused-labels",
        "url": "https://eslint.org/docs/latest/rules/no-unused-labels",
        "description": "Disallow unused labelsLabels that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring.In this case, probably removing OUTER_LOOP: had been forgotten. Such labels take up space in the code and can lead to confusion by readers.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-unused-labels: \"error\"*/\n\nA: var foo = 0;\n\nB: {\n    foo();\n}\n\nC:\nfor (let i = 0; i < 10; ++i) {\n    foo();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-unused-labels: \"error\"*/\n\nA: {\n    if (foo()) {\n        break A;\n    }\n    bar();\n}\n\nB:\nfor (let i = 0; i < 10; ++i) {\n    if (foo()) {\n        break B;\n    }\n    bar();\n}"
            }
        ]
    },
    {
        "name": "no-useless-call",
        "url": "https://eslint.org/docs/latest/rules/no-useless-call",
        "description": "Disallow unnecessary calls to .call() and .apply()The function invocation can be written by Function.prototype.call() and Function.prototype.apply(). But Function.prototype.call() and Function.prototype.apply() are slower than the normal function invocation.This rule is aimed to flag usage of Function.prototype.call() and Function.prototype.apply() that can be replaced with the normal function invocation.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-useless-call: \"error\"*/\n\n// These are same as `foo(1, 2, 3);`\nfoo.call(undefined, 1, 2, 3);\nfoo.apply(undefined, [1, 2, 3]);\nfoo.call(null, 1, 2, 3);\nfoo.apply(null, [1, 2, 3]);\n\n// These are same as `obj.foo(1, 2, 3);`\nobj.foo.call(obj, 1, 2, 3);\nobj.foo.apply(obj, [1, 2, 3]);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-call: \"error\"*/\n\n// The `this` binding is different.\nfoo.call(obj, 1, 2, 3);\nfoo.apply(obj, [1, 2, 3]);\nobj.foo.call(null, 1, 2, 3);\nobj.foo.apply(null, [1, 2, 3]);\nobj.foo.call(otherObj, 1, 2, 3);\nobj.foo.apply(otherObj, [1, 2, 3]);\n\n// The argument list is variadic.\n// Those are warned by the `prefer-spread` rule.\nfoo.apply(undefined, args);\nfoo.apply(null, args);\nobj.foo.apply(obj, args);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-useless-call: \"error\"*/\n\na[i++].foo.call(a[i++], 1, 2, 3);"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-call: \"error\"*/\n\na[++i].foo.call(a[i], 1, 2, 3);"
            }
        ]
    },
    {
        "name": "no-useless-catch",
        "url": "https://eslint.org/docs/latest/rules/no-useless-catch",
        "description": "Disallow unnecessary catch clausesA catch clause that only rethrows the original error is redundant, and has no effect on the runtime behavior of the program. These redundant clauses can be a source of confusion and code bloat, so it’s better to disallow these unnecessary catch clauses.This rule reports catch clauses that only throw the caught error.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-useless-catch: \"error\"*/\n\ntry {\n  doSomethingThatMightThrow();\n} catch (e) {\n  throw e;\n}\n\ntry {\n  doSomethingThatMightThrow();\n} catch (e) {\n  throw e;\n} finally {\n  cleanUp();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-catch: \"error\"*/\n\ntry {\n  doSomethingThatMightThrow();\n} catch (e) {\n  doSomethingBeforeRethrow();\n  throw e;\n}\n\ntry {\n  doSomethingThatMightThrow();\n} catch (e) {\n  handleError(e);\n}\n\ntry {\n  doSomethingThatMightThrow();\n} finally {\n  cleanUp();\n}"
            }
        ]
    },
    {
        "name": "no-useless-computed-key",
        "url": "https://eslint.org/docs/latest/rules/no-useless-computed-key",
        "description": "Disallow unnecessary computed property keys in objects and classesIt’s unnecessary to use computed properties with literals such as:The code can be rewritten as:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-useless-computed-key: \"error\"*/\n\nvar a = { ['0']: 0 };\nvar a = { ['0+1,234']: 0 };\nvar a = { [0]: 0 };\nvar a = { ['x']: 0 };\nvar a = { ['x']() {} };"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-computed-key: \"error\"*/\n\nvar c = { 'a': 0 };\nvar c = { 0: 0 };\nvar a = { x() {} };\nvar c = { a: 0 };\nvar c = { '0+1,234': 0 };"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-computed-key: \"error\"*/\n\nvar c = {\n    \"__proto__\": foo, // defines object's prototype\n\n    [\"__proto__\"]: bar // defines a property named \"__proto__\"\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-useless-computed-key: [\"error\", { \"enforceForClassMembers\": true }]*/\n\nclass Foo {\n    [\"foo\"] = \"bar\";\n\n    [0]() {}\n    ['a']() {}\n    get ['b']() {}\n    set ['c'](value) {}\n\n    static [\"foo\"] = \"bar\";\n\n    static ['a']() {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-computed-key: [\"error\", { \"enforceForClassMembers\": true }]*/\n\nclass Foo {\n    \"foo\" = \"bar\";\n\n    0() {}\n    'a'() {}\n    get 'b'() {}\n    set 'c'(value) {}\n\n    static \"foo\" = \"bar\";\n\n    static 'a'() {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-computed-key: [\"error\", { \"enforceForClassMembers\": true }]*/\n\nclass Foo {\n    [\"constructor\"]; // instance field named \"constructor\"\n\n    \"constructor\"() {} // the constructor of this class\n\n    [\"constructor\"]() {} // method named \"constructor\"\n\n    static [\"constructor\"]; // static field named \"constructor\"\n\n    static [\"prototype\"]; // runtime error, it would be a parsing error without `[]`\n}"
            }
        ]
    },
    {
        "name": "no-useless-concat",
        "url": "https://eslint.org/docs/latest/rules/no-useless-concat",
        "description": "Disallow unnecessary concatenation of literals or template literalsIt’s unnecessary to concatenate two strings together, such as:This code is likely the result of refactoring where a variable was removed from the concatenation (such as \"a\" + b + \"b\"). In such a case, the concatenation isn’t important and the code can be rewritten as:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-useless-concat: \"error\"*/\n/*eslint-env es6*/\n\nvar a = `some` + `string`;\n\n// these are the same as \"10\"\nvar a = '1' + '0';\nvar a = '1' + `0`;\nvar a = `1` + '0';\nvar a = `1` + `0`;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-concat: \"error\"*/\n\n// when a non string is included\nvar c = a + b;\nvar c = '1' + a;\nvar a = 1 + '1';\nvar c = 1 - 2;\n// when the string concatenation is multiline\nvar c = \"foo\" +\n    \"bar\";"
            }
        ]
    },
    {
        "name": "no-useless-constructor",
        "url": "https://eslint.org/docs/latest/rules/no-useless-constructor",
        "description": "Disallow unnecessary constructorsES2015 provides a default class constructor if one is not specified. As such, it is unnecessary to provide an empty constructor or one that simply delegates into its parent class, as in the following examples:This rule flags class constructors that can be safely removed without changing how the class works.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-useless-constructor: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    constructor () {\n    }\n}\n\nclass B extends A {\n    constructor (...args) {\n      super(...args);\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-constructor: \"error\"*/\n\nclass A { }\n\nclass A {\n    constructor () {\n        doSomething();\n    }\n}\n\nclass B extends A {\n    constructor() {\n        super('foo');\n    }\n}\n\nclass B extends A {\n    constructor() {\n        super();\n        doSomething();\n    }\n}"
            }
        ]
    },
    {
        "name": "no-useless-escape",
        "url": "https://eslint.org/docs/latest/rules/no-useless-escape",
        "description": "Disallow unnecessary escape charactersEscaping non-special characters in strings, template literals, and regular expressions doesn’t have any effect, as demonstrated in the following example:This rule flags escapes that can be safely removed without changing behavior.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-useless-escape: \"error\"*/\n\n\"\\'\";\n'\\\"';\n\"\\#\";\n\"\\e\";\n`\\\"`;\n`\\\"${foo}\\\"`;\n`\\#{foo}`;\n/\\!/;\n/\\@/;\n/[\\[]/;\n/[a-z\\-]/;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-escape: \"error\"*/\n\n\"\\\"\";\n'\\'';\n\"\\x12\";\n\"\\u00a9\";\n\"\\371\";\n\"xs\\u2111\";\n`\\``;\n`\\${${foo}}`;\n`$\\{${foo}}`;\n/\\\\/g;\n/\\t/g;\n/\\w\\$\\*\\^\\./;\n/[[]/;\n/[\\]]/;\n/[a-z-]/;"
            }
        ]
    },
    {
        "name": "no-useless-rename",
        "url": "https://eslint.org/docs/latest/rules/no-useless-rename",
        "description": "Disallow renaming import, export, and destructured assignments to the same nameES2015 allows for the renaming of references in import and export statements as well as destructuring assignments. This gives programmers a concise syntax for performing these operations while renaming these references:With this syntax, it is possible to rename a reference to the same name. This is a completely redundant operation, as this is the same as not renaming at all. For example, this:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-useless-rename: \"error\"*/\n\nimport { foo as foo } from \"bar\";\nimport { \"foo\" as foo } from \"bar\";\nexport { foo as foo };\nexport { foo as \"foo\" };\nexport { foo as foo } from \"bar\";\nexport { \"foo\" as \"foo\" } from \"bar\";\nlet { foo: foo } = bar;\nlet { 'foo': foo } = bar;\nfunction foo({ bar: bar }) {}\n({ foo: foo }) => {}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-rename: \"error\"*/\n\nimport * as foo from \"foo\";\nimport { foo } from \"bar\";\nimport { foo as bar } from \"baz\";\nimport { \"foo\" as bar } from \"baz\";\n\nexport { foo };\nexport { foo as bar };\nexport { foo as \"bar\" };\nexport { foo as bar } from \"foo\";\nexport { \"foo\" as \"bar\" } from \"foo\";\n\nlet { foo } = bar;\nlet { foo: bar } = baz;\nlet { [foo]: foo } = bar;\n\nfunction foo({ bar }) {}\nfunction foo({ bar: baz }) {}\n\n({ foo }) => {}\n({ foo: bar }) => {}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-rename: [\"error\", { ignoreImport: true }]*/\n\nimport { foo as foo } from \"bar\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-rename: [\"error\", { ignoreExport: true }]*/\n\nexport { foo as foo };\nexport { foo as foo } from \"bar\";"
            },
            {
                "type": "correct",
                "content": "/*eslint no-useless-rename: [\"error\", { ignoreDestructuring: true }]*/\n\nlet { foo: foo } = bar;\nfunction foo({ bar: bar }) {}\n({ foo: foo }) => {}"
            }
        ]
    },
    {
        "name": "no-useless-return",
        "url": "https://eslint.org/docs/latest/rules/no-useless-return",
        "description": "Disallow redundant return statementsA return; statement with nothing after it is redundant, and has no effect on the runtime behavior of a function. This can be confusing, so it’s better to disallow these redundant statements.This rule aims to report redundant return statements.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint no-useless-return: \"error\" */\n\nfunction foo() { return; }\n\nfunction foo() {\n  doSomething();\n  return;\n}\n\nfunction foo() {\n  if (condition) {\n    bar();\n    return;\n  } else {\n    baz();\n  }\n}\n\nfunction foo() {\n  switch (bar) {\n    case 1:\n      doSomething();\n    default:\n      doSomethingElse();\n      return;\n  }\n}\n"
            },
            {
                "type": "correct",
                "content": "/* eslint no-useless-return: \"error\" */\n\nfunction foo() { return 5; }\n\nfunction foo() {\n  return doSomething();\n}\n\nfunction foo() {\n  if (condition) {\n    bar();\n    return;\n  } else {\n    baz();\n  }\n  qux();\n}\n\nfunction foo() {\n  switch (bar) {\n    case 1:\n      doSomething();\n      return;\n    default:\n      doSomethingElse();\n  }\n}\n\nfunction foo() {\n  for (const foo of bar) {\n    return;\n  }\n}\n"
            }
        ]
    },
    {
        "name": "no-var",
        "url": "https://eslint.org/docs/latest/rules/no-var",
        "description": "Require let or const instead of varECMAScript 6 allows programmers to create variables with block scope instead of function scope using the let and const keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes such as:This rule is aimed at discouraging the use of var and encouraging the use of const or let instead.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};"
            }
        ]
    },
    {
        "name": "no-void",
        "url": "https://eslint.org/docs/latest/rules/no-void",
        "description": "Disallow void operatorsThe void operator takes an operand and returns undefined: void expression will evaluate expression and return undefined. It can be used to ignore any side effects expression may produce:The common case of using void operator is to get a “pure” undefined value as prior to ES5 the undefined variable was mutable:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-void: \"error\"*/\n\nvoid foo\nvoid someFunction();\n\nvar foo = void bar();\nfunction baz() {\n    return void 0;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-void: [\"error\", { \"allowAsStatement\": true }]*/\n\nvar foo = void bar();\nfunction baz() {\n    return void 0;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-void: [\"error\", { \"allowAsStatement\": true }]*/\n\nvoid foo;\nvoid someFunction();"
            }
        ]
    },
    {
        "name": "no-warning-comments",
        "url": "https://eslint.org/docs/latest/rules/no-warning-comments",
        "description": "Disallow specified warning terms in commentsDevelopers often add comments to code which is not complete or needs review. Most likely you want to fix or review the code, and then remove the comment, before you consider the code to be production ready.This rule reports comments that include any of the predefined terms specified in its configuration.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-warning-comments: \"error\"*/\n\n/*\nFIXME\n*/\nfunction callback(err, results) {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  // TODO\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-warning-comments: \"error\"*/\n\nfunction callback(err, results) {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  // NOT READY FOR PRIME TIME\n  // but too bad, it is not a predefined warning term\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-warning-comments: [\"error\", { \"terms\": [\"todo\", \"fixme\", \"any other term\"], \"location\": \"anywhere\" }]*/\n\n// TODO: this\n// todo: this too\n// Even this: TODO\n/*\n * The same goes for this TODO comment\n * Or a fixme\n * as well as any other term\n */"
            },
            {
                "type": "correct",
                "content": "/*eslint no-warning-comments: [\"error\", { \"terms\": [\"todo\", \"fixme\", \"any other term\"], \"location\": \"anywhere\" }]*/\n\n// This is to do\n// even not any other    term\n// any other terminal\n/*\n * The same goes for block comments\n * with any other interesting term\n * or fix me this\n */"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-warning-comments: [\"error\", { \"decoration\": [\"*\"] }]*/\n\n//***** todo decorative asterisks are ignored *****//\n/**\n * TODO new lines and asterisks are also ignored in block comments.\n */"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-warning-comments: [\"error\", { \"decoration\": [\"/\", \"*\"] }]*/\n\n////// TODO decorative slashes and whitespace are ignored //////\n//***** todo decorative asterisks are also ignored *****//\n/**\n * TODO new lines are also ignored in block comments.\n */"
            },
            {
                "type": "correct",
                "content": "/*eslint no-warning-comments: [\"error\", { \"decoration\": [\"/\", \"*\"] }]*/\n\n//!TODO preceded by non-decoration character\n/**\n *!TODO preceded by non-decoration character in a block comment\n */"
            }
        ]
    },
    {
        "name": "no-with",
        "url": "https://eslint.org/docs/latest/rules/no-with",
        "description": "Disallow with statementsThe with statement is potentially problematic because it adds members of an object to the current scope, making it impossible to tell what a variable inside the block actually refers to.This rule disallows with statements.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-with: \"error\"*/\n\nwith (point) {\n    r = Math.sqrt(x * x + y * y); // is r a member of point?\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-with: \"error\"*/\n/*eslint-env es6*/\n\nconst r = ({x, y}) => Math.sqrt(x * x + y * y);"
            }
        ]
    },
    {
        "name": "object-shorthand",
        "url": "https://eslint.org/docs/latest/rules/object-shorthand",
        "description": "Require or disallow method and property shorthand syntax for object literalsECMAScript 6 provides a concise form for defining object literal methods and properties. This syntax can make defining complex object literals much cleaner.Here are a few common examples using the ES5 syntax:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint object-shorthand: [\"error\", \"always\", { \"avoidQuotes\": true }]*/\n/*eslint-env es6*/\n\nvar foo = {\n    \"bar-baz\"() {}\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint object-shorthand: [\"error\", \"always\", { \"avoidQuotes\": true }]*/\n/*eslint-env es6*/\n\nvar foo = {\n    \"bar-baz\": function() {},\n    \"qux\": qux\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint object-shorthand: [\"error\", \"always\", { \"ignoreConstructors\": true }]*/\n/*eslint-env es6*/\n\nvar foo = {\n    ConstructorFunction: function() {}\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint object-shorthand: [\"error\", \"always\", { \"methodsIgnorePattern\": \"^bar$\" }]*/\n\nvar foo = {\n    bar: function() {}\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint object-shorthand: [\"error\", \"always\", { \"avoidExplicitReturnArrows\": true }]*/\n/*eslint-env es6*/\n\nvar foo = {\n  foo: (bar, baz) => {\n    return bar + baz;\n  },\n\n  qux: (foobar) => {\n    return foobar * 2;\n  }\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint object-shorthand: [\"error\", \"always\", { \"avoidExplicitReturnArrows\": true }]*/\n/*eslint-env es6*/\n\nvar foo = {\n  foo(bar, baz) {\n    return bar + baz;\n  },\n\n  qux: foobar => foobar * 2\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint object-shorthand: [2, \"consistent\"]*/\n/*eslint-env es6*/\n\nvar foo = {\n    a,\n    b: \"foo\",\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint object-shorthand: [2, \"consistent\"]*/\n/*eslint-env es6*/\n\nvar foo = {\n    a: a,\n    b: \"foo\"\n};\n\nvar bar = {\n    a,\n    b,\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint object-shorthand: [2, \"consistent-as-needed\"]*/\n/*eslint-env es6*/\n\nvar foo = {\n    a: a,\n    b: b,\n};"
            }
        ]
    },
    {
        "name": "one-var",
        "url": "https://eslint.org/docs/latest/rules/one-var",
        "description": "Enforce variables to be declared either together or separately in functionsVariables can be declared at any point in JavaScript code using var, let, or const. There are many styles and preferences related to the declaration of variables, and one of those is deciding on how many variable declarations should be allowed in a single function.There are two schools of thought in this regard:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", \"always\"]*/\n\nfunction foo() {\n    var bar;\n    var baz;\n    let qux;\n    let norf;\n}\n\nfunction foo(){\n    const bar = false;\n    const baz = true;\n    let qux;\n    let norf;\n}\n\nfunction foo() {\n    var bar;\n\n    if (baz) {\n        var qux = true;\n    }\n}\n\nclass C {\n    static {\n        var foo;\n        var bar;\n    }\n\n    static {\n        var foo;\n        if (bar) {\n            var baz = true;\n        }\n    }\n\n    static {\n        let foo;\n        let bar;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", \"always\"]*/\n\nfunction foo() {\n    var bar,\n        baz;\n    let qux,\n        norf;\n}\n\nfunction foo(){\n    const bar = true,\n        baz = false;\n    let qux,\n        norf;\n}\n\nfunction foo() {\n    var bar,\n        qux;\n\n    if (baz) {\n        qux = true;\n    }\n}\n\nfunction foo(){\n    let bar;\n\n    if (baz) {\n        let qux;\n    }\n}\n\nclass C {\n    static {\n        var foo, bar;\n    }\n\n    static {\n        var foo, baz;\n        if (bar) {\n            baz = true;\n        }\n    }\n\n    static {\n        let foo, bar;\n    }\n\n    static {\n        let foo;\n        if (bar) {\n            let baz;\n        }\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", \"never\"]*/\n\nfunction foo() {\n    var bar,\n        baz;\n    const bar = true,\n        baz = false;\n}\n\nfunction foo() {\n    var bar,\n        qux;\n\n    if (baz) {\n        qux = true;\n    }\n}\n\nfunction foo(){\n    let bar = true,\n        baz = false;\n}\n\nclass C {\n    static {\n        var foo, bar;\n        let baz, qux;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", \"never\"]*/\n\nfunction foo() {\n    var bar;\n    var baz;\n}\n\nfunction foo() {\n    var bar;\n\n    if (baz) {\n        var qux = true;\n    }\n}\n\nfunction foo() {\n    let bar;\n\n    if (baz) {\n        let qux = true;\n    }\n}\n\nclass C {\n    static {\n        var foo;\n        var bar;\n        let baz;\n        let qux;\n    }\n}\n\n// declarations with multiple variables are allowed in for-loop initializers\nfor (var i = 0, len = arr.length; i < len; i++) {\n    doSomething(arr[i]);\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", \"consecutive\"]*/\n\nfunction foo() {\n    var bar;\n    var baz;\n}\n\nfunction foo(){\n    var bar = 1;\n    var baz = 2;\n\n    qux();\n\n    var qux = 3;\n    var quux;\n}\n\nclass C {\n    static {\n        var foo;\n        var bar;\n        let baz;\n        let qux;\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", \"consecutive\"]*/\n\nfunction foo() {\n    var bar,\n        baz;\n}\n\nfunction foo(){\n    var bar = 1,\n        baz = 2;\n\n    qux();\n\n    var qux = 3,\n        quux;\n}\n\nclass C {\n    static {\n        var foo, bar;\n        let baz, qux;\n        doSomething();\n        let quux;\n        var quuux;\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", { var: \"always\", let: \"never\", const: \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar;\n    var baz;\n    let qux,\n        norf;\n}\n\nfunction foo() {\n    const bar = 1,\n          baz = 2;\n    let qux,\n        norf;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", { var: \"always\", let: \"never\", const: \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar,\n        baz;\n    let qux;\n    let norf;\n}\n\nfunction foo() {\n    const bar = 1;\n    const baz = 2;\n    let qux;\n    let norf;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", { var: \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar,\n        baz;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", { var: \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar,\n        baz;\n    const bar = 1; // `const` and `let` declarations are ignored if they are not specified\n    const baz = 2;\n    let qux;\n    let norf;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", { separateRequires: true, var: \"always\" }]*/\n/*eslint-env node*/\n\nvar foo = require(\"foo\"),\n    bar = \"bar\";"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", { separateRequires: true, var: \"always\" }]*/\n/*eslint-env node*/\n\nvar foo = require(\"foo\");\nvar bar = \"bar\";"
            },
            {
                "type": "correct",
                "content": "var foo = require(\"foo\"),\n    bar = require(\"bar\");"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", { var: \"never\", let: \"consecutive\", const: \"consecutive\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    let a,\n        b;\n    let c;\n\n    var d,\n        e;\n}\n\nfunction foo() {\n    const a = 1,\n        b = 2;\n    const c = 3;\n\n    var d,\n        e;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", { var: \"never\", let: \"consecutive\", const: \"consecutive\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    let a,\n        b;\n\n    var d;\n    var e;\n\n    let f;\n}\n\nfunction foo() {\n    const a = 1,\n          b = 2;\n\n    var c;\n    var d;\n\n    const e = 3;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", { var: \"consecutive\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var a;\n    var b;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", { var: \"consecutive\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var a,\n        b;\n    const c = 1; // `const` and `let` declarations are ignored if they are not specified\n    const d = 2;\n    let e;\n    let f;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", { \"initialized\": \"always\", \"uninitialized\": \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var a, b, c;\n    var foo = true;\n    var bar = false;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", { \"initialized\": \"always\", \"uninitialized\": \"never\" }]*/\n\nfunction foo() {\n    var a;\n    var b;\n    var c;\n    var foo = true,\n        bar = false;\n}\n\nfor (let z of foo) {\n    doSomething(z);\n}\n\nlet z;\nfor (z of foo) {\n    doSomething(z);\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", { \"initialized\": \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var foo = true,\n        bar = false;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", { \"initialized\": \"never\" }]*/\n\nfunction foo() {\n    var foo = true;\n    var bar = false;\n    var a, b, c; // Uninitialized variables are ignored\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", { \"initialized\": \"consecutive\", \"uninitialized\": \"never\" }]*/\n\nfunction foo() {\n    var a = 1;\n    var b = 2;\n    var c,\n        d;\n    var e = 3;\n    var f = 4;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", { \"initialized\": \"consecutive\", \"uninitialized\": \"never\" }]*/\n\nfunction foo() {\n    var a = 1,\n        b = 2;\n    var c;\n    var d;\n    var e = 3,\n        f = 4;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var: [\"error\", { \"initialized\": \"consecutive\" }]*/\n\nfunction foo() {\n    var a = 1;\n    var b = 2;\n\n    foo();\n\n    var c = 3;\n    var d = 4;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var: [\"error\", { \"initialized\": \"consecutive\" }]*/\n\nfunction foo() {\n    var a = 1,\n        b = 2;\n\n    foo();\n\n    var c = 3,\n        d = 4;\n}"
            }
        ]
    },
    {
        "name": "one-var-declaration-per-line",
        "url": "https://eslint.org/docs/latest/rules/one-var-declaration-per-line",
        "description": "Require or disallow newlines around variable declarationsSome developers declare multiple var statements on the same line:Others prefer to declare one var per line.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint one-var-declaration-per-line: [\"error\", \"initializations\"]*/\n/*eslint-env es6*/\n\nvar a, b, c = 0;\n\nlet a,\n    b = 0, c;"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var-declaration-per-line: [\"error\", \"initializations\"]*/\n/*eslint-env es6*/\n\nvar a, b;\n\nlet a,\n    b;\n\nlet a,\n    b = 0;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint one-var-declaration-per-line: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar a, b;\n\nlet a, b = 0;\n\nconst a = 0, b = 0;"
            },
            {
                "type": "correct",
                "content": "/*eslint one-var-declaration-per-line: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar a,\n    b;\n\nlet a,\n    b = 0;"
            }
        ]
    },
    {
        "name": "operator-assignment",
        "url": "https://eslint.org/docs/latest/rules/operator-assignment",
        "description": "Require or disallow assignment operator shorthand where possibleJavaScript provides shorthand operators that combine variable assignment and some simple mathematical operations. For example, x = x + 4 can be shortened to x += 4. The supported shorthand forms are as follows:This rule requires or disallows assignment operator shorthand where possible.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint operator-assignment: [\"error\", \"always\"]*/\n\nx = x + y;\nx = y * x;\nx[0] = x[0] / y;\nx.y = x.y << z;"
            },
            {
                "type": "correct",
                "content": "/*eslint operator-assignment: [\"error\", \"always\"]*/\n\nx = y;\nx += y;\nx = y * z;\nx = (x * y) * z;\nx[0] /= y;\nx[foo()] = x[foo()] % 2;\nx = y + x; // `+` is not always commutative (e.g. x = \"abc\")"
            },
            {
                "type": "incorrect",
                "content": "/*eslint operator-assignment: [\"error\", \"never\"]*/\n\nx *= y;\nx ^= (y + z) / foo();"
            },
            {
                "type": "correct",
                "content": "/*eslint operator-assignment: [\"error\", \"never\"]*/\n\nx = x + y;\nx.y = x.y / a.b;"
            }
        ]
    },
    {
        "name": "prefer-arrow-callback",
        "url": "https://eslint.org/docs/latest/rules/prefer-arrow-callback",
        "description": "Require using arrow functions for callbacksArrow functions can be an attractive alternative to function expressions for callbacks or function arguments.For example, arrow functions are automatically bound to their surrounding scope/context. This provides an alternative to the pre-ES6 standard of explicitly binding function expressions to achieve similar behavior.",
        "examples": []
    },
    {
        "name": "prefer-const",
        "url": "https://eslint.org/docs/latest/rules/prefer-const",
        "description": "Require const declarations for variables that are never reassigned after declaredIf a variable is never reassigned, using the const declaration is better.const declaration tells readers, “this variable is never reassigned,” reducing cognitive load and improving maintainability.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint prefer-const: \"error\"*/\n\n// it's initialized and never reassigned.\nlet a = 3;\nconsole.log(a);\n\nlet a;\na = 0;\nconsole.log(a);\n\nclass C {\n    static {\n        let a;\n        a = 0;\n        console.log(a);\n    }\n}\n\n// `i` is redefined (not reassigned) on each loop step.\nfor (let i in [1, 2, 3]) {\n    console.log(i);\n}\n\n// `a` is redefined (not reassigned) on each loop step.\nfor (let a of [1, 2, 3]) {\n    console.log(a);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-const: \"error\"*/\n\n// using const.\nconst a = 0;\n\n// it's never initialized.\nlet a;\nconsole.log(a);\n\n// it's reassigned after initialized.\nlet a;\na = 0;\na = 1;\nconsole.log(a);\n\n// it's initialized in a different block from the declaration.\nlet a;\nif (true) {\n    a = 0;\n}\nconsole.log(a);\n\n// it's initialized in a different scope.\nlet a;\nclass C {\n    #x;\n    static {\n        a = obj => obj.#x;\n    }\n}\n\n// it's initialized at a place that we cannot write a variable declaration.\nlet a;\nif (true) a = 0;\nconsole.log(a);\n\n// `i` gets a new binding each iteration\nfor (const i in [1, 2, 3]) {\n  console.log(i);\n}\n\n// `a` gets a new binding each iteration\nfor (const a of [1, 2, 3]) {\n  console.log(a);\n}\n\n// `end` is never reassigned, but we cannot separate the declarations without modifying the scope.\nfor (let i = 0, end = 10; i < end; ++i) {\n    console.log(a);\n}\n\n// `predicate` is only assigned once but cannot be separately declared as `const`\nlet predicate;\n[object.type, predicate] = foo();\n\n// `a` is only assigned once but cannot be separately declared as `const`\nlet a;\nconst b = {};\n({ a, c: b.c } = func());\n\n// suggest to use `no-var` rule.\nvar b = 3;\nconsole.log(b);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint prefer-const: \"error\"*/\n/*eslint-env es6*/\n\nlet {a, b} = obj;    /*error 'b' is never reassigned, use 'const' instead.*/\na = a + 1;"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-const: \"error\"*/\n/*eslint-env es6*/\n\n// using const.\nconst {a: a0, b} = obj;\nconst a = a0 + 1;\n\n// all variables are reassigned.\nlet {a, b} = obj;\na = a + 1;\nb = b + 1;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint prefer-const: [\"error\", {\"destructuring\": \"all\"}]*/\n/*eslint-env es6*/\n\n// all of `a` and `b` should be const, so those are warned.\nlet {a, b} = obj;    /*error 'a' is never reassigned, use 'const' instead.\n                             'b' is never reassigned, use 'const' instead.*/"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-const: [\"error\", {\"destructuring\": \"all\"}]*/\n/*eslint-env es6*/\n\n// 'b' is never reassigned, but all of `a` and `b` should not be const, so those are ignored.\nlet {a, b} = obj;\na = a + 1;"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-const: [\"error\", {\"ignoreReadBeforeAssign\": true}]*/\n/*eslint-env es6*/\n\nlet timer;\nfunction initialize() {\n    if (foo()) {\n        clearInterval(timer);\n    }\n}\ntimer = setInterval(initialize, 100);"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-const: [\"error\", {\"ignoreReadBeforeAssign\": false}]*/\n/*eslint-env es6*/\n\nconst timer = setInterval(initialize, 100);\nfunction initialize() {\n    if (foo()) {\n        clearInterval(timer);\n    }\n}"
            }
        ]
    },
    {
        "name": "prefer-destructuring",
        "url": "https://eslint.org/docs/latest/rules/prefer-destructuring",
        "description": "Require destructuring from arrays and/or objectsWith JavaScript ES6, a new syntax was added for creating variables from an array index or object property, called destructuring. This rule enforces usage of destructuring instead of accessing a property through a member expression.This rule takes two sets of configuration objects. The first object parameter determines what types of destructuring the rule applies to.",
        "examples": [
            {
                "type": "incorrect",
                "content": "// With `array` enabled\nvar foo = array[0];\n\n// With `object` enabled\nvar foo = object.foo;\nvar foo = object['foo'];"
            },
            {
                "type": "correct",
                "content": "// With `array` enabled\nvar [ foo ] = array;\nvar foo = array[someIndex];\n\n// With `object` enabled\nvar { foo } = object;\n\nvar foo = object.bar;\n\nlet foo;\n({ foo } = object);"
            },
            {
                "type": "incorrect",
                "content": "var foo = object.bar;"
            },
            {
                "type": "correct",
                "content": "var { bar: foo } = object;"
            },
            {
                "type": "correct",
                "content": "class C {\n    #x;\n    foo() {\n        const bar = this.#x; // private identifiers are not allowed in destructuring\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint prefer-destructuring: [\"error\", {VariableDeclarator: {object: true}}] */\nvar {bar: foo} = object;"
            },
            {
                "type": "correct",
                "content": "/* eslint prefer-destructuring: [\"error\", {AssignmentExpression: {array: true}}] */\n[bar] = array;"
            }
        ]
    },
    {
        "name": "prefer-exponentiation-operator",
        "url": "https://eslint.org/docs/latest/rules/prefer-exponentiation-operator",
        "description": "Disallow the use of Math.pow in favor of the ** operatorIntroduced in ES2016, the infix exponentiation operator ** is an alternative for the standard Math.pow function.Infix notation is considered to be more readable and thus more preferable than the function notation.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint prefer-exponentiation-operator: \"error\"*/\n\nconst foo = Math.pow(2, 8);\n\nconst bar = Math.pow(a, b);\n\nlet baz = Math.pow(a + b, c + d);\n\nlet quux = Math.pow(-1, n);"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-exponentiation-operator: \"error\"*/\n\nconst foo = 2 ** 8;\n\nconst bar = a ** b;\n\nlet baz = (a + b) ** (c + d);\n\nlet quux = (-1) ** n;"
            }
        ]
    },
    {
        "name": "prefer-named-capture-group",
        "url": "https://eslint.org/docs/latest/rules/prefer-named-capture-group",
        "description": "Enforce using named capture group in regular expressionWith the landing of ECMAScript 2018, named capture groups can be used in regular expressions, which can improve their readability. This rule is aimed at using named capture groups instead of numbered capture groups in regular expressions:Alternatively, if your intention is not to capture the results, but only express the alternative, use a non-capturing group:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint prefer-named-capture-group: \"error\"*/\n\nconst foo = /(ba[rz])/;\nconst bar = new RegExp('(ba[rz])');\nconst baz = RegExp('(ba[rz])');\n\nfoo.exec('bar')[1]; // Retrieve the group result."
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-named-capture-group: \"error\"*/\n\nconst foo = /(?<id>ba[rz])/;\nconst bar = new RegExp('(?<id>ba[rz])');\nconst baz = RegExp('(?<id>ba[rz])');\nconst xyz = /xyz(?:zy|abc)/;\n\nfoo.exec('bar').groups.id; // Retrieve the group result."
            }
        ]
    },
    {
        "name": "prefer-numeric-literals",
        "url": "https://eslint.org/docs/latest/rules/prefer-numeric-literals",
        "description": "Disallow parseInt() and Number.parseInt() in favor of binary, octal, and hexadecimal literalsThe parseInt() and Number.parseInt() functions can be used to turn binary, octal, and hexadecimal strings into integers. As binary, octal, and hexadecimal literals are supported in ES6, this rule encourages use of those numeric literals instead of parseInt() or Number.parseInt().This rule disallows calls to parseInt() or Number.parseInt() if called with two arguments: a string; and a radix option of 2 (binary), 8 (octal), or 16 (hexadecimal).",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint prefer-numeric-literals: \"error\"*/\n\nparseInt(\"111110111\", 2) === 503;\nparseInt(`111110111`, 2) === 503;\nparseInt(\"767\", 8) === 503;\nparseInt(\"1F7\", 16) === 503;\nNumber.parseInt(\"111110111\", 2) === 503;\nNumber.parseInt(\"767\", 8) === 503;\nNumber.parseInt(\"1F7\", 16) === 503;"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-numeric-literals: \"error\"*/\n/*eslint-env es6*/\n\nparseInt(1);\nparseInt(1, 3);\nNumber.parseInt(1);\nNumber.parseInt(1, 3);\n\n0b111110111 === 503;\n0o767 === 503;\n0x1F7 === 503;\n\na[parseInt](1,2);\n\nparseInt(foo);\nparseInt(foo, 2);\nNumber.parseInt(foo);\nNumber.parseInt(foo, 2);"
            }
        ]
    },
    {
        "name": "prefer-object-has-own",
        "url": "https://eslint.org/docs/latest/rules/prefer-object-has-own",
        "description": "Disallow use of Object.prototype.hasOwnProperty.call() and prefer use of Object.hasOwn()It is very common to write code like:This is a common practice because methods on Object.prototype can sometimes be unavailable or redefined (see the no-prototype-builtins rule).",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint prefer-object-has-own: \"error\"*/\n\nObject.prototype.hasOwnProperty.call(obj, \"a\");\n\nObject.hasOwnProperty.call(obj, \"a\");\n\n({}).hasOwnProperty.call(obj, \"a\");\n\nconst hasProperty = Object.prototype.hasOwnProperty.call(object, property);"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-object-has-own: \"error\"*/\n\nObject.hasOwn(obj, \"a\");\n\nconst hasProperty = Object.hasOwn(object, property);"
            }
        ]
    },
    {
        "name": "prefer-object-spread",
        "url": "https://eslint.org/docs/latest/rules/prefer-object-spread",
        "description": "Disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.When Object.assign is called using an object literal as the first argument, this rule requires using the object spread syntax instead. This rule also warns on cases where an Object.assign call is made using a single argument that is an object literal, in this case, the Object.assign call is not needed.Introduced in ES2018, object spread is a declarative alternative which may perform better than the more dynamic, imperative Object.assign.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint prefer-object-spread: \"error\"*/\n\nObject.assign({}, foo);\n\nObject.assign({}, {foo: 'bar'});\n\nObject.assign({ foo: 'bar'}, baz);\n\nObject.assign({}, baz, { foo: 'bar' });\n\nObject.assign({}, { ...baz });\n\n// Object.assign with a single argument that is an object literal\nObject.assign({});\n\nObject.assign({ foo: bar });"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-object-spread: \"error\"*/\n\n({ ...foo });\n\n({ ...baz, foo: 'bar' });\n\n// Any Object.assign call without an object literal as the first argument\nObject.assign(foo, { bar: baz });\n\nObject.assign(foo, bar);\n\nObject.assign(foo, { bar, baz });\n\nObject.assign(foo, { ...baz });"
            }
        ]
    },
    {
        "name": "prefer-promise-reject-errors",
        "url": "https://eslint.org/docs/latest/rules/prefer-promise-reject-errors",
        "description": "Require using Error objects as Promise rejection reasonsIt is considered good practice to only pass instances of the built-in Error object to the reject() function for user-defined errors in Promises. Error objects automatically store a stack trace, which can be used to debug an error by determining where it came from. If a Promise is rejected with a non-Error value, it can be difficult to determine where the rejection occurred.This rule aims to ensure that Promises are only rejected with Error objects.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint prefer-promise-reject-errors: \"error\"*/\n\nPromise.reject(\"something bad happened\");\n\nPromise.reject(5);\n\nPromise.reject();\n\nnew Promise(function(resolve, reject) {\n  reject(\"something bad happened\");\n});\n\nnew Promise(function(resolve, reject) {\n  reject();\n});\n"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-promise-reject-errors: \"error\"*/\n\nPromise.reject(new Error(\"something bad happened\"));\n\nPromise.reject(new TypeError(\"something bad happened\"));\n\nnew Promise(function(resolve, reject) {\n  reject(new Error(\"something bad happened\"));\n});\n\nvar foo = getUnknownValue();\nPromise.reject(foo);"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-promise-reject-errors: [\"error\", {\"allowEmptyReject\": true}]*/\n\nPromise.reject();\n\nnew Promise(function(resolve, reject) {\n  reject();\n});"
            }
        ]
    },
    {
        "name": "prefer-regex-literals",
        "url": "https://eslint.org/docs/latest/rules/prefer-regex-literals",
        "description": "Disallow use of the RegExp constructor in favor of regular expression literalsThere are two ways to create a regular expression:The constructor function is particularly useful when you want to dynamically generate the pattern, because it takes string arguments.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint prefer-regex-literals: \"error\"*/\n\nnew RegExp(\"abc\");\n\nnew RegExp(\"abc\", \"u\");\n\nRegExp(\"abc\");\n\nRegExp(\"abc\", \"u\");\n\nnew RegExp(\"\\\\d\\\\d\\\\.\\\\d\\\\d\\\\.\\\\d\\\\d\\\\d\\\\d\");\n\nRegExp(`^\\\\d\\\\.$`);\n\nnew RegExp(String.raw`^\\d\\.$`);"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-regex-literals: \"error\"*/\n\n/abc/;\n\n/abc/u;\n\n/\\d\\d\\.\\d\\d\\.\\d\\d\\d\\d/;\n\n/^\\d\\.$/;\n\n// RegExp constructor is allowed for dynamically generated regular expressions\n\nnew RegExp(pattern);\n\nRegExp(\"abc\", flags);\n\nnew RegExp(prefix + \"abc\");\n\nRegExp(`${prefix}abc`);\n\nnew RegExp(String.raw`^\\d\\. ${suffix}`);"
            }
        ]
    },
    {
        "name": "prefer-rest-params",
        "url": "https://eslint.org/docs/latest/rules/prefer-rest-params",
        "description": "Require rest parameters instead of argumentsThere are rest parameters in ES2015. We can use that feature for variadic functions instead of the arguments variable.arguments does not have methods of Array.prototype, so it’s a bit of an inconvenience.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint prefer-rest-params: \"error\"*/\n\nfunction foo() {\n    console.log(arguments);\n}\n\nfunction foo(action) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    action.apply(null, args);\n}\n\nfunction foo(action) {\n    var args = [].slice.call(arguments, 1);\n    action.apply(null, args);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-rest-params: \"error\"*/\n\nfunction foo(...args) {\n    console.log(args);\n}\n\nfunction foo(action, ...args) {\n    action.apply(null, args); // or `action(...args)`, related to the `prefer-spread` rule.\n}\n\n// Note: the implicit arguments can be overwritten.\nfunction foo(arguments) {\n    console.log(arguments); // This is the first argument.\n}\nfunction foo() {\n    var arguments = 0;\n    console.log(arguments); // This is a local variable.\n}"
            }
        ]
    },
    {
        "name": "prefer-spread",
        "url": "https://eslint.org/docs/latest/rules/prefer-spread",
        "description": "Require spread operators instead of .apply()Before ES2015, one must use Function.prototype.apply() to call variadic functions.In ES2015, one can use spread syntax to call variadic functions.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint prefer-spread: \"error\"*/\n\nfoo.apply(undefined, args);\nfoo.apply(null, args);\nobj.foo.apply(obj, args);"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-spread: \"error\"*/\n\n// Using spread syntax\nfoo(...args);\nobj.foo(...args);\n\n// The `this` binding is different.\nfoo.apply(obj, args);\nobj.foo.apply(null, args);\nobj.foo.apply(otherObj, args);\n\n// The argument list is not variadic.\n// Those are warned by the `no-useless-call` rule.\nfoo.apply(undefined, [1, 2, 3]);\nfoo.apply(null, [1, 2, 3]);\nobj.foo.apply(obj, [1, 2, 3]);"
            }
        ]
    },
    {
        "name": "prefer-template",
        "url": "https://eslint.org/docs/latest/rules/prefer-template",
        "description": "Require template literals instead of string concatenationIn ES2015 (ES6), we can use template literals instead of string concatenation.This rule is aimed to flag usage of + operators with strings.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint prefer-template: \"error\"*/\n\nvar str = \"Hello, \" + name + \"!\";\nvar str = \"Time: \" + (12 * 60 * 60 * 1000);"
            },
            {
                "type": "correct",
                "content": "/*eslint prefer-template: \"error\"*/\n/*eslint-env es6*/\n\nvar str = \"Hello World!\";\nvar str = `Hello, ${name}!`;\nvar str = `Time: ${12 * 60 * 60 * 1000}`;\n\n// This is reported by `no-useless-concat`.\nvar str = \"Hello, \" + \"World!\";"
            }
        ]
    },
    {
        "name": "quote-props",
        "url": "https://eslint.org/docs/latest/rules/quote-props",
        "description": "Require quotes around object literal property namesObject literal property names can be defined in two ways: using literals or using strings. For example, these two objects are equivalent:In many cases, it doesn’t matter if you choose to use an identifier instead of a string or vice-versa. Even so, you might decide to enforce a consistent style in your code.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint quote-props: [\"error\", \"always\"]*/\n\nvar object = {\n    foo: \"bar\",\n    baz: 42\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint quote-props: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar object1 = {\n    \"foo\": \"bar\",\n    \"baz\": 42,\n    \"qux-lorem\": true\n};\n\nvar object2 = {\n    'foo': 'bar',\n    'baz': 42,\n    'qux-lorem': true\n};\n\nvar object3 = {\n    foo() {\n        return;\n    }\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint quote-props: [\"error\", \"as-needed\"]*/\n\nvar object = {\n    \"a\": 0,\n    \"0\": 0,\n    \"true\": 0,\n    \"null\": 0\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint quote-props: [\"error\", \"as-needed\"]*/\n/*eslint-env es6*/\n\nvar object1 = {\n    \"a-b\": 0,\n    \"0x0\": 0,\n    \"1e2\": 0\n};\n\nvar object2 = {\n    foo: 'bar',\n    baz: 42,\n    true: 0,\n    0: 0,\n    'qux-lorem': true\n};\n\nvar object3 = {\n    foo() {\n        return;\n    }\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint quote-props: [\"error\", \"consistent\"]*/\n\nvar object1 = {\n    foo: \"bar\",\n    \"baz\": 42,\n    \"qux-lorem\": true\n};\n\nvar object2 = {\n    'foo': 'bar',\n    baz: 42\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint quote-props: [\"error\", \"consistent\"]*/\n\nvar object1 = {\n    \"foo\": \"bar\",\n    \"baz\": 42,\n    \"qux-lorem\": true\n};\n\nvar object2 = {\n    'foo': 'bar',\n    'baz': 42\n};\n\nvar object3 = {\n    foo: 'bar',\n    baz: 42\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint quote-props: [\"error\", \"consistent-as-needed\"]*/\n\nvar object1 = {\n    foo: \"bar\",\n    \"baz\": 42,\n    \"qux-lorem\": true\n};\n\nvar object2 = {\n    'foo': 'bar',\n    'baz': 42\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint quote-props: [\"error\", \"consistent-as-needed\"]*/\n\nvar object1 = {\n    \"foo\": \"bar\",\n    \"baz\": 42,\n    \"qux-lorem\": true\n};\n\nvar object2 = {\n    foo: 'bar',\n    baz: 42\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint quote-props: [\"error\", \"as-needed\", { \"keywords\": true }]*/\n\nvar x = {\n    while: 1,\n    volatile: \"foo\"\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint quote-props: [\"error\", \"consistent-as-needed\", { \"keywords\": true }]*/\n\nvar x = {\n    \"prop\": 1,\n    \"bar\": \"foo\"\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint quote-props: [\"error\", \"as-needed\", { \"keywords\": true, \"unnecessary\": false }]*/\n\nvar x = {\n    \"while\": 1,\n    \"foo\": \"bar\"  // Would normally have caused a warning\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint quote-props: [\"error\", \"as-needed\", { \"numbers\": true }]*/\n\nvar x = {\n    100: 1\n}"
            }
        ]
    },
    {
        "name": "radix",
        "url": "https://eslint.org/docs/latest/rules/radix",
        "description": "Enforce the consistent use of the radix argument when using parseInt()When using the parseInt() function it is common to omit the second argument, the radix, and let the function try to determine from the first argument what type of number it is. By default, parseInt() will autodetect decimal and hexadecimal (via 0x prefix). Prior to ECMAScript 5, parseInt() also autodetected octal literals, which caused problems because many developers assumed a leading 0 would be ignored.This confusion led to the suggestion that you always use the radix parameter to parseInt() to eliminate unintended consequences. So instead of doing this:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint radix: \"error\"*/\n\nvar num = parseInt(\"071\");\n\nvar num = parseInt(someValue);\n\nvar num = parseInt(\"071\", \"abc\");\n\nvar num = parseInt(\"071\", 37);\n\nvar num = parseInt();"
            },
            {
                "type": "correct",
                "content": "/*eslint radix: \"error\"*/\n\nvar num = parseInt(\"071\", 10);\n\nvar num = parseInt(\"071\", 8);\n\nvar num = parseFloat(someValue);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint radix: [\"error\", \"as-needed\"]*/\n\nvar num = parseInt(\"071\", 10);\n\nvar num = parseInt(\"071\", \"abc\");\n\nvar num = parseInt();"
            },
            {
                "type": "correct",
                "content": "/*eslint radix: [\"error\", \"as-needed\"]*/\n\nvar num = parseInt(\"071\");\n\nvar num = parseInt(\"071\", 8);\n\nvar num = parseFloat(someValue);"
            }
        ]
    },
    {
        "name": "require-await",
        "url": "https://eslint.org/docs/latest/rules/require-await",
        "description": "Disallow async functions which have no await expressionAsynchronous functions in JavaScript behave differently than other functions in two important ways:The primary reason to use asynchronous functions is typically to use the await operator, such as this:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint require-await: \"error\"*/\n\nasync function foo() {\n    doSomething();\n}\n\nbar(async () => {\n    doSomething();\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint require-await: \"error\"*/\n\nasync function foo() {\n    await doSomething();\n}\n\nbar(async () => {\n    await doSomething();\n});\n\nfunction foo() {\n    doSomething();\n}\n\nbar(() => {\n    doSomething();\n});\n\n// Allow empty functions.\nasync function noop() {}"
            }
        ]
    },
    {
        "name": "require-unicode-regexp",
        "url": "https://eslint.org/docs/latest/rules/require-unicode-regexp",
        "description": "Enforce the use of u flag on RegExpRegExp u flag has two effects:Therefore, the u flag lets us work better with regular expressions.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint require-unicode-regexp: error */\n\nconst a = /aaa/\nconst b = /bbb/gi\nconst c = new RegExp(\"ccc\")\nconst d = new RegExp(\"ddd\", \"gi\")"
            },
            {
                "type": "correct",
                "content": "/*eslint require-unicode-regexp: error */\n\nconst a = /aaa/u\nconst b = /bbb/giu\nconst c = new RegExp(\"ccc\", \"u\")\nconst d = new RegExp(\"ddd\", \"giu\")\n\n// This rule ignores RegExp calls if the flags could not be evaluated to a static value.\nfunction f(flags) {\n    return new RegExp(\"eee\", flags)\n}"
            }
        ]
    },
    {
        "name": "require-yield",
        "url": "https://eslint.org/docs/latest/rules/require-yield",
        "description": "Require generator functions to contain yieldThis rule generates warnings for generator functions that do not have the yield keyword.Examples of incorrect code for this rule:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint require-yield: \"error\"*/\n/*eslint-env es6*/\n\nfunction* foo() {\n  return 10;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint require-yield: \"error\"*/\n/*eslint-env es6*/\n\nfunction* foo() {\n  yield 5;\n  return 10;\n}\n\nfunction foo() {\n  return 10;\n}\n\n// This rule does not warn on empty generator functions.\nfunction* foo() { }"
            }
        ]
    },
    {
        "name": "sort-imports",
        "url": "https://eslint.org/docs/latest/rules/sort-imports",
        "description": "Enforce sorted import declarations within modulesThe import statement is used to import members (functions, objects or primitives) that have been exported from an external module. Using a specific member syntax:The import statement can also import a module without exported bindings. Used when the module does not export anything, but runs it own code or changes the global context object.",
        "examples": [
            {
                "type": "correct",
                "content": "/*eslint sort-imports: \"error\"*/\nimport 'module-without-export.js';\nimport * as bar from 'bar.js';\nimport * as foo from 'foo.js';\nimport {alpha, beta} from 'alpha.js';\nimport {delta, gamma} from 'delta.js';\nimport a from 'baz.js';\nimport {b} from 'qux.js';\n\n/*eslint sort-imports: \"error\"*/\nimport a from 'foo.js';\nimport b from 'bar.js';\nimport c from 'baz.js';\n\n/*eslint sort-imports: \"error\"*/\nimport 'foo.js'\nimport * as bar from 'bar.js';\nimport {a, b} from 'baz.js';\nimport c from 'qux.js';\nimport {d} from 'quux.js';\n\n/*eslint sort-imports: \"error\"*/\nimport {a, b, c} from 'foo.js'"
            },
            {
                "type": "incorrect",
                "content": "/*eslint sort-imports: \"error\"*/\nimport b from 'foo.js';\nimport a from 'bar.js';\n\n/*eslint sort-imports: \"error\"*/\nimport a from 'foo.js';\nimport A from 'bar.js';\n\n/*eslint sort-imports: \"error\"*/\nimport {b, c} from 'foo.js';\nimport {a, b} from 'bar.js';\n\n/*eslint sort-imports: \"error\"*/\nimport a from 'foo.js';\nimport {b, c} from 'bar.js';\n\n/*eslint sort-imports: \"error\"*/\nimport {a} from 'foo.js';\nimport {b, c} from 'bar.js';\n\n/*eslint sort-imports: \"error\"*/\nimport a from 'foo.js';\nimport * as b from 'bar.js';\n\n/*eslint sort-imports: \"error\"*/\nimport {b, a, c} from 'foo.js'"
            },
            {
                "type": "incorrect",
                "content": "/*eslint sort-imports: [\"error\", { \"ignoreCase\": true }]*/\n\nimport B from 'foo.js';\nimport a from 'bar.js';"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-imports: [\"error\", { \"ignoreCase\": true }]*/\n\nimport a from 'foo.js';\nimport B from 'bar.js';\nimport c from 'baz.js';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint sort-imports: [\"error\", { \"ignoreDeclarationSort\": false }]*/\nimport b from 'foo.js'\nimport a from 'bar.js'"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-imports: [\"error\", { \"ignoreDeclarationSort\": true }]*/\nimport a from 'foo.js'\nimport b from 'bar.js'"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-imports: [\"error\", { \"ignoreDeclarationSort\": true }]*/\nimport b from 'foo.js'\nimport a from 'bar.js'"
            },
            {
                "type": "incorrect",
                "content": "/*eslint sort-imports: [\"error\", { \"ignoreMemberSort\": false }]*/\nimport {b, a, c} from 'foo.js'"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-imports: [\"error\", { \"ignoreMemberSort\": true }]*/\nimport {b, a, c} from 'foo.js'"
            },
            {
                "type": "incorrect",
                "content": "/*eslint sort-imports: \"error\"*/\nimport a from 'foo.js';\nimport * as b from 'bar.js';"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-imports: [\"error\", { \"memberSyntaxSortOrder\": ['single', 'all', 'multiple', 'none'] }]*/\n\nimport a from 'foo.js';\nimport * as b from 'bar.js';"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-imports: [\"error\", { \"memberSyntaxSortOrder\": ['all', 'single', 'multiple', 'none'] }]*/\n\nimport * as foo from 'foo.js';\nimport z from 'zoo.js';\nimport {a, b} from 'foo.js';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint sort-imports: [\"error\", { \"allowSeparatedGroups\": true }]*/\n\nimport b from 'foo.js';\nimport c from 'bar.js';\nimport a from 'baz.js';"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-imports: [\"error\", { \"allowSeparatedGroups\": true }]*/\n\nimport b from 'foo.js';\nimport c from 'bar.js';\n\nimport a from 'baz.js';"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-imports: [\"error\", { \"allowSeparatedGroups\": true }]*/\n\nimport b from 'foo.js';\nimport c from 'bar.js';\n// comment\nimport a from 'baz.js';"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-imports: [\"error\", { \"allowSeparatedGroups\": true }]*/\n\nimport b from 'foo.js';\nimport c from 'bar.js';\nquux();\nimport a from 'baz.js';"
            }
        ]
    },
    {
        "name": "sort-keys",
        "url": "https://eslint.org/docs/latest/rules/sort-keys",
        "description": "Require object keys to be sortedWhen declaring multiple properties, some developers prefer to sort property names alphabetically to more easily find and/or diff necessary properties at a later time. Others feel that it adds complexity and becomes burden to maintain.This rule checks all property definitions of object expressions and verifies that all variables are sorted alphabetically.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint sort-keys: \"error\"*/\n/*eslint-env es6*/\n\nlet obj = {a: 1, c: 3, b: 2};\nlet obj = {a: 1, \"c\": 3, b: 2};\n\n// Case-sensitive by default.\nlet obj = {a: 1, b: 2, C: 3};\n\n// Non-natural order by default.\nlet obj = {1: a, 2: c, 10: b};\n\n// This rule checks computed properties which have a simple name as well.\n// Simple names are names which are expressed by an Identifier node or a Literal node.\nconst S = Symbol(\"s\")\nlet obj = {a: 1, [\"c\"]: 3, b: 2};\nlet obj = {a: 1, [S]: 3, b: 2};"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-keys: \"error\"*/\n/*eslint-env es6*/\n\nlet obj = {a: 1, b: 2, c: 3};\nlet obj = {a: 1, \"b\": 2, c: 3};\n\n// Case-sensitive by default.\nlet obj = {C: 3, a: 1, b: 2};\n\n// Non-natural order by default.\nlet obj = {1: a, 10: b, 2: c};\n\n// This rule checks computed properties which have a simple name as well.\nlet obj = {a: 1, [\"b\"]: 2, c: 3};\nlet obj = {a: 1, [b]: 2, c: 3};\n\n// This rule ignores computed properties which have a non-simple name.\nlet obj = {a: 1, [c + d]: 3, b: 2};\nlet obj = {a: 1, [\"c\" + \"d\"]: 3, b: 2};\nlet obj = {a: 1, [`${c}`]: 3, b: 2};\nlet obj = {a: 1, [tag`c`]: 3, b: 2};\n\n// This rule does not report unsorted properties that are separated by a spread property.\nlet obj = {b: 1, ...c, a: 2};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint sort-keys: [\"error\", \"desc\"]*/\n/*eslint-env es6*/\n\nlet obj = {b: 2, c: 3, a: 1};\nlet obj = {\"b\": 2, c: 3, a: 1};\n\n// Case-sensitive by default.\nlet obj = {C: 1, b: 3, a: 2};\n\n// Non-natural order by default.\nlet obj = {10: b, 2: c, 1: a};"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-keys: [\"error\", \"desc\"]*/\n/*eslint-env es6*/\n\nlet obj = {c: 3, b: 2, a: 1};\nlet obj = {c: 3, \"b\": 2, a: 1};\n\n// Case-sensitive by default.\nlet obj = {b: 3, a: 2, C: 1};\n\n// Non-natural order by default.\nlet obj = {2: c, 10: b, 1: a};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint sort-keys: [\"error\", \"asc\", {caseSensitive: false}]*/\n/*eslint-env es6*/\n\nlet obj = {a: 1, c: 3, C: 4, b: 2};\nlet obj = {a: 1, C: 3, c: 4, b: 2};"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-keys: [\"error\", \"asc\", {caseSensitive: false}]*/\n/*eslint-env es6*/\n\nlet obj = {a: 1, b: 2, c: 3, C: 4};\nlet obj = {a: 1, b: 2, C: 3, c: 4};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint sort-keys: [\"error\", \"asc\", {natural: true}]*/\n/*eslint-env es6*/\n\nlet obj = {1: a, 10: c, 2: b};"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-keys: [\"error\", \"asc\", {natural: true}]*/\n/*eslint-env es6*/\n\nlet obj = {1: a, 2: b, 10: c};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint sort-keys: [\"error\", \"asc\", {minKeys: 4}]*/\n/*eslint-env es6*/\n\n// 4 keys\nlet obj = {\n    b: 2,\n    a: 1, // not sorted correctly (should be 1st key)\n    c: 3,\n    d: 4,\n};\n\n// 5 keys\nlet obj = {\n    2: 'a',\n    1: 'b', // not sorted correctly (should be 1st key)\n    3: 'c',\n    4: 'd',\n    5: 'e',\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-keys: [\"error\", \"asc\", {minKeys: 4}]*/\n/*eslint-env es6*/\n\n// 3 keys\nlet obj = {\n    b: 2,\n    a: 1,\n    c: 3,\n};\n\n// 2 keys\nlet obj = {\n    2: 'b',\n    1: 'a',\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint sort-keys: [\"error\", \"asc\", {allowLineSeparatedGroups: true}]*/\n/*eslint-env es6*/\n\nlet obj1 = {\n    b: 1,\n    c () {\n\n    },\n    a: 3\n}\n\nlet obj2 = {\n    b: 1,\n    c: 2,\n\n    z () {\n\n    },\n    y: 3\n}\n\nlet obj3 = {\n    b: 1,\n    c: 2,\n\n    z () {\n\n    },\n    // comment\n    y: 3,\n}\n\nlet obj4 = {\n    b: 1\n    // comment before comma\n    , a: 2\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-keys: [\"error\", \"asc\", {allowLineSeparatedGroups: true}]*/\n/*eslint-env es6*/\n\nlet obj = {\n    e: 1,\n    f: 2,\n    g: 3,\n\n    a: 4,\n    b: 5,\n    c: 6\n}\n\nlet obj = {\n    b: 1,\n\n    // comment\n    a: 4,\n    c: 5,\n}\n\nlet obj = {\n    c: 1,\n    d: 2,\n\n    b () {\n\n    }, \n    e: 3,\n}\n\nlet obj = {\n    c: 1,\n    d: 2,\n    // comment\n\n    // comment\n    b() {\n\n    },\n    e: 4\n}\n\nlet obj = {\n    b,\n\n    [foo + bar]: 1,\n    a\n}\n\nlet obj = {\n    b: 1\n    // comment before comma\n\n    ,\n    a: 2\n};\n\nvar obj = {\n    b: 1,\n\n    a: 2,\n    ...z,\n    c: 3\n}"
            }
        ]
    },
    {
        "name": "sort-vars",
        "url": "https://eslint.org/docs/latest/rules/sort-vars",
        "description": "Require variables within the same declaration block to be sortedWhen declaring multiple variables within the same block, some developers prefer to sort variable names alphabetically to be able to find necessary variable easier at the later time. Others feel that it adds complexity and becomes burden to maintain.This rule checks all variable declaration blocks and verifies that all variables are sorted alphabetically. The default configuration of the rule is case-sensitive.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint sort-vars: \"error\"*/\n\nvar b, a;\n\nvar a, B, c;\n\nvar a, A;"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-vars: \"error\"*/\n\nvar a, b, c, d;\n\nvar _a = 10;\nvar _b = 20;\n\nvar A, a;\n\nvar B, a, c;"
            },
            {
                "type": "correct",
                "content": "/*eslint sort-vars: [\"error\", { \"ignoreCase\": true }]*/\n\nvar a, A;\n\nvar a, B, c;"
            }
        ]
    },
    {
        "name": "spaced-comment",
        "url": "https://eslint.org/docs/latest/rules/spaced-comment",
        "description": "Enforce consistent spacing after the // or /* in a commentSome style guides require or disallow a whitespace immediately after the initial // or /* of a comment. Whitespace after the // or /* makes it easier to read text in comments. On the other hand, commenting out code is easier without having to put a whitespace right after the // or /*.This rule will enforce consistency of spacing after the start of a comment // or /*. It also provides several exceptions for various documentation styles.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint spaced-comment: [\"error\", \"always\"]*/\n\n//This is a comment with no whitespace at the beginning\n\n/*This is a comment with no whitespace at the beginning */"
            },
            {
                "type": "incorrect",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"block\": { \"balanced\": true } }] */\n/* This is a comment with whitespace at the beginning but not the end*/"
            },
            {
                "type": "correct",
                "content": "/* eslint spaced-comment: [\"error\", \"always\"] */\n\n// This is a comment with a whitespace at the beginning\n\n/* This is a comment with a whitespace at the beginning */\n\n/*\n * This is a comment with a whitespace at the beginning\n */\n\n/*\nThis comment has a newline\n*/"
            },
            {
                "type": "correct",
                "content": "/* eslint spaced-comment: [\"error\", \"always\"] */\n\n/**\n* I am jsdoc\n*/"
            },
            {
                "type": "incorrect",
                "content": "/*eslint spaced-comment: [\"error\", \"never\"]*/\n\n// This is a comment with a whitespace at the beginning\n\n/* This is a comment with a whitespace at the beginning */\n\n/* \\nThis is a comment with a whitespace at the beginning */"
            },
            {
                "type": "incorrect",
                "content": "/*eslint spaced-comment: [\"error\", \"never\", { \"block\": { \"balanced\": true } }]*/\n/*This is a comment with whitespace at the end */"
            },
            {
                "type": "correct",
                "content": "/*eslint spaced-comment: [\"error\", \"never\"]*/\n\n/*This is a comment with no whitespace at the beginning */"
            },
            {
                "type": "correct",
                "content": "/*eslint spaced-comment: [\"error\", \"never\"]*/\n\n/**\n* I am jsdoc\n*/"
            },
            {
                "type": "incorrect",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"block\": { \"exceptions\": [\"-\"] } }] */\n\n//--------------\n// Comment block\n//--------------"
            },
            {
                "type": "incorrect",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"exceptions\": [\"-\", \"+\"] }] */\n\n//------++++++++\n// Comment block\n//------++++++++"
            },
            {
                "type": "incorrect",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"exceptions\": [\"-\", \"+\"] }] */\n\n/*------++++++++*/\n/* Comment block */\n/*------++++++++*/"
            },
            {
                "type": "incorrect",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"line\": { \"exceptions\": [\"-+\"] } }] */\n\n/*-+-+-+-+-+-+-+*/\n// Comment block\n/*-+-+-+-+-+-+-+*/"
            },
            {
                "type": "incorrect",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"block\": { \"exceptions\": [\"*\"] } }] */\n\n/******** COMMENT *******/"
            },
            {
                "type": "correct",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"exceptions\": [\"-\"] }] */\n\n//--------------\n// Comment block\n//--------------"
            },
            {
                "type": "correct",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"line\": { \"exceptions\": [\"-\"] } }] */\n\n//--------------\n// Comment block\n//--------------"
            },
            {
                "type": "correct",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"exceptions\": [\"*\"] }] */\n\n/****************\n * Comment block\n ****************/"
            },
            {
                "type": "correct",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"exceptions\": [\"-+\"] }] */\n\n//-+-+-+-+-+-+-+\n// Comment block\n//-+-+-+-+-+-+-+\n\n/*-+-+-+-+-+-+-+*/\n// Comment block\n/*-+-+-+-+-+-+-+*/"
            },
            {
                "type": "correct",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"block\": { \"exceptions\": [\"-+\"] } }] */\n\n/*-+-+-+-+-+-+-+*/\n// Comment block\n/*-+-+-+-+-+-+-+*/"
            },
            {
                "type": "correct",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"block\": { \"exceptions\": [\"*\"] } }] */\n\n/***************/\n\n/********\nCOMMENT\n*******/"
            },
            {
                "type": "incorrect",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"markers\": [\"/\"] }] */\n\n///This is a comment with a marker but without whitespace"
            },
            {
                "type": "incorrect",
                "content": "/*eslint spaced-comment: [\"error\", \"always\", { \"block\": { \"markers\": [\"!\"], \"balanced\": true } }]*/\n/*! This is a comment with a marker but without whitespace at the end*/"
            },
            {
                "type": "incorrect",
                "content": "/*eslint spaced-comment: [\"error\", \"never\", { \"block\": { \"markers\": [\"!\"], \"balanced\": true } }]*/\n/*!This is a comment with a marker but with whitespace at the end */"
            },
            {
                "type": "correct",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"markers\": [\"/\"] }] */\n\n/// This is a comment with a marker"
            },
            {
                "type": "correct",
                "content": "/*eslint spaced-comment: [\"error\", \"never\", { \"markers\": [\"!<\"] }]*/\n\n//!<This is a line comment with a marker\n\n/*!<this is a block comment with a marker\nsubsequent lines are ignored\n*/"
            },
            {
                "type": "correct",
                "content": "/* eslint spaced-comment: [\"error\", \"always\", { \"markers\": [\"global\"] }] */\n\n/*global ABC*/"
            }
        ]
    },
    {
        "name": "strict",
        "url": "https://eslint.org/docs/latest/rules/strict",
        "description": "Require or disallow strict mode directivesA strict mode directive is a \"use strict\" literal at the beginning of a script or function body. It enables strict mode semantics.When a directive occurs in global scope, strict mode applies to the entire script:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint strict: [\"error\", \"global\"]*/\n\nfunction foo() {\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint strict: [\"error\", \"global\"]*/\n\nfunction foo() {\n    \"use strict\";\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint strict: [\"error\", \"global\"]*/\n\n\"use strict\";\n\nfunction foo() {\n    \"use strict\";\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint strict: [\"error\", \"global\"]*/\n\n\"use strict\";\n\nfunction foo() {\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint strict: [\"error\", \"function\"]*/\n\n\"use strict\";\n\nfunction foo() {\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint strict: [\"error\", \"function\"]*/\n\nfunction foo() {\n}\n\n(function() {\n    function bar() {\n        \"use strict\";\n    }\n}());"
            },
            {
                "type": "incorrect",
                "content": "/*eslint strict: [\"error\", \"function\"]*/\n/*eslint-env es6*/\n\n// Illegal \"use strict\" directive in function with non-simple parameter list.\n// This is a syntax error since ES2016.\nfunction foo(a = 1) {\n    \"use strict\";\n}\n\n// We cannot write \"use strict\" directive in this function.\n// So we have to wrap this function with a function with \"use strict\" directive.\nfunction foo(a = 1) {\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint strict: [\"error\", \"function\"]*/\n\nfunction foo() {\n    \"use strict\";\n}\n\n(function() {\n    \"use strict\";\n\n    function bar() {\n    }\n\n    function baz(a = 1) {\n    }\n}());\n\nvar foo = (function() {\n    \"use strict\";\n\n    return function foo(a = 1) {\n    };\n}());"
            },
            {
                "type": "incorrect",
                "content": "/*eslint strict: [\"error\", \"never\"]*/\n\n\"use strict\";\n\nfunction foo() {\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint strict: [\"error\", \"never\"]*/\n\nfunction foo() {\n    \"use strict\";\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint strict: [\"error\", \"never\"]*/\n\nfunction foo() {\n}"
            },
            {
                "type": "incorrect",
                "content": "// \"strict\": \"error\"\n\nfunction foo() {\n}"
            },
            {
                "type": "incorrect",
                "content": "// \"strict\": \"error\"\n\n(function() {\n    function bar() {\n        \"use strict\";\n    }\n}());"
            },
            {
                "type": "correct",
                "content": "// \"strict\": \"error\"\n\n\"use strict\";\n\nfunction foo() {\n}"
            },
            {
                "type": "correct",
                "content": "// \"strict\": \"error\"\n\nfunction foo() {\n    \"use strict\";\n}"
            },
            {
                "type": "correct",
                "content": "// \"strict\": \"error\"\n\n(function() {\n    \"use strict\";\n    function bar() {\n        \"use strict\";\n    }\n}());"
            }
        ]
    },
    {
        "name": "symbol-description",
        "url": "https://eslint.org/docs/latest/rules/symbol-description",
        "description": "Require symbol descriptionsThe Symbol function may have an optional description:Using description promotes easier debugging: when a symbol is logged the description is used:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint symbol-description: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = Symbol();"
            },
            {
                "type": "correct",
                "content": "/*eslint symbol-description: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = Symbol(\"some description\");\n\nvar someString = \"some description\";\nvar bar = Symbol(someString);"
            }
        ]
    },
    {
        "name": "vars-on-top",
        "url": "https://eslint.org/docs/latest/rules/vars-on-top",
        "description": "Require var declarations be placed at the top of their containing scopeThe vars-on-top rule generates warnings when variable declarations are not used serially at the top of a function scope or the top of a program. By default variable declarations are always moved (“hoisted”) invisibly to the top of their containing scope by the JavaScript interpreter. This rule forces the programmer to represent that behavior by manually moving the variable declaration to the top of its containing scope.This rule aims to keep all variable declarations in the leading series of statements. Allowing multiple declarations helps promote maintainability and is thus allowed.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint vars-on-top: \"error\"*/\n\n// Variable declaration in a nested block, and a variable declaration after other statements:\nfunction doSomething() {\n    if (true) {\n        var first = true;\n    }\n    var second;\n}\n\n// Variable declaration in for initializer:\nfunction doSomething() {\n    for (var i=0; i<10; i++) {}\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint vars-on-top: \"error\"*/\n\n// Variable declaration after other statements:\nf();\nvar a;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint vars-on-top: \"error\"*/\n\n// Variables in class static blocks should be at the top of the static blocks.\n\nclass C {\n\n    // Variable declaration in a nested block:\n    static {\n        if (something) {\n            var a = true;\n        }\n    }\n\n    // Variable declaration after other statements:\n    static {\n        f();\n        var a;\n    }\n\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint vars-on-top: \"error\"*/\n\nfunction doSomething() {\n    var first;\n    var second; //multiple declarations are allowed at the top\n    if (true) {\n        first = true;\n    }\n}\n\nfunction doSomething() {\n    var i;\n    for (i=0; i<10; i++) {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint vars-on-top: \"error\"*/\n\nvar a;\nf();"
            },
            {
                "type": "correct",
                "content": "/*eslint vars-on-top: \"error\"*/\n\nclass C {\n\n    static {\n        var a;\n        if (something) {\n            a = true;\n        }\n    }\n\n    static {\n        var a;\n        f();\n    }\n\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint vars-on-top: \"error\"*/\n\n// Directives may precede variable declarations.\n\"use strict\";\nvar a;\nf();\n\n// Comments can describe variables.\nfunction doSomething() {\n    // this is the first var.\n    var first;\n    // this is the second var.\n    var second\n}"
            }
        ]
    },
    {
        "name": "yoda",
        "url": "https://eslint.org/docs/latest/rules/yoda",
        "description": "Require or disallow \"Yoda\" conditionsYoda conditions are so named because the literal value of the condition comes first while the variable comes second. For example, the following is a Yoda condition:This is called a Yoda condition because it reads as, “if red equals the color”, similar to the way the Star Wars character Yoda speaks. Compare to the other way of arranging the operands:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint yoda: \"error\"*/\n\nif (\"red\" === color) {\n    // ...\n}\n\nif (`red` === color) {\n    // ...\n}\n\nif (`red` === `${color}`) {\n    // ...\n}\n\nif (true == flag) {\n    // ...\n}\n\nif (5 > count) {\n    // ...\n}\n\nif (-1 < str.indexOf(substr)) {\n    // ...\n}\n\nif (0 <= x && x < 1) {\n    // ...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint yoda: \"error\"*/\n\nif (5 & value) {\n    // ...\n}\n\nif (value === \"red\") {\n    // ...\n}\n\nif (value === `red`) {\n    // ...\n}\n\nif (`${value}` === `red`) {\n\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint yoda: [\"error\", \"never\", { \"exceptRange\": true }]*/\n\nfunction isReddish(color) {\n    return (color.hue < 60 || 300 < color.hue);\n}\n\nif (x < -1 || 1 < x) {\n    // ...\n}\n\nif (count < 10 && (0 <= rand && rand < 1)) {\n    // ...\n}\n\nif (`blue` < x && x < `green`) {\n    // ...\n}\n\nfunction howLong(arr) {\n    return (0 <= arr.length && arr.length < 10) ? \"short\" : \"long\";\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint yoda: [\"error\", \"never\", { \"onlyEquality\": true }]*/\n\nif (x < -1 || 9 < x) {\n}\n\nif (x !== 'foo' && 'bar' != x) {\n}\n\nif (x !== `foo` && `bar` != x) {\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint yoda: [\"error\", \"always\"]*/\n\nif (color == \"blue\") {\n    // ...\n}\n\nif (color == `blue`) {\n    // ...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint yoda: [\"error\", \"always\"]*/\n\nif (\"blue\" == value) {\n    // ...\n}\n\nif (`blue` == value) {\n    // ...\n}\n\nif (`blue` == `${value}`) {\n    // ...\n}\n\nif (-1 < str.indexOf(substr)) {\n    // ...\n}"
            }
        ]
    },
    {
        "name": "array-bracket-newline",
        "url": "https://eslint.org/docs/latest/rules/array-bracket-newline",
        "description": "Enforce linebreaks after opening and before closing array bracketsA number of style guides require or disallow line breaks inside of array brackets.This rule enforces line breaks after opening and before closing array brackets.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint array-bracket-newline: [\"error\", \"always\"]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1,\n    2];\nvar e = [function foo() {\n    dosomething();\n}];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-bracket-newline: [\"error\", \"always\"]*/\n\nvar a = [\n];\nvar b = [\n    1\n];\nvar c = [\n    1, 2\n];\nvar d = [\n    1,\n    2\n];\nvar e = [\n    function foo() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-bracket-newline: [\"error\", \"never\"]*/\n\nvar a = [\n];\nvar b = [\n    1\n];\nvar c = [\n    1, 2\n];\nvar d = [\n    1,\n    2\n];\nvar e = [\n    function foo() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-bracket-newline: [\"error\", \"never\"]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1,\n    2];\nvar e = [function foo() {\n    dosomething();\n}];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-bracket-newline: [\"error\", \"consistent\"]*/\n\nvar a = [1\n];\nvar b = [\n    1];\nvar c = [function foo() {\n    dosomething();\n}\n]\nvar d = [\n    function foo() {\n        dosomething();\n    }]"
            },
            {
                "type": "correct",
                "content": "/*eslint array-bracket-newline: [\"error\", \"consistent\"]*/\n\nvar a = [];\nvar b = [\n];\nvar c = [1];\nvar d = [\n    1\n];\nvar e = [function foo() {\n    dosomething();\n}];\nvar f = [\n    function foo() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-bracket-newline: [\"error\", { \"multiline\": true }]*/\n\nvar a = [\n];\nvar b = [\n    1\n];\nvar c = [\n    1, 2\n];\nvar d = [1,\n    2];\nvar e = [function foo() {\n    dosomething();\n}];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-bracket-newline: [\"error\", { \"multiline\": true }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [\n    1,\n    2\n];\nvar e = [\n    function foo() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-bracket-newline: [\"error\", { \"minItems\": 2 }]*/\n\nvar a = [\n];\nvar b = [\n    1\n];\nvar c = [1, 2];\nvar d = [1,\n    2];\nvar e = [\n  function foo() {\n    dosomething();\n  }\n];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-bracket-newline: [\"error\", { \"minItems\": 2 }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [\n    1, 2\n];\nvar d = [\n    1,\n    2\n];\nvar e = [function foo() {\n    dosomething();\n}];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-bracket-newline: [\"error\", { \"multiline\": true, \"minItems\": 2 }]*/\n\nvar a = [\n];\nvar b = [\n    1\n];\nvar c = [1, 2];\nvar d = [1,\n    2];\nvar e = [function foo() {\n    dosomething();\n}];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-bracket-newline: [\"error\", { \"multiline\": true, \"minItems\": 2 }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [\n    1, 2\n];\nvar d = [\n    1,\n    2\n];\nvar e = [\n    function foo() {\n        dosomething();\n    }\n];"
            }
        ]
    },
    {
        "name": "array-bracket-spacing",
        "url": "https://eslint.org/docs/latest/rules/array-bracket-spacing",
        "description": "Enforce consistent spacing inside array bracketsA number of style guides require or disallow spaces between array brackets and other tokens. This rule applies to both array literals and destructuring assignments (ECMAScript 6).This rule enforces consistent spacing inside array brackets.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint array-bracket-spacing: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nvar arr = [ 'foo', 'bar' ];\nvar arr = ['foo', 'bar' ];\nvar arr = [ ['foo'], 'bar'];\nvar arr = [[ 'foo' ], 'bar'];\nvar arr = [ 'foo',\n  'bar'\n];\nvar [ x, y ] = z;\nvar [ x,y ] = z;\nvar [ x, ...y ] = z;\nvar [ ,,x, ] = z;"
            },
            {
                "type": "correct",
                "content": "/*eslint array-bracket-spacing: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nvar arr = [];\nvar arr = ['foo', 'bar', 'baz'];\nvar arr = [['foo'], 'bar', 'baz'];\nvar arr = [\n  'foo',\n  'bar',\n  'baz'\n];\nvar arr = ['foo',\n  'bar'\n];\nvar arr = [\n  'foo',\n  'bar'];\n\nvar [x, y] = z;\nvar [x,y] = z;\nvar [x, ...y] = z;\nvar [,,x,] = z;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-bracket-spacing: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar arr = ['foo', 'bar'];\nvar arr = ['foo', 'bar' ];\nvar arr = [ ['foo'], 'bar' ];\nvar arr = ['foo',\n  'bar'\n];\nvar arr = [\n  'foo',\n  'bar'];\n\nvar [x, y] = z;\nvar [x,y] = z;\nvar [x, ...y] = z;\nvar [,,x,] = z;"
            },
            {
                "type": "correct",
                "content": "/*eslint array-bracket-spacing: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar arr = [];\nvar arr = [ 'foo', 'bar', 'baz' ];\nvar arr = [ [ 'foo' ], 'bar', 'baz' ];\nvar arr = [ 'foo',\n  'bar'\n];\nvar arr = [\n  'foo',\n  'bar' ];\nvar arr = [\n  'foo',\n  'bar',\n  'baz'\n];\n\nvar [ x, y ] = z;\nvar [ x,y ] = z;\nvar [ x, ...y ] = z;\nvar [ ,,x, ] = z;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-bracket-spacing: [\"error\", \"always\", { \"singleValue\": false }]*/\n\nvar foo = [ 'foo' ];\nvar foo = [ 'foo'];\nvar foo = ['foo' ];\nvar foo = [ 1 ];\nvar foo = [ 1];\nvar foo = [1 ];\nvar foo = [ [ 1, 2 ] ];\nvar foo = [ { 'foo': 'bar' } ];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-bracket-spacing: [\"error\", \"always\", { \"singleValue\": false }]*/\n\nvar foo = ['foo'];\nvar foo = [1];\nvar foo = [[ 1, 1 ]];\nvar foo = [{ 'foo': 'bar' }];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-bracket-spacing: [\"error\", \"always\", { \"objectsInArrays\": false }]*/\n\nvar arr = [ { 'foo': 'bar' } ];\nvar arr = [ {\n  'foo': 'bar'\n} ]"
            },
            {
                "type": "correct",
                "content": "/*eslint array-bracket-spacing: [\"error\", \"always\", { \"objectsInArrays\": false }]*/\n\nvar arr = [{ 'foo': 'bar' }];\nvar arr = [{\n  'foo': 'bar'\n}];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-bracket-spacing: [\"error\", \"always\", { \"arraysInArrays\": false }]*/\n\nvar arr = [ [ 1, 2 ], 2, 3, 4 ];\nvar arr = [ [ 1, 2 ], 2, [ 3, 4 ] ];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-bracket-spacing: [\"error\", \"always\", { \"arraysInArrays\": false }]*/\n\nvar arr = [[ 1, 2 ], 2, 3, 4 ];\nvar arr = [[ 1, 2 ], 2, [ 3, 4 ]];"
            }
        ]
    },
    {
        "name": "array-element-newline",
        "url": "https://eslint.org/docs/latest/rules/array-element-newline",
        "description": "Enforce line breaks after each array elementA number of style guides require or disallow line breaks between array elements.This rule enforces line breaks between array elements.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint array-element-newline: [\"error\", \"always\"]*/\n\nvar c = [1, 2];\nvar d = [1, 2, 3];\nvar e = [1, 2, 3\n];\nvar f = [\n  1, 2, 3\n];\nvar g = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-element-newline: [\"error\", \"always\"]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1,\n    2];\nvar d = [1,\n    2,\n    3];\nvar d = [\n  1, \n  2, \n  3\n];\nvar e = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-element-newline: [\"error\", \"never\"]*/\n\nvar c = [\n    1,\n    2\n];\nvar d = [\n    1,\n    2,\n    3\n];\nvar e = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-element-newline: [\"error\", \"never\"]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1, 2, 3];\nvar e = [\n    1, 2, 3];\nvar f = [\n  1, 2, 3\n];\nvar g = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-element-newline: [\"error\", \"consistent\"]*/\n\nvar a = [\n    1, 2,\n    3\n];\nvar b = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    },\n    function baz() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-element-newline: [\"error\", \"consistent\"]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1, 2, 3];\nvar e = [\n    1,\n    2\n];\nvar f = [\n    1,\n    2,\n    3\n];\nvar g = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }, function baz() {\n        dosomething();\n    }\n];\nvar h = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    },\n    function baz() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-element-newline: [\"error\", { \"multiline\": true }]*/\n\nvar d = [1,\n    2, 3];\nvar e = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-element-newline: [\"error\", { \"multiline\": true }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1, 2, 3];\nvar e = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-element-newline: [\"error\", { \"minItems\": 3 }]*/\n\nvar c = [1,\n    2];\nvar d = [1, 2, 3];\nvar e = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-element-newline: [\"error\", { \"minItems\": 3 }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1,\n    2,\n    3];\nvar e = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-element-newline: [\"error\", { \"multiline\": true, \"minItems\": 3 }]*/\n\nvar c = [1,\n2];\nvar d = [1, 2, 3];\nvar e = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "correct",
                "content": "/*eslint array-element-newline: [\"error\", { \"multiline\": true, \"minItems\": 3 }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1,\n    2,\n    3];\nvar e = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    }\n];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint array-element-newline: [\"error\", { \"ArrayExpression\": \"always\", \"ArrayPattern\": \"never\" }]*/\n\nvar a = [1, 2];\nvar b = [1, 2, 3];\nvar c = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }\n];\n\nvar [d,\n    e] = arr;\nvar [f,\n    g,\n    h] = arr;\nvar [i = function foo() {\n  dosomething()\n},\nj = function bar() {\n  dosomething()\n}] = arr"
            },
            {
                "type": "correct",
                "content": "/*eslint array-element-newline: [\"error\", { \"ArrayExpression\": \"always\", \"ArrayPattern\": \"never\" }]*/\n\nvar a = [1,\n    2];\nvar b = [1,\n    2,\n    3];\nvar c = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    }\n];\n\nvar [d, e] = arr\nvar [f, g, h] = arr\nvar [i = function foo() {\n    dosomething()\n}, j = function bar() {\n    dosomething()\n}] = arr"
            }
        ]
    },
    {
        "name": "arrow-parens",
        "url": "https://eslint.org/docs/latest/rules/arrow-parens",
        "description": "Require parentheses around arrow function argumentsArrow functions can omit parentheses when they have exactly one parameter. In all other cases the parameter(s) must be wrapped in parentheses. This rule enforces the consistent use of parentheses in arrow functions.This rule enforces parentheses around arrow function parameters regardless of arity. For example:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint arrow-parens: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\na => {};\na => a;\na => {'\\n'};\na.then(foo => {});\na.then(foo => a);\na(foo => { if (true) {} });"
            },
            {
                "type": "correct",
                "content": "/*eslint arrow-parens: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\n() => {};\n(a) => {};\n(a) => a;\n(a) => {'\\n'}\na.then((foo) => {});\na.then((foo) => { if (true) {} });"
            },
            {
                "type": "incorrect",
                "content": "/*eslint arrow-parens: [\"error\", \"as-needed\"]*/\n/*eslint-env es6*/\n\n(a) => {};\n(a) => a;\n(a) => {'\\n'};\na.then((foo) => {});\na.then((foo) => a);\na((foo) => { if (true) {} });\nconst f = /** @type {number} */(a) => a + a;\nconst g = /* comment */ (a) => a + a;\nconst h = (a) /* comment */ => a + a;"
            },
            {
                "type": "correct",
                "content": "/*eslint arrow-parens: [\"error\", \"as-needed\"]*/\n/*eslint-env es6*/\n\n() => {};\na => {};\na => a;\na => {'\\n'};\na.then(foo => {});\na.then(foo => { if (true) {} });\n(a, b, c) => a;\n(a = 10) => a;\n([a, b]) => a;\n({a, b}) => a;\nconst f = (/** @type {number} */a) => a + a;\nconst g = (/* comment */ a) => a + a;\nconst h = (a /* comment */) => a + a;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint arrow-parens: [2, \"as-needed\", { \"requireForBlockBody\": true }]*/\n/*eslint-env es6*/\n\n(a) => a;\na => {};\na => {'\\n'};\na.map((x) => x * x);\na.map(x => {\n  return x * x;\n});\na.then(foo => {});"
            },
            {
                "type": "correct",
                "content": "/*eslint arrow-parens: [2, \"as-needed\", { \"requireForBlockBody\": true }]*/\n/*eslint-env es6*/\n\n(a) => {};\n(a) => {'\\n'};\na => ({});\n() => {};\na => a;\na.then((foo) => {});\na.then((foo) => { if (true) {} });\na((foo) => { if (true) {} });\n(a, b, c) => a;\n(a = 10) => a;\n([a, b]) => a;\n({a, b}) => a;"
            }
        ]
    },
    {
        "name": "arrow-spacing",
        "url": "https://eslint.org/docs/latest/rules/arrow-spacing",
        "description": "Enforce consistent spacing before and after the arrow in arrow functionsThis rule normalize style of spacing before/after an arrow function’s arrow(=>).This rule takes an object argument with before and after properties, each with a Boolean value.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint arrow-spacing: \"error\"*/\n/*eslint-env es6*/\n\n()=> {};\n() =>{};\n(a)=> {};\n(a) =>{};\na =>a;\na=> a;\n()=> {'\\n'};\n() =>{'\\n'};"
            },
            {
                "type": "correct",
                "content": "/*eslint arrow-spacing: \"error\"*/\n/*eslint-env es6*/\n\n() => {};\n(a) => {};\na => a;\n() => {'\\n'};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint arrow-spacing: [\"error\", { \"before\": false, \"after\": false }]*/\n/*eslint-env es6*/\n\n() =>{};\n(a) => {};\n()=> {'\\n'};"
            },
            {
                "type": "correct",
                "content": "/*eslint arrow-spacing: [\"error\", { \"before\": false, \"after\": false }]*/\n/*eslint-env es6*/\n\n()=>{};\n(a)=>{};\n()=>{'\\n'};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint arrow-spacing: [\"error\", { \"before\": false, \"after\": true }]*/\n/*eslint-env es6*/\n\n() =>{};\n(a) => {};\n()=>{'\\n'};"
            },
            {
                "type": "correct",
                "content": "/*eslint arrow-spacing: [\"error\", { \"before\": false, \"after\": true }]*/\n/*eslint-env es6*/\n\n()=> {};\n(a)=> {};\n()=> {'\\n'};"
            }
        ]
    },
    {
        "name": "block-spacing",
        "url": "https://eslint.org/docs/latest/rules/block-spacing",
        "description": "Disallow or enforce spaces inside of blocks after opening block and before closing blockThis rule enforces consistent spacing inside an open block token and the next token on the same line. This rule also enforces consistent spacing inside a close block token and previous token on the same line.This rule has a string option:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint block-spacing: \"error\"*/\n\nfunction foo() {return true;}\nif (foo) { bar = 0;}\nfunction baz() {let i = 0;\n    return i;\n}\n\nclass C {\n    static {this.bar = 0;}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint block-spacing: \"error\"*/\n\nfunction foo() { return true; }\nif (foo) { bar = 0; }\n\nclass C {\n    static { this.bar = 0; }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint block-spacing: [\"error\", \"never\"]*/\n\nfunction foo() { return true; }\nif (foo) { bar = 0;}\n\nclass C {\n    static { this.bar = 0; }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint block-spacing: [\"error\", \"never\"]*/\n\nfunction foo() {return true;}\nif (foo) {bar = 0;}\n\nclass C {\n    static {this.bar = 0;}\n}"
            }
        ]
    },
    {
        "name": "brace-style",
        "url": "https://eslint.org/docs/latest/rules/brace-style",
        "description": "Enforce consistent brace style for blocksBrace style is closely related to indent style in programming and describes the placement of braces relative to their control statement and body. There are probably a dozen, if not more, brace styles in the world.The one true brace style is one of the most common brace styles in JavaScript, in which the opening brace of a block is placed on the same line as its corresponding statement or declaration. For example:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint brace-style: \"error\"*/\n\nfunction foo()\n{\n  return true;\n}\n\nif (foo)\n{\n  bar();\n}\n\ntry\n{\n  somethingRisky();\n} catch(e)\n{\n  handleError();\n}\n\nif (foo) {\n  bar();\n}\nelse {\n  baz();\n}\n\nclass C\n{\n    static\n    {\n        foo();\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint brace-style: \"error\"*/\n\nfunction foo() {\n  return true;\n}\n\nif (foo) {\n  bar();\n}\n\nif (foo) {\n  bar();\n} else {\n  baz();\n}\n\ntry {\n  somethingRisky();\n} catch(e) {\n  handleError();\n}\n\nclass C {\n    static {\n        foo();\n    }\n}\n\n// when there are no braces, there are no problems\nif (foo) bar();\nelse if (baz) boom();"
            },
            {
                "type": "correct",
                "content": "/*eslint brace-style: [\"error\", \"1tbs\", { \"allowSingleLine\": true }]*/\n\nfunction nop() { return; }\n\nif (foo) { bar(); }\n\nif (foo) { bar(); } else { baz(); }\n\ntry { somethingRisky(); } catch(e) { handleError(); }\n\nif (foo) { baz(); } else {\n  boom();\n}\n\nif (foo) { baz(); } else if (bar) {\n  boom();\n}\n\nif (foo) { baz(); } else\nif (bar) {\n  boom();\n}\n\nif (foo) { baz(); } else if (bar) {\n  boom();\n}\n\ntry { somethingRisky(); } catch(e) {\n  handleError();\n}\n\nclass C {\n    static { foo(); }\n}\n\nclass D { static { foo(); } }"
            },
            {
                "type": "incorrect",
                "content": "/*eslint brace-style: [\"error\", \"stroustrup\"]*/\n\nfunction foo()\n{\n  return true;\n}\n\nif (foo)\n{\n  bar();\n}\n\ntry\n{\n  somethingRisky();\n} catch(e)\n{\n  handleError();\n}\n\nclass C\n{\n    static\n    {\n        foo();\n    }\n}\n\nif (foo) {\n  bar();\n} else {\n  baz();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint brace-style: [\"error\", \"stroustrup\"]*/\n\nfunction foo() {\n  return true;\n}\n\nif (foo) {\n  bar();\n}\n\nif (foo) {\n  bar();\n}\nelse {\n  baz();\n}\n\ntry {\n  somethingRisky();\n}\ncatch(e) {\n  handleError();\n}\n\nclass C {\n    static {\n        foo();\n    }\n}\n\n// when there are no braces, there are no problems\nif (foo) bar();\nelse if (baz) boom();"
            },
            {
                "type": "correct",
                "content": "/*eslint brace-style: [\"error\", \"stroustrup\", { \"allowSingleLine\": true }]*/\n\nfunction nop() { return; }\n\nif (foo) { bar(); }\n\nif (foo) { bar(); }\nelse { baz(); }\n\ntry { somethingRisky(); }\ncatch(e) { handleError(); }\n\nclass C {\n    static { foo(); }\n}\n\nclass D { static { foo(); } }"
            },
            {
                "type": "incorrect",
                "content": "/*eslint brace-style: [\"error\", \"allman\"]*/\n\nfunction foo() {\n  return true;\n}\n\nif (foo)\n{\n  bar(); }\n\ntry\n{\n  somethingRisky();\n} catch(e)\n{\n  handleError();\n}\n\nclass C {\n    static {\n        foo();\n    }\n}\n\nif (foo) {\n  bar();\n} else {\n  baz();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint brace-style: [\"error\", \"allman\"]*/\n\nfunction foo()\n{\n  return true;\n}\n\nif (foo)\n{\n  bar();\n}\n\nif (foo)\n{\n  bar();\n}\nelse\n{\n  baz();\n}\n\ntry\n{\n  somethingRisky();\n}\ncatch(e)\n{\n  handleError();\n}\n\nclass C\n{\n    static\n    {\n        foo();\n    }\n}\n\n// when there are no braces, there are no problems\nif (foo) bar();\nelse if (baz) boom();"
            },
            {
                "type": "correct",
                "content": "/*eslint brace-style: [\"error\", \"allman\", { \"allowSingleLine\": true }]*/\n\nfunction nop() { return; }\n\nif (foo) { bar(); }\n\nif (foo) { bar(); }\nelse { baz(); }\n\ntry { somethingRisky(); }\ncatch(e) { handleError(); }\n\nclass C\n{\n    static { foo(); }\n\n    static\n    { foo(); }\n}\n\nclass D { static { foo(); } }"
            }
        ]
    },
    {
        "name": "comma-dangle",
        "url": "https://eslint.org/docs/latest/rules/comma-dangle",
        "description": "Require or disallow trailing commasTrailing commas in object literals are valid according to the ECMAScript 5 (and ECMAScript 3!) spec. However, IE8 (when not in IE8 document mode) and below will throw an error when it encounters trailing commas in JavaScript.Trailing commas simplify adding and removing items to objects and arrays, since only the lines you are modifying must be touched. Another argument in favor of trailing commas is that it improves the clarity of diffs when an item is added or removed from an object or array:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint comma-dangle: [\"error\", \"never\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\",\n};\n\nvar arr = [1,2,];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\",\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-dangle: [\"error\", \"never\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\"\n};\n\nvar arr = [1,2];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\"\n});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint comma-dangle: [\"error\", \"always\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\"\n};\n\nvar arr = [1,2];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\"\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-dangle: [\"error\", \"always\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\",\n};\n\nvar arr = [1,2,];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\",\n});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint comma-dangle: [\"error\", \"always-multiline\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\"\n};\n\nvar foo = { bar: \"baz\", qux: \"quux\", };\n\nvar arr = [1,2,];\n\nvar arr = [1,\n    2,];\n\nvar arr = [\n    1,\n    2\n];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\"\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-dangle: [\"error\", \"always-multiline\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\",\n};\n\nvar foo = {bar: \"baz\", qux: \"quux\"};\nvar arr = [1,2];\n\nvar arr = [1,\n    2];\n\nvar arr = [\n    1,\n    2,\n];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\",\n});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint comma-dangle: [\"error\", \"only-multiline\"]*/\n\nvar foo = { bar: \"baz\", qux: \"quux\", };\n\nvar arr = [1,2,];\n\nvar arr = [1,\n    2,];\n"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-dangle: [\"error\", \"only-multiline\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\",\n};\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\"\n};\n\nvar foo = {bar: \"baz\", qux: \"quux\"};\nvar arr = [1,2];\n\nvar arr = [1,\n    2];\n\nvar arr = [\n    1,\n    2,\n];\n\nvar arr = [\n    1,\n    2\n];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\",\n});\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\"\n});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint comma-dangle: [\"error\", {\"functions\": \"never\"}]*/\n\nfunction foo(a, b,) {\n}\n\nfoo(a, b,);\nnew foo(a, b,);"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-dangle: [\"error\", {\"functions\": \"never\"}]*/\n\nfunction foo(a, b) {\n}\n\nfoo(a, b);\nnew foo(a, b);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint comma-dangle: [\"error\", {\"functions\": \"always\"}]*/\n\nfunction foo(a, b) {\n}\n\nfoo(a, b);\nnew foo(a, b);"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-dangle: [\"error\", {\"functions\": \"always\"}]*/\n\nfunction foo(a, b,) {\n}\n\nfoo(a, b,);\nnew foo(a, b,);"
            }
        ]
    },
    {
        "name": "comma-spacing",
        "url": "https://eslint.org/docs/latest/rules/comma-spacing",
        "description": "Enforce consistent spacing before and after commasSpacing around commas improves readability of a list of items. Although most of the style guidelines for languages prescribe adding a space after a comma and not before it, it is subjective to the preferences of a project.This rule enforces consistent spacing before and after commas in variable declarations, array literals, object literals, function parameters, and sequences.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint comma-spacing: [\"error\", { \"before\": false, \"after\": true }]*/\n\nvar foo = 1 ,bar = 2;\nvar arr = [1 , 2];\nvar obj = {\"foo\": \"bar\" ,\"baz\": \"qur\"};\nfoo(a ,b);\nnew Foo(a ,b);\nfunction foo(a ,b){}\na ,b"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-spacing: [\"error\", { \"before\": false, \"after\": true }]*/\n\nvar foo = 1, bar = 2\n    , baz = 3;\nvar arr = [1, 2];\nvar arr = [1,, 3]\nvar obj = {\"foo\": \"bar\", \"baz\": \"qur\"};\nfoo(a, b);\nnew Foo(a, b);\nfunction foo(a, b){}\na, b"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-spacing: [\"error\", { \"before\": false, \"after\": true }]*/\n\n// this rule does not enforce spacing between two commas\nvar arr = [\n    ,,\n    , ,\n];\n\n// this rule does not enforce spacing after `[` and before `]`\nvar arr = [,];\nvar arr = [ , ];\nvar arr = [a, b,];\n[,] = arr;\n[ , ] = arr;\n[a, b,] = arr;\n\n// this rule does not enforce spacing before `}`\nvar obj = {x, y,};\nvar {z, q,} = obj;\nimport {foo, bar,} from \"mod\";\n\n// this rule does not enforce spacing before `)`\nfoo(a, b,)"
            },
            {
                "type": "incorrect",
                "content": "/*eslint comma-spacing: [\"error\", { \"before\": true, \"after\": false }]*/\n\nvar foo = 1, bar = 2;\nvar arr = [1 , 2];\nvar obj = {\"foo\": \"bar\", \"baz\": \"qur\"};\nnew Foo(a,b);\nfunction foo(a,b){}\na, b"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-spacing: [\"error\", { \"before\": true, \"after\": false }]*/\n\nvar foo = 1 ,bar = 2 ,\n    baz = true;\nvar arr = [1 ,2];\nvar arr = [1 ,,3]\nvar obj = {\"foo\": \"bar\" ,\"baz\": \"qur\"};\nfoo(a ,b);\nnew Foo(a ,b);\nfunction foo(a ,b){}\na ,b"
            }
        ]
    },
    {
        "name": "comma-style",
        "url": "https://eslint.org/docs/latest/rules/comma-style",
        "description": "Enforce consistent comma styleThe Comma Style rule enforces styles for comma-separated lists. There are two comma styles primarily used in JavaScript:One of the justifications for using Comma First style is that it can help track missing and trailing commas. These are problematic because missing commas in variable declarations can lead to the leakage of global variables and trailing commas can lead to errors in older versions of IE.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint comma-style: [\"error\", \"last\"]*/\n\nvar foo = 1\n,\nbar = 2;\n\nvar foo = 1\n  , bar = 2;\n\nvar foo = [\"apples\"\n           , \"oranges\"];\n\nfunction bar() {\n    return {\n        \"a\": 1\n        ,\"b:\": 2\n    };\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-style: [\"error\", \"last\"]*/\n\nvar foo = 1, bar = 2;\n\nvar foo = 1,\n    bar = 2;\n\nvar foo = [\"apples\",\n           \"oranges\"];\n\nfunction bar() {\n    return {\n        \"a\": 1,\n        \"b:\": 2\n    };\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint comma-style: [\"error\", \"first\"]*/\n\nvar foo = 1,\n    bar = 2;\n\nvar foo = [\"apples\",\n           \"oranges\"];\n\nfunction bar() {\n    return {\n        \"a\": 1,\n        \"b:\": 2\n    };\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-style: [\"error\", \"first\"]*/\n\nvar foo = 1, bar = 2;\n\nvar foo = 1\n    ,bar = 2;\n\nvar foo = [\"apples\"\n          ,\"oranges\"];\n\nfunction bar() {\n    return {\n        \"a\": 1\n        ,\"b:\": 2\n    };\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint comma-style: [\"error\", \"first\", { \"exceptions\": { \"ArrayExpression\": true, \"ObjectExpression\": true } }]*/\n\nvar o = {},\n    a = [];"
            },
            {
                "type": "correct",
                "content": "/*eslint comma-style: [\"error\", \"first\", { \"exceptions\": { \"ArrayExpression\": true, \"ObjectExpression\": true } }]*/\n\nvar o = {fst:1,\n         snd: [1,\n               2]}\n  , a = [];"
            }
        ]
    },
    {
        "name": "computed-property-spacing",
        "url": "https://eslint.org/docs/latest/rules/computed-property-spacing",
        "description": "Enforce consistent spacing inside computed property bracketsWhile formatting preferences are very personal, a number of style guides require or disallow spaces between computed properties in the following situations:This rule enforces consistent spacing inside computed property brackets.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint computed-property-spacing: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nobj[foo ]\nobj[ 'foo']\nvar x = {[ b ]: a}\nobj[foo[ bar ]]\n\nconst { [ a ]: someProp } = obj;\n({ [ b ]: anotherProp } = anotherObj);"
            },
            {
                "type": "correct",
                "content": "/*eslint computed-property-spacing: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nobj[foo]\nobj['foo']\nvar x = {[b]: a}\nobj[foo[bar]]\n\nconst { [a]: someProp } = obj;\n({ [b]: anotherProp } = anotherObj);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint computed-property-spacing: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nobj[foo]\nvar x = {[b]: a}\nobj[ foo]\nobj['foo' ]\nobj[foo[ bar ]]\nvar x = {[ b]: a}\nconst { [a]: someProp } = obj;\n({ [b ]: anotherProp } = anotherObj);"
            },
            {
                "type": "correct",
                "content": "/*eslint computed-property-spacing: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nobj[ foo ]\nobj[ 'foo' ]\nvar x = {[ b ]: a}\nobj[ foo[ bar ] ]\nconst { [ a ]: someProp } = obj;\n({ [ b ]: anotherProp } = anotherObj);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint computed-property-spacing: [\"error\", \"never\", { \"enforceForClassMembers\": true }]*/\n/*eslint-env es6*/\n\nclass Foo {\n  [a ]() {}\n  get [b ]() {}\n  set [b ](value) {}\n}\n\nconst Bar = class {\n  [ a](){}\n  static [ b]() {}\n  static get [ c ]() {}\n  static set [ c ](value) {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint computed-property-spacing: [\"error\", \"never\", { \"enforceForClassMembers\": true }]*/\n/*eslint-env es6*/\n\nclass Foo {\n  [a]() {}\n  get [b]() {}\n  set [b](value) {}\n}\n\nconst Bar = class {\n  [a](){}\n  static [b]() {}\n  static get [c]() {}\n  static set [c](value) {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint computed-property-spacing: [\"error\", \"never\", { \"enforceForClassMembers\": false }]*/\n/*eslint-env es6*/\n\nclass Foo {\n  [a ]() {}\n  get [b ]() {}\n  set [b ](value) {}\n}\n\nconst Bar = class {\n  [ a](){}\n  static [ b]() {}\n  static get [ c ]() {}\n  static set [ c ](value) {}\n}"
            }
        ]
    },
    {
        "name": "dot-location",
        "url": "https://eslint.org/docs/latest/rules/dot-location",
        "description": "Enforce consistent newlines before and after dotsJavaScript allows you to place newlines before or after a dot in a member expression.Consistency in placing a newline before or after the dot can greatly increase readability.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint dot-location: [\"error\", \"object\"]*/\n\nvar foo = object\n.property;"
            },
            {
                "type": "correct",
                "content": "/*eslint dot-location: [\"error\", \"object\"]*/\n\nvar foo = object.\nproperty;\n\nvar bar = (\n    object\n).\nproperty;\n\nvar baz = object.property;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint dot-location: [\"error\", \"property\"]*/\n\nvar foo = object.\nproperty;"
            },
            {
                "type": "correct",
                "content": "/*eslint dot-location: [\"error\", \"property\"]*/\n\nvar foo = object\n.property;\nvar bar = object.property;"
            }
        ]
    },
    {
        "name": "eol-last",
        "url": "https://eslint.org/docs/latest/rules/eol-last",
        "description": "Require or disallow newline at the end of filesTrailing newlines in non-empty files are a common UNIX idiom. Benefits of trailing newlines include the ability to concatenate or append to files as well as output files to the terminal without interfering with shell prompts.This rule enforces at least one newline (or absence thereof) at the end of non-empty files.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint eol-last: [\"error\", \"always\"]*/\n\nfunction doSomething() {\n  var foo = 2;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint eol-last: [\"error\", \"always\"]*/\n\nfunction doSomething() {\n  var foo = 2;\n}\\n"
            }
        ]
    },
    {
        "name": "func-call-spacing",
        "url": "https://eslint.org/docs/latest/rules/func-call-spacing",
        "description": "Require or disallow spacing between function identifiers and their invocationsWhen calling a function, developers may insert optional whitespace between the function’s name and the parentheses that invoke it. The following pairs of function calls are equivalent:This rule requires or disallows spaces between the function name and the opening parenthesis that calls it.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint func-call-spacing: [\"error\", \"never\"]*/\n\nfn ();\n\nfn\n();"
            },
            {
                "type": "correct",
                "content": "/*eslint func-call-spacing: [\"error\", \"never\"]*/\n\nfn();"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-call-spacing: [\"error\", \"always\"]*/\n\nfn();\n\nfn\n();"
            },
            {
                "type": "correct",
                "content": "/*eslint func-call-spacing: [\"error\", \"always\"]*/\n\nfn ();"
            },
            {
                "type": "incorrect",
                "content": "/*eslint func-call-spacing: [\"error\", \"always\", { \"allowNewlines\": true }]*/\n\nfn();"
            },
            {
                "type": "correct",
                "content": "/*eslint func-call-spacing: [\"error\", \"always\", { \"allowNewlines\": true }]*/\n\nfn (); // Newlines are never required.\n\nfn\n();"
            }
        ]
    },
    {
        "name": "function-call-argument-newline",
        "url": "https://eslint.org/docs/latest/rules/function-call-argument-newline",
        "description": "Enforce line breaks between arguments of a function callA number of style guides require or disallow line breaks between arguments of a function call.This rule enforces line breaks between arguments of a function call.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint function-call-argument-newline: [\"error\", \"always\"]*/\n\nfoo(\"one\", \"two\", \"three\");\n\nbar(\"one\", \"two\", {\n    one: 1,\n    two: 2\n});\n\nbaz(\"one\", \"two\", (x) => {\n    console.log(x);\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint function-call-argument-newline: [\"error\", \"always\"]*/\n\nfoo(\n    \"one\",\n    \"two\",\n    \"three\"\n);\n\nbar(\n    \"one\",\n    \"two\",\n    { one: 1, two: 2 }\n);\n// or\nbar(\n    \"one\",\n    \"two\",\n    {\n        one: 1,\n        two: 2\n    }\n);\n\nbaz(\n    \"one\",\n    \"two\",\n    (x) => {\n        console.log(x);\n    }\n);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint function-call-argument-newline: [\"error\", \"never\"]*/\n\nfoo(\n    \"one\",\n    \"two\", \"three\"\n);\n\nbar(\n    \"one\",\n    \"two\", {\n        one: 1,\n        two: 2\n    }\n);\n\nbaz(\n    \"one\",\n    \"two\", (x) => {\n        console.log(x);\n    }\n);"
            },
            {
                "type": "correct",
                "content": "/*eslint function-call-argument-newline: [\"error\", \"never\"]*/\n\nfoo(\"one\", \"two\", \"three\");\n// or\nfoo(\n    \"one\", \"two\", \"three\"\n);\n\nbar(\"one\", \"two\", { one: 1, two: 2 });\n// or\nbar(\"one\", \"two\", {\n    one: 1,\n    two: 2\n});\n\nbaz(\"one\", \"two\", (x) => {\n    console.log(x);\n});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint function-call-argument-newline: [\"error\", \"consistent\"]*/\n\nfoo(\"one\", \"two\",\n    \"three\");\n//or\nfoo(\"one\",\n    \"two\", \"three\");\n\nbar(\"one\", \"two\",\n    { one: 1, two: 2}\n);\n\nbaz(\"one\", \"two\",\n    (x) => { console.log(x); }\n);"
            },
            {
                "type": "correct",
                "content": "/*eslint function-call-argument-newline: [\"error\", \"consistent\"]*/\n\nfoo(\"one\", \"two\", \"three\");\n// or\nfoo(\n    \"one\",\n    \"two\",\n    \"three\"\n);\n\nbar(\"one\", \"two\", {\n    one: 1,\n    two: 2\n});\n// or\nbar(\n    \"one\",\n    \"two\",\n    { one: 1, two: 2 }\n);\n// or\nbar(\n    \"one\",\n    \"two\",\n    {\n        one: 1,\n        two: 2\n    }\n);\n\nbaz(\"one\", \"two\", (x) => {\n    console.log(x);\n});\n// or\nbaz(\n    \"one\",\n    \"two\",\n    (x) => {\n        console.log(x);\n    }\n);"
            }
        ]
    },
    {
        "name": "function-paren-newline",
        "url": "https://eslint.org/docs/latest/rules/function-paren-newline",
        "description": "Enforce consistent line breaks inside function parenthesesMany style guides require or disallow newlines inside of function parentheses.This rule enforces consistent line breaks inside parentheses of function parameters or arguments.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint function-paren-newline: [\"error\", \"always\"] */\n\nfunction foo(bar, baz) {}\n\nvar foo = function(bar, baz) {};\n\nvar foo = (bar, baz) => {};\n\nfoo(bar, baz);"
            },
            {
                "type": "correct",
                "content": "/* eslint function-paren-newline: [\"error\", \"always\"] */\n\nfunction foo(\n  bar,\n  baz\n) {}\n\nvar foo = function(\n  bar, baz\n) {};\n\nvar foo = (\n  bar,\n  baz\n) => {};\n\nfoo(\n  bar,\n  baz\n);"
            },
            {
                "type": "incorrect",
                "content": "/* eslint function-paren-newline: [\"error\", \"never\"] */\n\nfunction foo(\n  bar,\n  baz\n) {}\n\nvar foo = function(\n  bar, baz\n) {};\n\nvar foo = (\n  bar,\n  baz\n) => {};\n\nfoo(\n  bar,\n  baz\n);"
            },
            {
                "type": "correct",
                "content": "/* eslint function-paren-newline: [\"error\", \"never\"] */\n\nfunction foo(bar, baz) {}\n\nfunction foo(bar,\n             baz) {}\n\nvar foo = function(bar, baz) {};\n\nvar foo = (bar, baz) => {};\n\nfoo(bar, baz);\n\nfoo(bar,\n  baz);"
            },
            {
                "type": "incorrect",
                "content": "/* eslint function-paren-newline: [\"error\", \"multiline\"] */\n\nfunction foo(bar,\n  baz\n) {}\n\nvar foo = function(\n  bar, baz\n) {};\n\nvar foo = (\n  bar,\n  baz) => {};\n\nfoo(bar,\n  baz);\n\nfoo(\n  function() {\n    return baz;\n  }\n);"
            },
            {
                "type": "correct",
                "content": "/* eslint function-paren-newline: [\"error\", \"multiline\"] */\n\nfunction foo(bar, baz) {}\n\nvar foo = function(\n  bar,\n  baz\n) {};\n\nvar foo = (bar, baz) => {};\n\nfoo(bar, baz, qux);\n\nfoo(\n  bar,\n  baz,\n  qux\n);\n\nfoo(function() {\n  return baz;\n});"
            },
            {
                "type": "incorrect",
                "content": "/* eslint function-paren-newline: [\"error\", \"consistent\"] */\n\nfunction foo(bar,\n  baz\n) {}\n\nvar foo = function(bar,\n  baz\n) {};\n\nvar foo = (\n  bar,\n  baz) => {};\n\nfoo(\n  bar,\n  baz);\n\nfoo(\n  function() {\n    return baz;\n  });"
            },
            {
                "type": "correct",
                "content": "/* eslint function-paren-newline: [\"error\", \"consistent\"] */\n\nfunction foo(bar,\n  baz) {}\n\nvar foo = function(bar, baz) {};\n\nvar foo = (\n  bar,\n  baz\n) => {};\n\nfoo(\n  bar, baz\n);\n\nfoo(\n  function() {\n    return baz;\n  }\n);"
            },
            {
                "type": "incorrect",
                "content": "/* eslint function-paren-newline: [\"error\", \"multiline-arguments\"] */\n\nfunction foo(bar,\n  baz\n) {}\n\nvar foo = function(bar,\n  baz\n) {};\n\nvar foo = (\n  bar,\n  baz) => {};\n\nfoo(\n  bar,\n  baz);\n\nfoo(\n  bar, qux,\n  baz\n);"
            },
            {
                "type": "correct",
                "content": "/* eslint function-paren-newline: [\"error\", \"multiline-arguments\"] */\n\nfunction foo(\n  bar,\n  baz\n) {}\n\nvar foo = function(bar, baz) {};\n\nvar foo = (\n  bar\n) => {};\n\nfoo(\n  function() {\n    return baz;\n  }\n);"
            },
            {
                "type": "incorrect",
                "content": "/* eslint function-paren-newline: [\"error\", { \"minItems\": 3 }] */\n\nfunction foo(\n  bar,\n  baz\n) {}\n\nfunction foo(bar, baz, qux) {}\n\nvar foo = function(\n  bar, baz\n) {};\n\nvar foo = (bar,\n  baz) => {};\n\nfoo(bar,\n  baz);"
            },
            {
                "type": "correct",
                "content": "/* eslint function-paren-newline: [\"error\", { \"minItems\": 3 }] */\n\nfunction foo(bar, baz) {}\n\nvar foo = function(\n  bar,\n  baz,\n  qux\n) {};\n\nvar foo = (\n  bar, baz, qux\n) => {};\n\nfoo(bar, baz);\n\nfoo(\n  bar, baz, qux\n);"
            }
        ]
    },
    {
        "name": "generator-star-spacing",
        "url": "https://eslint.org/docs/latest/rules/generator-star-spacing",
        "description": "Enforce consistent spacing around * operators in generator functionsGenerators are a new type of function in ECMAScript 6 that can return multiple values over time. These special functions are indicated by placing an * after the function keyword.Here is an example of a generator function:",
        "examples": [
            {
                "type": "correct",
                "content": "/*eslint generator-star-spacing: [\"error\", {\"before\": true, \"after\": false}]*/\n/*eslint-env es6*/\n\nfunction *generator() {}\n\nvar anonymous = function *() {};\n\nvar shorthand = { *generator() {} };"
            },
            {
                "type": "correct",
                "content": "/*eslint generator-star-spacing: [\"error\", {\"before\": false, \"after\": true}]*/\n/*eslint-env es6*/\n\nfunction* generator() {}\n\nvar anonymous = function* () {};\n\nvar shorthand = { * generator() {} };"
            },
            {
                "type": "correct",
                "content": "/*eslint generator-star-spacing: [\"error\", {\"before\": true, \"after\": true}]*/\n/*eslint-env es6*/\n\nfunction * generator() {}\n\nvar anonymous = function * () {};\n\nvar shorthand = { * generator() {} };"
            },
            {
                "type": "correct",
                "content": "/*eslint generator-star-spacing: [\"error\", {\"before\": false, \"after\": false}]*/\n/*eslint-env es6*/\n\nfunction*generator() {}\n\nvar anonymous = function*() {};\n\nvar shorthand = { *generator() {} };"
            },
            {
                "type": "incorrect",
                "content": "/*eslint generator-star-spacing: [\"error\", {\n    \"before\": false,\n    \"after\": true,\n    \"anonymous\": \"neither\",\n    \"method\": {\"before\": true, \"after\": true}\n}]*/\n/*eslint-env es6*/\n\nfunction * generator() {}\n\nvar anonymous = function* () {};\n\nvar shorthand = { *generator() {} };\n\nclass Class { static* method() {} }"
            },
            {
                "type": "correct",
                "content": "/*eslint generator-star-spacing: [\"error\", {\n    \"before\": false,\n    \"after\": true,\n    \"anonymous\": \"neither\",\n    \"method\": {\"before\": true, \"after\": true}\n}]*/\n/*eslint-env es6*/\n\nfunction* generator() {}\n\nvar anonymous = function*() {};\n\nvar shorthand = { * generator() {} };\n\nclass Class { static * method() {} }"
            }
        ]
    },
    {
        "name": "implicit-arrow-linebreak",
        "url": "https://eslint.org/docs/latest/rules/implicit-arrow-linebreak",
        "description": "Enforce the location of arrow function bodiesAn arrow function body can contain an implicit return as an expression instead of a block body. It can be useful to enforce a consistent location for the implicitly returned expression.This rule aims to enforce a consistent location for an arrow function containing an implicit return.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint implicit-arrow-linebreak: [\"error\", \"beside\"] */\n\n(foo) =>\n  bar;\n\n(foo) =>\n  (bar);\n\n(foo) =>\n  bar =>\n    baz;\n\n(foo) =>\n(\n  bar()\n);"
            },
            {
                "type": "correct",
                "content": "/* eslint implicit-arrow-linebreak: [\"error\", \"beside\"] */\n\n(foo) => bar;\n\n(foo) => (bar);\n\n(foo) => bar => baz;\n\n(foo) => (\n  bar()\n);\n\n// functions with block bodies allowed with this rule using any style\n// to enforce a consistent location for this case, see the rule: `brace-style`\n(foo) => {\n  return bar();\n}\n\n(foo) =>\n{\n  return bar();\n}"
            },
            {
                "type": "incorrect",
                "content": "/* eslint implicit-arrow-linebreak: [\"error\", \"below\"] */\n\n(foo) => bar;\n\n(foo) => (bar);\n\n(foo) => bar => baz;"
            },
            {
                "type": "correct",
                "content": "/* eslint implicit-arrow-linebreak: [\"error\", \"below\"] */\n\n(foo) =>\n  bar;\n\n(foo) =>\n  (bar);\n\n(foo) =>\n  bar =>\n    baz;"
            }
        ]
    },
    {
        "name": "indent",
        "url": "https://eslint.org/docs/latest/rules/indent",
        "description": "Enforce consistent indentationThere are several common guidelines which require specific indentation of nested blocks and statements, like:These are the most common scenarios recommended in different style guides:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint indent: \"error\"*/\n\nif (a) {\n  b=c;\n  function foo(d) {\n    e=f;\n  }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: \"error\"*/\n\nif (a) {\n    b=c;\n    function foo(d) {\n        e=f;\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", \"tab\"]*/\n\nif (a) {\n     b=c;\nfunction foo(d) {\n           e=f;\n }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", \"tab\"]*/\n\nif (a) {\n/*tab*/b=c;\n/*tab*/function foo(d) {\n/*tab*//*tab*/e=f;\n/*tab*/}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 4, { \"ignoredNodes\": [\"ConditionalExpression\"] }]*/\n\nvar a = foo\n      ? bar\n      : baz;\n\nvar a = foo\n                ? bar\n: baz;"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 4, { \"ignoredNodes\": [\"CallExpression > FunctionExpression.callee > BlockStatement.body\"] }]*/\n\n(function() {\n\nfoo();\nbar();\n\n})"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"SwitchCase\": 1 }]*/\n\nswitch(a){\ncase \"a\":\n    break;\ncase \"b\":\n    break;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"SwitchCase\": 1 }]*/\n\nswitch(a){\n  case \"a\":\n    break;\n  case \"b\":\n    break;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": 1 }]*/\n/*eslint-env es6*/\n\nvar a,\n    b,\n    c;\nlet a,\n    b,\n    c;\nconst a = 1,\n    b = 2,\n    c = 3;"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": 1 }]*/\n/*eslint-env es6*/\n\nvar a,\n  b,\n  c;\nlet a,\n  b,\n  c;\nconst a = 1,\n  b = 2,\n  c = 3;"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": 2 }]*/\n/*eslint-env es6*/\n\nvar a,\n    b,\n    c;\nlet a,\n    b,\n    c;\nconst a = 1,\n    b = 2,\n    c = 3;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": \"first\" }]*/\n/*eslint-env es6*/\n\nvar a,\n  b,\n  c;\nlet a,\n  b,\n  c;\nconst a = 1,\n  b = 2,\n  c = 3;"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": \"first\" }]*/\n/*eslint-env es6*/\n\nvar a,\n    b,\n    c;\nlet a,\n    b,\n    c;\nconst a = 1,\n      b = 2,\n      c = 3;"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": { \"var\": 2, \"let\": 2, \"const\": 3 } }]*/\n/*eslint-env es6*/\n\nvar a,\n    b,\n    c;\nlet a,\n    b,\n    c;\nconst a = 1,\n      b = 2,\n      c = 3;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"outerIIFEBody\": 0 }]*/\n\n(function() {\n\n  function foo(x) {\n    return x + 1;\n  }\n\n})();\n\nif (y) {\nconsole.log('foo');\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"outerIIFEBody\": 0 }]*/\n\n(function() {\n\nfunction foo(x) {\n  return x + 1;\n}\n\n})();\n\nif (y) {\n   console.log('foo');\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"outerIIFEBody\": \"off\" }]*/\n\n(function() {\n\nfunction foo(x) {\n  return x + 1;\n}\n\n})();\n\n(function() {\n\n  function foo(x) {\n    return x + 1;\n  }\n\n})();\n\nif (y) {\n  console.log('foo');\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"MemberExpression\": 1 }]*/\n\nfoo\n.bar\n.baz()"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"MemberExpression\": 1 }]*/\n\nfoo\n  .bar\n  .baz();"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} }]*/\n\nfunction foo(bar,\n  baz,\n  qux) {\n    qux();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} }]*/\n\nfunction foo(bar,\n    baz,\n    qux) {\n  qux();\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, {\"FunctionDeclaration\": {\"parameters\": \"first\"}}]*/\n\nfunction foo(bar, baz,\n  qux, boop) {\n  qux();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, {\"FunctionDeclaration\": {\"parameters\": \"first\"}}]*/\n\nfunction foo(bar, baz,\n             qux, boop) {\n  qux();\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} }]*/\n\nvar foo = function(bar,\n  baz,\n  qux) {\n    qux();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} }]*/\n\nvar foo = function(bar,\n    baz,\n    qux) {\n  qux();\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, {\"FunctionExpression\": {\"parameters\": \"first\"}}]*/\n\nvar foo = function(bar, baz,\n  qux, boop) {\n  qux();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, {\"FunctionExpression\": {\"parameters\": \"first\"}}]*/\n\nvar foo = function(bar, baz,\n                   qux, boop) {\n  qux();\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"StaticBlock\": {\"body\": 1} }]*/\n\nclass C {\n  static {\n      foo();\n  }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"StaticBlock\": {\"body\": 1} }]*/\n\nclass C {\n  static {\n    foo();\n  }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"StaticBlock\": {\"body\": 2} }]*/\n\nclass C {\n  static {\n    foo();\n  }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"StaticBlock\": {\"body\": 2} }]*/\n\nclass C {\n  static {\n      foo();\n  }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"CallExpression\": {\"arguments\": 1} }]*/\n\nfoo(bar,\n    baz,\n      qux\n);"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"CallExpression\": {\"arguments\": 1} }]*/\n\nfoo(bar,\n  baz,\n  qux\n);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, {\"CallExpression\": {\"arguments\": \"first\"}}]*/\n\nfoo(bar, baz,\n  baz, boop, beep);"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, {\"CallExpression\": {\"arguments\": \"first\"}}]*/\n\nfoo(bar, baz,\n    baz, boop, beep);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"ArrayExpression\": 1 }]*/\n\nvar foo = [\n    bar,\nbaz,\n      qux\n];"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"ArrayExpression\": 1 }]*/\n\nvar foo = [\n  bar,\n  baz,\n  qux\n];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, {\"ArrayExpression\": \"first\"}]*/\n\nvar foo = [bar,\n  baz,\n  qux\n];"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, {\"ArrayExpression\": \"first\"}]*/\n\nvar foo = [bar,\n           baz,\n           qux\n];"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"ObjectExpression\": 1 }]*/\n\nvar foo = {\n    bar: 1,\nbaz: 2,\n      qux: 3\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"ObjectExpression\": 1 }]*/\n\nvar foo = {\n  bar: 1,\n  baz: 2,\n  qux: 3\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, {\"ObjectExpression\": \"first\"}]*/\n\nvar foo = { bar: 1,\n  baz: 2 };"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, {\"ObjectExpression\": \"first\"}]*/\n\nvar foo = { bar: 1,\n            baz: 2 };"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 4, { \"ImportDeclaration\": 1 }]*/\n\nimport { foo,\n    bar,\n    baz,\n} from 'qux';\n\nimport {\n    foo,\n    bar,\n    baz,\n} from 'qux';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 4, { \"ImportDeclaration\": \"first\" }]*/\n\nimport { foo,\n    bar,\n    baz,\n} from 'qux';"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 4, { \"ImportDeclaration\": \"first\" }]*/\n\nimport { foo,\n         bar,\n         baz,\n} from 'qux';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 4, { \"flatTernaryExpressions\": false }]*/\n\nvar a =\n    foo ? bar :\n    baz ? qux :\n    boop;"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 4, { \"flatTernaryExpressions\": false }]*/\n\nvar a =\n    foo ? bar :\n        baz ? qux :\n            boop;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 4, { \"flatTernaryExpressions\": true }]*/\n\nvar a =\n    foo ? bar :\n        baz ? qux :\n            boop;"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 4, { \"flatTernaryExpressions\": true }]*/\n\nvar a =\n    foo ? bar :\n    baz ? qux :\n    boop;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"offsetTernaryExpressions\": false }]*/\n\ncondition\n  ? () => {\n      return true\n    }\n  : () => {\n      false\n    }"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"offsetTernaryExpressions\": false }]*/\n\ncondition\n  ? () => {\n    return true\n  }\n  : condition2\n    ? () => {\n      return true\n    }\n    : () => {\n      return false\n    }"
            },
            {
                "type": "incorrect",
                "content": "/*eslint indent: [\"error\", 2, { \"offsetTernaryExpressions\": true }]*/\n\ncondition\n  ? () => {\n    return true\n  }\n  : condition2\n    ? () => {\n      return true\n    }\n    : () => {\n      return false\n    }"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 2, { \"offsetTernaryExpressions\": true }]*/\n\ncondition\n  ? () => {\n      return true\n    }\n  : condition2\n    ? () => {\n        return true\n      }\n    : () => {\n        return false\n      }"
            },
            {
                "type": "correct",
                "content": "/*eslint indent: [\"error\", 4, { \"ignoreComments\": true }] */\n\nif (foo) {\n    doSomething();\n\n// comment intentionally de-indented\n    doSomethingElse();\n}"
            }
        ]
    },
    {
        "name": "jsx-quotes",
        "url": "https://eslint.org/docs/latest/rules/jsx-quotes",
        "description": "Enforce the consistent use of either double or single quotes in JSX attributesJSX attribute values can contain string literals, which are delimited with single or double quotes.Unlike string literals in JavaScript, string literals within JSX attributes can’t contain escaped quotes. If you want to have e.g. a double quote within a JSX attribute value, you have to use single quotes as string delimiter.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint jsx-quotes: [\"error\", \"prefer-double\"]*/\n\n<a b='c' />"
            },
            {
                "type": "correct",
                "content": "/*eslint jsx-quotes: [\"error\", \"prefer-double\"]*/\n\n<a b=\"c\" />\n<a b='\"' />"
            },
            {
                "type": "incorrect",
                "content": "/*eslint jsx-quotes: [\"error\", \"prefer-single\"]*/\n\n<a b=\"c\" />"
            },
            {
                "type": "correct",
                "content": "/*eslint jsx-quotes: [\"error\", \"prefer-single\"]*/\n\n<a b='c' />\n<a b=\"'\" />"
            }
        ]
    },
    {
        "name": "key-spacing",
        "url": "https://eslint.org/docs/latest/rules/key-spacing",
        "description": "Enforce consistent spacing between keys and values in object literal propertiesThis rule enforces spacing around the colon in object literal properties. It can verify each property individually, or it can ensure horizontal alignment of adjacent properties in an object literal.This rule enforces consistent spacing between keys and values in object literal properties. In the case of long lines, it is acceptable to add a new line wherever whitespace is allowed.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint key-spacing: [\"error\", { \"beforeColon\": false }]*/\n\nvar obj = { \"foo\" : 42 };"
            },
            {
                "type": "correct",
                "content": "/*eslint key-spacing: [\"error\", { \"beforeColon\": false }]*/\n\nvar obj = { \"foo\": 42 };"
            },
            {
                "type": "incorrect",
                "content": "/*eslint key-spacing: [\"error\", { \"beforeColon\": true }]*/\n\nvar obj = { \"foo\": 42 };"
            },
            {
                "type": "correct",
                "content": "/*eslint key-spacing: [\"error\", { \"beforeColon\": true }]*/\n\nvar obj = { \"foo\" : 42 };"
            },
            {
                "type": "incorrect",
                "content": "/*eslint key-spacing: [\"error\", { \"afterColon\": true }]*/\n\nvar obj = { \"foo\":42 };"
            },
            {
                "type": "correct",
                "content": "/*eslint key-spacing: [\"error\", { \"afterColon\": true }]*/\n\nvar obj = { \"foo\": 42 };"
            },
            {
                "type": "incorrect",
                "content": "/*eslint key-spacing: [\"error\", { \"afterColon\": false }]*/\n\nvar obj = { \"foo\": 42 };"
            },
            {
                "type": "correct",
                "content": "/*eslint key-spacing: [\"error\", { \"afterColon\": false }]*/\n\nvar obj = { \"foo\":42 };"
            },
            {
                "type": "incorrect",
                "content": "/*eslint key-spacing: [\"error\", { \"mode\": \"strict\" }]*/\n\ncall({\n    foobar: 42,\n    bat:    2 * 2\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint key-spacing: [\"error\", { \"mode\": \"strict\" }]*/\n\ncall({\n    foobar: 42,\n    bat: 2 * 2\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint key-spacing: [\"error\", { \"mode\": \"minimum\" }]*/\n\ncall({\n    foobar: 42,\n    bat:    2 * 2\n});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint key-spacing: [\"error\", { \"align\": \"value\" }]*/\n\nvar obj = {\n    a: value,\n    bcde:  42,\n    fg :   foo()\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint key-spacing: [\"error\", { \"align\": \"value\" }]*/\n\nvar obj = {\n    a:    value,\n    bcde: 42,\n\n    fg: foo(),\n    h:  function() {\n        return this.a;\n    },\n    ijkl: 'Non-consecutive lines form a new group'\n};\n\nvar obj = { a: \"foo\", longPropertyName: \"bar\" };"
            },
            {
                "type": "incorrect",
                "content": "/*eslint key-spacing: [\"error\", { \"align\": \"colon\" }]*/\n\ncall({\n    foobar: 42,\n    bat:    2 * 2\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint key-spacing: [\"error\", { \"align\": \"colon\" }]*/\n\ncall({\n    foobar: 42,\n    bat   : 2 * 2\n});"
            },
            {
                "type": "correct",
                "content": "/*eslint key-spacing: [\"error\", {\n    \"align\": {\n        \"beforeColon\": true,\n        \"afterColon\": true,\n        \"on\": \"colon\"\n    }\n}]*/\n\nvar obj = {\n    \"one\"   : 1,\n    \"seven\" : 7\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint key-spacing: [\"error\", {\n    \"align\": {\n        \"beforeColon\": false,\n        \"afterColon\": false,\n        \"on\": \"value\"\n    }\n}]*/\n\nvar obj = {\n    \"one\":  1,\n    \"seven\":7\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint key-spacing: [\"error\", {\n    \"multiLine\": {\n        \"beforeColon\": false,\n        \"afterColon\":true\n    },\n    \"align\": {\n        \"beforeColon\": true,\n        \"afterColon\": true,\n        \"on\": \"colon\"\n    }\n}]*/\n\nvar obj = {\n    \"myObjectFunction\": function() {\n        // Do something\n    },\n    \"one\"             : 1,\n    \"seven\"           : 7\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint key-spacing: [\"error\", {\n    \"multiLine\": {\n        \"beforeColon\": false,\n        \"afterColon\": true\n\n    },\n    \"align\": {\n        \"beforeColon\": true,\n        \"afterColon\": true,\n        \"on\": \"colon\"\n    }\n}]*/\n\nvar obj = {\n    \"myObjectFunction\": function() {\n        // Do something\n        //\n    }, // These are two separate groups, so no alignment between `myObjectFunction` and `one`\n    \"one\"   : 1,\n    \"seven\" : 7 // `one` and `seven` are in their own group, and therefore aligned\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint \"key-spacing\": [2, {\n    \"singleLine\": {\n        \"beforeColon\": false,\n        \"afterColon\": true\n    },\n    \"multiLine\": {\n        \"beforeColon\": true,\n        \"afterColon\": true,\n        \"align\": \"colon\"\n    }\n}]*/\nvar obj = { one: 1, \"two\": 2, three: 3 };\nvar obj2 = {\n    \"two\" : 2,\n    three : 3\n};"
            }
        ]
    },
    {
        "name": "keyword-spacing",
        "url": "https://eslint.org/docs/latest/rules/keyword-spacing",
        "description": "Enforce consistent spacing before and after keywordsKeywords are syntax elements of JavaScript, such as try and if. These keywords have special meaning to the language and so often appear in a different color in code editors. As an important part of the language, style guides often refer to the spacing that should be used around keywords. For example, you might have a style guide that says keywords should be always surrounded by spaces, which would mean if-else statements must look like this:Of course, you could also have a style guide that disallows spaces around keywords.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint keyword-spacing: [\"error\", { \"before\": true }]*/\n\nif (foo) {\n    //...\n}else if (bar) {\n    //...\n}else {\n    //...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint keyword-spacing: [\"error\", { \"before\": true }]*/\n/*eslint-env es6*/\n\nif (foo) {\n    //...\n} else if (bar) {\n    //...\n} else {\n    //...\n}\n\n// Avoid conflict with `array-bracket-spacing`\nlet a = [this];\nlet b = [function() {}];\n\n// Avoid conflict with `arrow-spacing`\nlet a = ()=> this.foo;\n\n// Avoid conflict with `block-spacing`\n{function foo() {}}\n\n// Avoid conflict with `comma-spacing`\nlet a = [100,this.foo, this.bar];\n\n// Avoid conflict with `computed-property-spacing`\nobj[this.foo] = 0;\n\n// Avoid conflict with `generator-star-spacing`\nfunction *foo() {}\n\n// Avoid conflict with `key-spacing`\nlet obj = {\n    foo:function() {}\n};\n\n// Avoid conflict with `object-curly-spacing`\nlet obj = {foo: this};\n\n// Avoid conflict with `semi-spacing`\nlet a = this;function foo() {}\n\n// Avoid conflict with `space-in-parens`\n(function () {})();\n\n// Avoid conflict with `space-infix-ops`\nif (\"foo\"in {foo: 0}) {}\nif (10+this.foo<= this.bar) {}\n\n// Avoid conflict with `jsx-curly-spacing`\nlet a = <A foo={this.foo} bar={function(){}} />"
            },
            {
                "type": "incorrect",
                "content": "/*eslint keyword-spacing: [\"error\", { \"before\": false }]*/\n\nif (foo) {\n    //...\n} else if (bar) {\n    //...\n} else {\n    //...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint keyword-spacing: [\"error\", { \"before\": false }]*/\n\nif (foo) {\n    //...\n}else if (bar) {\n    //...\n}else {\n    //...\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint keyword-spacing: [\"error\", { \"after\": true }]*/\n\nif(foo) {\n    //...\n} else if(bar) {\n    //...\n} else{\n    //...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint keyword-spacing: [\"error\", { \"after\": true }]*/\n\nif (foo) {\n    //...\n} else if (bar) {\n    //...\n} else {\n    //...\n}\n\n// Avoid conflict with `array-bracket-spacing`\nlet a = [this];\n\n// Avoid conflict with `arrow-spacing`\nlet a = ()=> this.foo;\n\n// Avoid conflict with `comma-spacing`\nlet a = [100, this.foo, this.bar];\n\n// Avoid conflict with `computed-property-spacing`\nobj[this.foo] = 0;\n\n// Avoid conflict with `generator-star-spacing`\nfunction* foo() {}\n\n// Avoid conflict with `key-spacing`\nlet obj = {\n    foo:function() {}\n};\n\n// Avoid conflict with `func-call-spacing`\nclass A {\n    constructor() {\n        super();\n    }\n}\n\n// Avoid conflict with `object-curly-spacing`\nlet obj = {foo: this};\n\n// Avoid conflict with `semi-spacing`\nlet a = this;function foo() {}\n\n// Avoid conflict with `space-before-function-paren`\nfunction() {}\n\n// Avoid conflict with `space-infix-ops`\nif (\"foo\"in{foo: 0}) {}\nif (10+this.foo<= this.bar) {}\n\n// Avoid conflict with `space-unary-ops`\nfunction* foo(a) {\n    return yield+a;\n}\n\n// Avoid conflict with `yield-star-spacing`\nfunction* foo(a) {\n    return yield* a;\n}\n\n// Avoid conflict with `jsx-curly-spacing`\nlet a = <A foo={this.foo} bar={function(){}} />"
            },
            {
                "type": "incorrect",
                "content": "/*eslint keyword-spacing: [\"error\", { \"after\": false }]*/\n\nif (foo) {\n    //...\n} else if (bar) {\n    //...\n} else {\n    //...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint keyword-spacing: [\"error\", { \"after\": false }]*/\n\nif(foo) {\n    //...\n} else if(bar) {\n    //...\n} else{\n    //...\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint keyword-spacing: [\"error\", { \"overrides\": {\n  \"if\": { \"after\": false },\n  \"for\": { \"after\": false },\n  \"while\": { \"after\": false },\n  \"static\": { \"after\": false },\n  \"as\": { \"after\": false }\n} }]*/\n\nif(foo) {\n    //...\n} else if(bar) {\n    //...\n} else {\n    //...\n}\n\nfor(;;);\n\nwhile(true) {\n    //...\n}\n\nclass C {\n    static{\n        //...\n    }\n}\n\nexport { C as\"my class\" };"
            }
        ]
    },
    {
        "name": "line-comment-position",
        "url": "https://eslint.org/docs/latest/rules/line-comment-position",
        "description": "Enforce position of line commentsLine comments can be positioned above or beside code. This rule helps teams maintain a consistent style.This rule enforces consistent position of line comments. Block comments are not affected by this rule. By default, this rule ignores comments starting with the following words: eslint, jshint, jslint, istanbul, global, exported, jscs, falls through.",
        "examples": [
            {
                "type": "correct",
                "content": "/*eslint line-comment-position: [\"error\", { \"position\": \"above\" }]*/\n// valid comment\n1 + 1;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint line-comment-position: [\"error\", { \"position\": \"above\" }]*/\n1 + 1; // invalid comment"
            },
            {
                "type": "correct",
                "content": "/*eslint line-comment-position: [\"error\", { \"position\": \"beside\" }]*/\n1 + 1; // valid comment"
            },
            {
                "type": "incorrect",
                "content": "/*eslint line-comment-position: [\"error\", { \"position\": \"beside\" }]*/\n// invalid comment\n1 + 1;"
            },
            {
                "type": "correct",
                "content": "/*eslint line-comment-position: [\"error\", { \"ignorePattern\": \"pragma\" }]*/\n1 + 1; // pragma valid comment"
            },
            {
                "type": "incorrect",
                "content": "/*eslint line-comment-position: [\"error\", { \"ignorePattern\": \"pragma\" }]*/\n1 + 1; // invalid comment"
            },
            {
                "type": "correct",
                "content": "/*eslint line-comment-position: [\"error\", { \"ignorePattern\": \"pragma\", \"applyDefaultIgnorePatterns\": false }]*/\n1 + 1; // pragma valid comment"
            },
            {
                "type": "incorrect",
                "content": "/*eslint line-comment-position: [\"error\", { \"ignorePattern\": \"pragma\", \"applyDefaultIgnorePatterns\": false }]*/\n1 + 1; // falls through"
            }
        ]
    },
    {
        "name": "linebreak-style",
        "url": "https://eslint.org/docs/latest/rules/linebreak-style",
        "description": "Enforce consistent linebreak styleWhen developing with a lot of people all having different editors, VCS applications and operating systems it may occur that different line endings are written by either of the mentioned (might especially happen when using the windows and mac versions of SourceTree together).The linebreaks (new lines) used in windows operating system are usually carriage returns (CR) followed by a line feed (LF) making it a carriage return line feed (CRLF) whereas Linux and Unix use a simple line feed (LF). The corresponding control sequences are \"\\n\" (for LF) and \"\\r\\n\" for (CRLF).",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint linebreak-style: [\"error\", \"unix\"]*/\n\nvar a = 'a'; // \\r\\n\n"
            },
            {
                "type": "correct",
                "content": "/*eslint linebreak-style: [\"error\", \"unix\"]*/\n\nvar a = 'a', // \\n\n    b = 'b'; // \\n\n// \\n\nfunction foo(params) { // \\n\n    // do stuff \\n\n}// \\n"
            },
            {
                "type": "incorrect",
                "content": "/*eslint linebreak-style: [\"error\", \"windows\"]*/\n\nvar a = 'a'; // \\n"
            },
            {
                "type": "correct",
                "content": "/*eslint linebreak-style: [\"error\", \"windows\"]*/\n\nvar a = 'a', // \\r\\n\n    b = 'b'; // \\r\\n\n// \\r\\n\nfunction foo(params) { // \\r\\n\n    // do stuff \\r\\n\n} // \\r\\n"
            }
        ]
    },
    {
        "name": "lines-around-comment",
        "url": "https://eslint.org/docs/latest/rules/lines-around-comment",
        "description": "Require empty lines around commentsMany style guides require empty lines before or after comments. The primary goal of these rules is to make the comments easier to read and improve readability of the code.This rule requires empty lines before and/or after comments. It can be enabled separately for both block (/*) and line (//) comments. This rule does not apply to comments that appear on the same line as code and does not require empty lines at the beginning or end of a file.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true }]*/\n\nvar night = \"long\";\n/* what a great and wonderful day */\nvar day = \"great\""
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true }]*/\n\nvar night = \"long\";\n\n/* what a great and wonderful day */\nvar day = \"great\""
            },
            {
                "type": "incorrect",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterBlockComment\": true }]*/\n\nvar night = \"long\";\n\n/* what a great and wonderful day */\nvar day = \"great\""
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterBlockComment\": true }]*/\n\nvar night = \"long\";\n\n/* what a great and wonderful day */\n\nvar day = \"great\""
            },
            {
                "type": "incorrect",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true }]*/\n\nvar night = \"long\";\n// what a great and wonderful day\nvar day = \"great\""
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true }]*/\n\nvar night = \"long\";\n\n// what a great and wonderful day\nvar day = \"great\""
            },
            {
                "type": "incorrect",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterLineComment\": true }]*/\n\nvar night = \"long\";\n// what a great and wonderful day\nvar day = \"great\""
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterLineComment\": true }]*/\n\nvar night = \"long\";\n// what a great and wonderful day\n\nvar day = \"great\""
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true, \"allowBlockStart\": true }]*/\n\nfunction foo(){\n    // what a great and wonderful day\n    var day = \"great\"\n    return day;\n}\n\nif (bar) {\n    // what a great and wonderful day\n    foo();\n}\n\nclass C {\n    // what a great and wonderful day\n\n    method() {\n        // what a great and wonderful day\n        foo();\n    }\n\n    static {\n        // what a great and wonderful day\n        foo();\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true, \"allowBlockStart\": true }]*/\n\nfunction foo(){\n    /* what a great and wonderful day */\n    var day = \"great\"\n    return day;\n}\n\nif (bar) {\n    /* what a great and wonderful day */\n    foo();\n}\n\nclass C {\n    /* what a great and wonderful day */\n\n    method() {\n        /* what a great and wonderful day */\n        foo();\n    }\n\n    static {\n        /* what a great and wonderful day */\n        foo();\n    }\n}\n\nswitch (foo) {\n  /* what a great and wonderful day */\n\n  case 1:    \n    bar();\n    break;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterLineComment\": true, \"allowBlockEnd\": true }]*/\n\nfunction foo(){\n    var day = \"great\"\n    return day;\n    // what a great and wonderful day\n}\n\nif (bar) {\n    foo();\n    // what a great and wonderful day\n}\n\nclass C {\n\n    method() {\n        foo();\n        // what a great and wonderful day\n    }\n\n    static {\n        foo();\n        // what a great and wonderful day\n    }\n\n    // what a great and wonderful day\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterBlockComment\": true, \"allowBlockEnd\": true }]*/\n\nfunction foo(){\n    var day = \"great\"\n    return day;\n\n    /* what a great and wonderful day */\n}\n\nif (bar) {\n    foo();\n\n    /* what a great and wonderful day */\n}\n\nclass C {\n\n    method() {\n        foo();\n\n        /* what a great and wonderful day */\n    }\n\n    static {\n        foo();\n\n        /* what a great and wonderful day */\n    }\n\n    /* what a great and wonderful day */\n}\n\nswitch (foo) {\n  case 1:    \n    bar();\n    break;\n\n  /* what a great and wonderful day */\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true, \"allowClassStart\": false }]*/\n\nclass foo {\n    // what a great and wonderful day\n    day() {}\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true, \"allowClassStart\": false }]*/\n\nclass foo {\n\n    // what a great and wonderful day\n    day() {}\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true, \"allowClassStart\": true }]*/\n\nclass foo {\n    // what a great and wonderful day\n    day() {}\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true, \"allowClassStart\": false }]*/\n\nclass foo {\n    /* what a great and wonderful day */\n    day() {}\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true, \"allowClassStart\": false }]*/\n\nclass foo {\n\n    /* what a great and wonderful day */\n    day() {}\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true, \"allowClassStart\": true }]*/\n\nclass foo {\n    /* what a great and wonderful day */\n    day() {}\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterLineComment\": true, \"allowClassEnd\": true }]*/\n\nclass foo {\n    day() {}\n    // what a great and wonderful day\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterBlockComment\": true, \"allowClassEnd\": true }]*/\n\nclass foo {\n    day() {}\n\n    /* what a great and wonderful day */\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true, \"allowObjectStart\": true }]*/\n\nvar foo = {\n    // what a great and wonderful day\n    day: \"great\"\n};\n\nconst {\n    // what a great and wonderful day\n    foo: someDay\n} = {foo: \"great\"};\n\nconst {\n    // what a great and wonderful day\n    day\n} = {day: \"great\"};"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true, \"allowObjectStart\": true }]*/\n\nvar foo = {\n    /* what a great and wonderful day */\n    day: \"great\"\n};\n\nconst {\n    /* what a great and wonderful day */\n    foo: someDay\n} = {foo: \"great\"};\n\nconst {\n    /* what a great and wonderful day */\n    day\n} = {day: \"great\"};"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterLineComment\": true, \"allowObjectEnd\": true }]*/\n\nvar foo = {\n    day: \"great\"\n    // what a great and wonderful day\n};\n\nconst {\n    foo: someDay\n    // what a great and wonderful day\n} = {foo: \"great\"};\n\nconst {\n    day\n    // what a great and wonderful day\n} = {day: \"great\"};"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterBlockComment\": true, \"allowObjectEnd\": true }]*/\n\nvar foo = {\n    day: \"great\"\n\n    /* what a great and wonderful day */\n};\n\nconst {\n    foo: someDay\n\n    /* what a great and wonderful day */\n} = {foo: \"great\"};\n\nconst {\n    day\n\n    /* what a great and wonderful day */\n} = {day: \"great\"};"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true, \"allowArrayStart\": true }]*/\n\nvar day = [\n    // what a great and wonderful day\n    \"great\",\n    \"wonderful\"\n];\n\nconst [\n    // what a great and wonderful day\n    someDay\n] = [\"great\", \"not great\"];"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true, \"allowArrayStart\": true }]*/\n\nvar day = [\n    /* what a great and wonderful day */\n    \"great\",\n    \"wonderful\"\n];\n\nconst [\n    /* what a great and wonderful day */\n    someDay\n] = [\"great\", \"not great\"];"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterLineComment\": true, \"allowArrayEnd\": true }]*/\n\nvar day = [\n    \"great\",\n    \"wonderful\"\n    // what a great and wonderful day\n];\n\nconst [\n    someDay\n    // what a great and wonderful day\n] = [\"great\", \"not great\"];"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"afterBlockComment\": true, \"allowArrayEnd\": true }]*/\n\nvar day = [\n    \"great\",\n    \"wonderful\"\n\n    /* what a great and wonderful day */\n];\n\nconst [\n    someDay\n\n    /* what a great and wonderful day */\n] = [\"great\", \"not great\"];"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\"]*/\n\nfoo();\n/* eslint mentioned in this comment */,\nbar();\n\n/*eslint lines-around-comment: [\"error\", { \"ignorePattern\": \"pragma\" }] */\n\nfoo();\n/* a valid comment using pragma in it */"
            },
            {
                "type": "incorrect",
                "content": "/*eslint lines-around-comment: [\"error\", { \"ignorePattern\": \"pragma\" }] */\n\n1 + 1;\n/* something else */"
            },
            {
                "type": "correct",
                "content": "/*eslint lines-around-comment: [\"error\", { \"ignorePattern\": \"pragma\", applyDefaultIgnorePatterns: false }] */\n\nfoo();\n/* a valid comment using pragma in it */"
            },
            {
                "type": "incorrect",
                "content": "/*eslint lines-around-comment: [\"error\", { \"applyDefaultIgnorePatterns\": false }] */\n\nfoo();\n/* eslint mentioned in comment */\n"
            }
        ]
    },
    {
        "name": "lines-between-class-members",
        "url": "https://eslint.org/docs/latest/rules/lines-between-class-members",
        "description": "Require or disallow an empty line between class membersThis rule improves readability by enforcing lines between class members. It will not check empty lines before the first member and after the last member, since that is already taken care of by padded-blocks.Examples of incorrect code for this rule:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint lines-between-class-members: [\"error\", \"always\"]*/\nclass MyClass {\n  x;\n  foo() {\n    //...\n  }\n  bar() {\n    //...\n  }\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint lines-between-class-members: [\"error\", \"always\"]*/\nclass MyClass {\n  x;\n\n  foo() {\n    //...\n  }\n\n  bar() {\n    //...\n  }\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint lines-between-class-members: [\"error\", \"always\"]*/\nclass MyClass {\n  x = 1\n\n  ;in = 2\n}"
            },
            {
                "type": "incorrect",
                "content": "/* eslint lines-between-class-members: [\"error\", \"always\"]*/\nclass Foo{\n  x;\n  bar(){}\n  baz(){}\n}\n\n/* eslint lines-between-class-members: [\"error\", \"never\"]*/\nclass Foo{\n  x;\n\n  bar(){}\n\n  baz(){}\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint lines-between-class-members: [\"error\", \"always\"]*/\nclass Foo{\n  x;\n\n  bar(){}\n\n  baz(){}\n}\n\n/* eslint lines-between-class-members: [\"error\", \"never\"]*/\nclass Foo{\n  x;\n  bar(){}\n  baz(){}\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint lines-between-class-members: [\"error\", \"always\", { \"exceptAfterSingleLine\": true }]*/\nclass Foo{\n  x; // single line class member\n  bar(){} // single line class member\n  baz(){\n    // multi line class member\n  }\n\n  qux(){}\n}"
            }
        ]
    },
    {
        "name": "max-len",
        "url": "https://eslint.org/docs/latest/rules/max-len",
        "description": "Enforce a maximum line lengthVery long lines of code in any language can be difficult to read. In order to aid in readability and maintainability many coders have developed a convention to limit lines of code to X number of characters (traditionally 80 characters).This rule enforces a maximum line length to increase code readability and maintainability. The length of a line is defined as the number of Unicode characters in the line.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint max-len: [\"error\", { \"code\": 80 }]*/\n\nvar foo = { \"bar\": \"This is a bar.\", \"baz\": { \"qux\": \"This is a qux\" }, \"difficult\": \"to read\" };"
            },
            {
                "type": "correct",
                "content": "/*eslint max-len: [\"error\", { \"code\": 80 }]*/\n\nvar foo = {\n  \"bar\": \"This is a bar.\",\n  \"baz\": { \"qux\": \"This is a qux\" },\n  \"easier\": \"to read\"\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-len: [\"error\", { \"code\": 80, \"tabWidth\": 4 }]*/\n\n\\t  \\t  var foo = { \"bar\": \"This is a bar.\", \"baz\": { \"qux\": \"This is a qux\" } };"
            },
            {
                "type": "correct",
                "content": "/*eslint max-len: [\"error\", { \"code\": 80, \"tabWidth\": 4 }]*/\n\n\\t  \\t  var foo = {\n\\t  \\t  \\t  \\t  \"bar\": \"This is a bar.\",\n\\t  \\t  \\t  \\t  \"baz\": { \"qux\": \"This is a qux\" }\n\\t  \\t  };"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-len: [\"error\", { \"comments\": 65 }]*/\n\n/**\n * This is a comment that violates the maximum line length we have specified\n**/"
            },
            {
                "type": "correct",
                "content": "/*eslint max-len: [\"error\", { \"ignoreComments\": true }]*/\n\n/**\n * This is a really really really really really really really really really long comment\n**/"
            },
            {
                "type": "correct",
                "content": "/*eslint max-len: [\"error\", { \"ignoreTrailingComments\": true }]*/\n\nvar foo = 'bar'; // This is a really really really really really really really long comment"
            },
            {
                "type": "correct",
                "content": "/*eslint max-len: [\"error\", { \"ignoreUrls\": true }]*/\n\nvar url = 'https://www.example.com/really/really/really/really/really/really/really/long';"
            },
            {
                "type": "correct",
                "content": "/*eslint max-len: [\"error\", { \"ignoreStrings\": true }]*/\n\nvar longString = 'this is a really really really really really long string!';"
            },
            {
                "type": "correct",
                "content": "/*eslint max-len: [\"error\", { \"ignoreTemplateLiterals\": true }]*/\n\nvar longTemplateLiteral = `this is a really really really really really long template literal!`;"
            },
            {
                "type": "correct",
                "content": "/*eslint max-len: [\"error\", { \"ignoreRegExpLiterals\": true }]*/\n\nvar longRegExpLiteral = /this is a really really really really really long regular expression!/;"
            },
            {
                "type": "correct",
                "content": "/*eslint max-len: [\"error\", { \"ignorePattern\": \"^\\\\s*var\\\\s.+=\\\\s*require\\\\s*\\\\(\" }]*/\n\nvar dep = require('really/really/really/really/really/really/really/really/long/module');"
            }
        ]
    },
    {
        "name": "max-statements-per-line",
        "url": "https://eslint.org/docs/latest/rules/max-statements-per-line",
        "description": "Enforce a maximum number of statements allowed per lineA line of code containing too many statements can be difficult to read. Code is generally read from the top down, especially when scanning, so limiting the number of statements allowed on a single line can be very beneficial for readability and maintainability.This rule enforces a maximum number of statements allowed per line.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint max-statements-per-line: [\"error\", { \"max\": 1 }]*/\n\nvar bar; var baz;\nif (condition) { bar = 1; }\nfor (var i = 0; i < length; ++i) { bar = 1; }\nswitch (discriminant) { default: break; }\nfunction foo() { bar = 1; }\nvar foo = function foo() { bar = 1; };\n(function foo() { bar = 1; })();"
            },
            {
                "type": "correct",
                "content": "/*eslint max-statements-per-line: [\"error\", { \"max\": 1 }]*/\n\nvar bar, baz;\nif (condition) bar = 1;\nfor (var i = 0; i < length; ++i);\nswitch (discriminant) { default: }\nfunction foo() { }\nvar foo = function foo() { };\n(function foo() { })();"
            },
            {
                "type": "incorrect",
                "content": "/*eslint max-statements-per-line: [\"error\", { \"max\": 2 }]*/\n\nvar bar; var baz; var qux;\nif (condition) { bar = 1; } else { baz = 2; }\nfor (var i = 0; i < length; ++i) { bar = 1; baz = 2; }\nswitch (discriminant) { case 'test': break; default: break; }\nfunction foo() { bar = 1; baz = 2; }\nvar foo = function foo() { bar = 1; };\n(function foo() { bar = 1; baz = 2; })();"
            },
            {
                "type": "correct",
                "content": "/*eslint max-statements-per-line: [\"error\", { \"max\": 2 }]*/\n\nvar bar; var baz;\nif (condition) bar = 1; if (condition) baz = 2;\nfor (var i = 0; i < length; ++i) { bar = 1; }\nswitch (discriminant) { default: break; }\nfunction foo() { bar = 1; }\nvar foo = function foo() { bar = 1; };\n(function foo() { var bar = 1; })();"
            }
        ]
    },
    {
        "name": "multiline-ternary",
        "url": "https://eslint.org/docs/latest/rules/multiline-ternary",
        "description": "Enforce newlines between operands of ternary expressionsJavaScript allows operands of ternary expressions to be separated by newlines, which can improve the readability of your program.For example:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint multiline-ternary: [\"error\", \"always\"]*/\n\nfoo > bar ? value1 : value2;\n\nfoo > bar ? value :\n    value2;\n\nfoo > bar ?\n    value : value2;"
            },
            {
                "type": "correct",
                "content": "/*eslint multiline-ternary: [\"error\", \"always\"]*/\n\nfoo > bar ?\n    value1 :\n    value2;\n\nfoo > bar ?\n    (baz > qux ?\n        value1 :\n        value2) :\n    value3;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint multiline-ternary: [\"error\", \"always-multiline\"]*/\n\nfoo > bar ? value1 :\n    value2;\n\nfoo > bar ?\n    value1 : value2;\n\nfoo > bar &&\n    bar > baz ? value1 : value2;"
            },
            {
                "type": "correct",
                "content": "/*eslint multiline-ternary: [\"error\", \"always-multiline\"]*/\n\nfoo > bar ? value1 : value2;\n\nfoo > bar ?\n    value1 :\n    value2;\n\nfoo > bar ?\n    (baz > qux ? value1 : value2) :\n    value3;\n\nfoo > bar ?\n    (baz > qux ?\n        value1 :\n        value2) :\n    value3;\n\nfoo > bar &&\n    bar > baz ?\n        value1 :\n        value2;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint multiline-ternary: [\"error\", \"never\"]*/\n\nfoo > bar ? value :\n    value2;\n\nfoo > bar ?\n    value : value2;\n\nfoo >\n    bar ?\n    value1 :\n    value2;"
            },
            {
                "type": "correct",
                "content": "/*eslint multiline-ternary: [\"error\", \"never\"]*/\n\nfoo > bar ? value1 : value2;\n\nfoo > bar ? (baz > qux ? value1 : value2) : value3;\n\nfoo > bar ? (\n    baz > qux ? value1 : value2\n) : value3;"
            }
        ]
    },
    {
        "name": "new-parens",
        "url": "https://eslint.org/docs/latest/rules/new-parens",
        "description": "Enforce or disallow parentheses when invoking a constructor with no argumentsJavaScript allows the omission of parentheses when invoking a function via the new keyword and the constructor has no arguments. However, some coders believe that omitting the parentheses is inconsistent with the rest of the language and thus makes code less clear.This rule can enforce or disallow parentheses when invoking a constructor with no arguments using the new keyword.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint new-parens: \"error\"*/\n\nvar person = new Person;\nvar person = new (Person);"
            },
            {
                "type": "correct",
                "content": "/*eslint new-parens: \"error\"*/\n\nvar person = new Person();\nvar person = new (Person)();"
            },
            {
                "type": "incorrect",
                "content": "/*eslint new-parens: [\"error\", \"never\"]*/\n\nvar person = new Person();\nvar person = new (Person)();"
            },
            {
                "type": "correct",
                "content": "/*eslint new-parens: [\"error\", \"never\"]*/\n\nvar person = new Person;\nvar person = (new Person);\nvar person = new Person(\"Name\");"
            }
        ]
    },
    {
        "name": "newline-per-chained-call",
        "url": "https://eslint.org/docs/latest/rules/newline-per-chained-call",
        "description": "Require a newline after each call in a method chainChained method calls on a single line without line breaks are harder to read, so some developers place a newline character after each method call in the chain to make it more readable and easy to maintain.Let’s look at the following perfectly valid (but single line) code.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint newline-per-chained-call: [\"error\", { \"ignoreChainWithDepth\": 2 }]*/\n\n_.chain({}).map(foo).filter(bar).value();\n\n// Or\n_.chain({}).map(foo).filter(bar);\n\n// Or\n_\n  .chain({}).map(foo)\n  .filter(bar);\n\n// Or\nobj.method().method2().method3();"
            },
            {
                "type": "correct",
                "content": "/*eslint newline-per-chained-call: [\"error\", { \"ignoreChainWithDepth\": 2 }]*/\n\n_\n  .chain({})\n  .map(foo)\n  .filter(bar)\n  .value();\n\n// Or\n_\n  .chain({})\n  .map(foo)\n  .filter(bar);\n\n// Or\n_.chain({})\n  .map(foo)\n  .filter(bar);\n\n// Or\nobj\n  .prop\n  .method().prop;\n\n// Or\nobj\n  .prop.method()\n  .method2()\n  .method3().prop;"
            }
        ]
    },
    {
        "name": "no-extra-parens",
        "url": "https://eslint.org/docs/latest/rules/no-extra-parens",
        "description": "Disallow unnecessary parenthesesThis rule restricts the use of parentheses to only where they are necessary.This rule always ignores extra parentheses around the following:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint no-extra-parens: \"error\" */\n\na = (b * c);\n\n(a * b) + c;\n\nfor (a in (b, c));\n\nfor (a in (b));\n\nfor (a of (b));\n\ntypeof (a);\n\n(function(){} ? a() : b());\n\nclass A {\n    [(x)] = 1;\n}\n\nclass B {\n    x = (y + z);\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: \"error\" */\n\n(0).toString();\n\n(Object.prototype.toString.call());\n\n({}.toString.call());\n\n(function(){}) ? a() : b();\n\n(/^a$/).test(x);\n\nfor (a of (b, c));\n\nfor (a of b);\n\nfor (a in b, c);\n\nfor (a in b);\n\nclass A {\n    [x] = 1;\n}\n\nclass B {\n    x = y + z;\n}"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { \"conditionalAssign\": false }] */\n\nwhile ((foo = bar())) {}\n\nif ((foo = bar())) {}\n\ndo; while ((foo = bar()))\n\nfor (;(a = b););"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { \"returnAssign\": false }] */\n\nfunction a(b) {\n  return (b = 1);\n}\n\nfunction a(b) {\n  return b ? (c = d) : (c = e);\n}\n\nb => (b = 1);\n\nb => b ? (c = d) : (c = e);"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { \"nestedBinaryExpressions\": false }] */\n\nx = a || (b && c);\nx = a + (b * c);\nx = (a * b) / c;"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"all\" }] */\nconst Component = (<div />)\nconst Component = (\n    <div\n        prop={true}\n    />\n)"
            },
            {
                "type": "incorrect",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"multi-line\" }] */\nconst Component = (<div />)\nconst Component = (<div><p /></div>)"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"multi-line\" }] */\nconst Component = (\n    <div>\n        <p />\n    </div>\n)\nconst Component = (\n    <div\n        prop={true}\n    />\n)"
            },
            {
                "type": "incorrect",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"single-line\" }] */\nconst Component = (\n    <div>\n        <p />\n    </div>\n)\nconst Component = (\n    <div\n        prop={true}\n    />\n)"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"single-line\" }] */\nconst Component = (<div />)\nconst Component = (<div><p /></div>)"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { \"enforceForArrowConditionals\": false }] */\n\nconst b = a => 1 ? 2 : 3;\nconst d = c => (1 ? 2 : 3);"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { \"enforceForSequenceExpressions\": false }] */\n\n(a, b);\n\nif ((val = foo(), val < 10)) {}\n\nwhile ((val = foo(), val < 10));"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { \"enforceForNewInMemberExpressions\": false }] */\n\nconst foo = (new Bar()).baz;\n\nconst quux = (new Bar())[baz];\n\n(new Bar()).doSomething();"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: [\"error\", \"all\", { \"enforceForFunctionPrototypeMethods\": false }] */\n\nconst foo = (function () {}).call();\n\nconst bar = (function () {}).apply();\n\nconst baz = (function () {}.call());\n\nconst quux = (function () {}.apply());"
            },
            {
                "type": "incorrect",
                "content": "/* eslint no-extra-parens: [\"error\", \"functions\"] */\n\n((function foo() {}))();\n\nvar y = (function () {return 1;});"
            },
            {
                "type": "correct",
                "content": "/* eslint no-extra-parens: [\"error\", \"functions\"] */\n\n(0).toString();\n\n(Object.prototype.toString.call());\n\n({}.toString.call());\n\n(function(){} ? a() : b());\n\n(/^a$/).test(x);\n\na = (b * c);\n\n(a * b) + c;\n\ntypeof (a);"
            }
        ]
    },
    {
        "name": "no-mixed-spaces-and-tabs",
        "url": "https://eslint.org/docs/latest/rules/no-mixed-spaces-and-tabs",
        "description": "Disallow mixed spaces and tabs for indentationMost code conventions require either tabs or spaces be used for indentation. As such, it’s usually an error if a single line of code is indented with both tabs and spaces.This rule disallows mixed spaces and tabs for indentation.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-mixed-spaces-and-tabs: \"error\"*/\n\nfunction add(x, y) {\n// --->..return x + y;\n\n      return x + y;\n}\n\nfunction main() {\n// --->var x = 5,\n// --->....y = 7;\n\n    var x = 5,\n        y = 7;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-mixed-spaces-and-tabs: \"error\"*/\n\nfunction add(x, y) {\n// --->return x + y;\n    return x + y;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint no-mixed-spaces-and-tabs: [\"error\", \"smart-tabs\"]*/\n\nfunction main() {\n// --->var x = 5,\n// --->....y = 7;\n\n    var x = 5,\n        y = 7;\n}"
            }
        ]
    },
    {
        "name": "no-multi-spaces",
        "url": "https://eslint.org/docs/latest/rules/no-multi-spaces",
        "description": "Disallow multiple spacesMultiple spaces in a row that are not used for indentation are typically mistakes. For example:It’s hard to tell, but there are two spaces between foo and ===. Multiple spaces such as this are generally frowned upon in favor of single spaces:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-multi-spaces: \"error\"*/\n\nvar a =  1;\n\nif(foo   === \"bar\") {}\n\na <<  b\n\nvar arr = [1,  2];\n\na ?  b: c"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multi-spaces: \"error\"*/\n\nvar a = 1;\n\nif(foo === \"bar\") {}\n\na << b\n\nvar arr = [1, 2];\n\na ? b: c"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-multi-spaces: [\"error\", { ignoreEOLComments: false }]*/\n\nvar x = 5;      // comment\nvar x = 5;      /* multiline\n * comment\n */"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multi-spaces: [\"error\", { ignoreEOLComments: false }]*/\n\nvar x = 5; // comment\nvar x = 5; /* multiline\n * comment\n */"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multi-spaces: [\"error\", { ignoreEOLComments: true }]*/\n\nvar x = 5; // comment\nvar x = 5;      // comment\nvar x = 5; /* multiline\n * comment\n */\nvar x = 5;      /* multiline\n * comment\n */"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multi-spaces: \"error\"*/\n/*eslint key-spacing: [\"error\", { align: \"value\" }]*/\n\nvar obj = {\n    first:  \"first\",\n    second: \"second\"\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-multi-spaces: [\"error\", { exceptions: { \"Property\": false } }]*/\n/*eslint key-spacing: [\"error\", { align: \"value\" }]*/\n\nvar obj = {\n    first:  \"first\",\n    second: \"second\"\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multi-spaces: [\"error\", { exceptions: { \"BinaryExpression\": true } }]*/\n\nvar a = 1  *  2;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multi-spaces: [\"error\", { exceptions: { \"VariableDeclarator\": true } }]*/\n\nvar someVar      = 'foo';\nvar someOtherVar = 'barBaz';"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multi-spaces: [\"error\", { exceptions: { \"ImportDeclaration\": true } }]*/\n\nimport mod          from 'mod';\nimport someOtherMod from 'some-other-mod';"
            }
        ]
    },
    {
        "name": "no-multiple-empty-lines",
        "url": "https://eslint.org/docs/latest/rules/no-multiple-empty-lines",
        "description": "Disallow multiple empty linesSome developers prefer to have multiple blank lines removed, while others feel that it helps improve readability. Whitespace is useful for separating logical sections of code, but excess whitespace takes up more of the screen.This rule aims to reduce the scrolling required when reading through your code. It will warn when the maximum amount of empty lines has been exceeded.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-multiple-empty-lines: \"error\"*/\n\nvar foo = 5;\n\n\nvar bar = 3;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multiple-empty-lines: \"error\"*/\n\nvar foo = 5;\n\nvar bar = 3;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-multiple-empty-lines: [\"error\", { \"max\": 2, \"maxEOF\": 0 }]*/\n\nvar foo = 5;\n\nvar bar = 3;\n"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multiple-empty-lines: [\"error\", { \"max\": 2, \"maxEOF\": 0 }]*/\n\nvar foo = 5;\n\nvar bar = 3;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint no-multiple-empty-lines: [\"error\", { \"max\": 2, \"maxBOF\": 1 }]*/\n\nvar foo = 5;\n\nvar bar = 3;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-multiple-empty-lines: [\"error\", { \"max\": 2, \"maxBOF\": 1}]*/\n\nvar foo = 5;\n\nvar bar = 3;"
            }
        ]
    },
    {
        "name": "no-tabs",
        "url": "https://eslint.org/docs/latest/rules/no-tabs",
        "description": "Disallow all tabsSome style guides don’t allow the use of tab characters at all, including within comments.This rule looks for tabs anywhere inside a file: code, comments or anything else.",
        "examples": [
            {
                "type": "incorrect",
                "content": "var a \\t= 2;\n\n/**\n* \\t\\t it's a test function\n*/\nfunction test(){}\n\nvar x = 1; // \\t test"
            },
            {
                "type": "correct",
                "content": "var a = 2;\n\n/**\n* it's a test function\n*/\nfunction test(){}\n\nvar x = 1; // test"
            },
            {
                "type": "correct",
                "content": "/* eslint no-tabs: [\"error\", { allowIndentationTabs: true }] */\n\nfunction test() {\n\\tdoSomething();\n}\n\n\\t// comment with leading indentation tab"
            }
        ]
    },
    {
        "name": "no-trailing-spaces",
        "url": "https://eslint.org/docs/latest/rules/no-trailing-spaces",
        "description": "Disallow trailing whitespace at the end of linesSometimes in the course of editing files, you can end up with extra whitespace at the end of lines. These whitespace differences can be picked up by source control systems and flagged as diffs, causing frustration for developers. While this extra whitespace causes no functional issues, many code conventions require that trailing spaces be removed before check-in.This rule disallows trailing whitespace (spaces, tabs, and other Unicode whitespace characters) at the end of lines.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-trailing-spaces: \"error\"*/\n\nvar foo = 0;//•••••\nvar baz = 5;//••\n//•••••"
            },
            {
                "type": "correct",
                "content": "/*eslint no-trailing-spaces: \"error\"*/\n\nvar foo = 0;\nvar baz = 5;"
            },
            {
                "type": "correct",
                "content": "/*eslint no-trailing-spaces: [\"error\", { \"skipBlankLines\": true }]*/\n\nvar foo = 0;\nvar baz = 5;\n//•••••"
            },
            {
                "type": "correct",
                "content": "/*eslint no-trailing-spaces: [\"error\", { \"ignoreComments\": true }]*/\n\n//foo•\n//•••••\n/**\n *•baz\n *••\n *•bar\n */"
            }
        ]
    },
    {
        "name": "no-whitespace-before-property",
        "url": "https://eslint.org/docs/latest/rules/no-whitespace-before-property",
        "description": "Disallow whitespace before propertiesJavaScript allows whitespace between objects and their properties. However, inconsistent spacing can make code harder to read and can lead to errors.This rule disallows whitespace around the dot or before the opening bracket before properties of objects if they are on the same line. This rule allows whitespace when the object and property are on separate lines, as it is common to add newlines to longer chains of properties:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint no-whitespace-before-property: \"error\"*/\n\nfoo [bar]\n\nfoo. bar\n\nfoo .bar\n\nfoo. bar. baz\n\nfoo. bar()\n  .baz()\n\nfoo\n  .bar(). baz()"
            },
            {
                "type": "correct",
                "content": "/*eslint no-whitespace-before-property: \"error\"*/\n\nfoo.bar\n\nfoo[bar]\n\nfoo[ bar ]\n\nfoo.bar.baz\n\nfoo\n  .bar().baz()\n\nfoo\n  .bar()\n  .baz()\n\nfoo.\n  bar().\n  baz()"
            }
        ]
    },
    {
        "name": "nonblock-statement-body-position",
        "url": "https://eslint.org/docs/latest/rules/nonblock-statement-body-position",
        "description": "Enforce the location of single-line statementsWhen writing if, else, while, do-while, and for statements, the body can be a single statement instead of a block. It can be useful to enforce a consistent location for these single statements.For example, some developers avoid writing code like this:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/* eslint nonblock-statement-body-position: [\"error\", \"beside\"] */\n\nif (foo)\n  bar();\nelse\n  baz();\n\nwhile (foo)\n  bar();\n\nfor (let i = 1; i < foo; i++)\n  bar();\n\ndo\n  bar();\nwhile (foo)\n"
            },
            {
                "type": "correct",
                "content": "/* eslint nonblock-statement-body-position: [\"error\", \"beside\"] */\n\nif (foo) bar();\nelse baz();\n\nwhile (foo) bar();\n\nfor (let i = 1; i < foo; i++) bar();\n\ndo bar(); while (foo)\n\nif (foo) { // block statements are always allowed with this rule\n  bar();\n} else {\n  baz();\n}"
            },
            {
                "type": "incorrect",
                "content": "/* eslint nonblock-statement-body-position: [\"error\", \"below\"] */\n\nif (foo) bar();\nelse baz();\n\nwhile (foo) bar();\n\nfor (let i = 1; i < foo; i++) bar();\n\ndo bar(); while (foo)"
            },
            {
                "type": "correct",
                "content": "/* eslint nonblock-statement-body-position: [\"error\", \"below\"] */\n\nif (foo)\n  bar();\nelse\n  baz();\n\nwhile (foo)\n  bar();\n\nfor (let i = 1; i < foo; i++)\n  bar();\n\ndo\n  bar();\nwhile (foo)\n\nif (foo) {\n  // Although the second `if` statement is on the same line as the `else`, this is a very common\n  // pattern, so it's not checked by this rule.\n} else if (bar) {\n}"
            },
            {
                "type": "incorrect",
                "content": "/* eslint nonblock-statement-body-position: [\"error\", \"beside\", { \"overrides\": { \"while\": \"below\" } }] */\n\nif (foo)\n  bar();\n\nwhile (foo) bar();"
            },
            {
                "type": "correct",
                "content": "/* eslint nonblock-statement-body-position: [\"error\", \"beside\", { \"overrides\": { \"while\": \"below\" } }] */\n\nif (foo) bar();\n\nwhile (foo)\n  bar();"
            }
        ]
    },
    {
        "name": "object-curly-newline",
        "url": "https://eslint.org/docs/latest/rules/object-curly-newline",
        "description": "Enforce consistent line breaks after opening and before closing bracesA number of style guides require or disallow line breaks inside of object braces and other tokens.This rule requires or disallows a line break between { and its following token, and between } and its preceding token of object literals or destructuring assignments.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint object-curly-newline: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nlet a = {};\nlet b = {foo: 1};\nlet c = {foo: 1, bar: 2};\nlet d = {foo: 1,\n    bar: 2};\nlet e = {foo() {\n    dosomething();\n}};\n\nlet {} = obj;\nlet {f} = obj;\nlet {g, h} = obj;\nlet {i,\n    j} = obj;\nlet {k = function() {\n    dosomething();\n}} = obj;"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-newline: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nlet a = {\n};\nlet b = {\n    foo: 1\n};\nlet c = {\n    foo: 1, bar: 2\n};\nlet d = {\n    foo: 1,\n    bar: 2\n};\nlet e = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {\n} = obj;\nlet {\n    f\n} = obj;\nlet {\n    g, h\n} = obj;\nlet {\n    i,\n    j\n} = obj;\nlet {\n    k = function() {\n        dosomething();\n    }\n} = obj;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint object-curly-newline: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nlet a = {\n};\nlet b = {\n    foo: 1\n};\nlet c = {\n    foo: 1, bar: 2\n};\nlet d = {\n    foo: 1,\n    bar: 2\n};\nlet e = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {\n} = obj;\nlet {\n    f\n} = obj;\nlet {\n    g, h\n} = obj;\nlet {\n    i,\n    j\n} = obj;\nlet {\n    k = function() {\n        dosomething();\n    }\n} = obj;"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-newline: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nlet a = {};\nlet b = {foo: 1};\nlet c = {foo: 1, bar: 2};\nlet d = {foo: 1,\n    bar: 2};\nlet e = {foo: function() {\n    dosomething();\n}};\n\nlet {} = obj;\nlet {f} = obj;\nlet {g, h} = obj;\nlet {i,\n    j} = obj;\nlet {k = function() {\n    dosomething();\n}} = obj;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint object-curly-newline: [\"error\", { \"multiline\": true }]*/\n/*eslint-env es6*/\n\nlet a = {\n};\nlet b = {\n    foo: 1\n};\nlet c = {\n    foo: 1, bar: 2\n};\nlet d = {foo: 1,\n    bar: 2};\nlet e = {foo: function() {\n    dosomething();\n}};\n\nlet {\n} = obj;\nlet {\n    f\n} = obj;\nlet {\n    g, h\n} = obj;\nlet {i,\n    j} = obj;\nlet {k = function() {\n    dosomething();\n}} = obj;"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-newline: [\"error\", { \"multiline\": true }]*/\n/*eslint-env es6*/\n\nlet a = {};\nlet b = {foo: 1};\nlet c = {foo: 1, bar: 2};\nlet d = {\n    foo: 1,\n    bar: 2\n};\nlet e = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {} = obj;\nlet {f} = obj;\nlet {g, h} = obj;\nlet {\n    i,\n    j\n} = obj;\nlet {\n    k = function() {\n        dosomething();\n    }\n} = obj;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint object-curly-newline: [\"error\", { \"minProperties\": 2 }]*/\n/*eslint-env es6*/\n\nlet a = {\n};\nlet b = {\n    foo: 1\n};\nlet c = {foo: 1, bar: 2};\nlet d = {foo: 1,\n    bar: 2};\nlet e = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {\n} = obj;\nlet {\n    f\n} = obj;\nlet {g, h} = obj;\nlet {i,\n    j} = obj;\nlet {\n    k = function() {\n        dosomething();\n    }\n} = obj;"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-newline: [\"error\", { \"minProperties\": 2 }]*/\n/*eslint-env es6*/\n\nlet a = {};\nlet b = {foo: 1};\nlet c = {\n    foo: 1, bar: 2\n};\nlet d = {\n    foo: 1,\n    bar: 2\n};\nlet e = {foo: function() {\n    dosomething();\n}};\n\nlet {} = obj;\nlet {f} = obj;\nlet {\n    g, h\n} = obj;\nlet {\n    i,\n    j\n} = obj;\nlet {k = function() {\n    dosomething();\n}} = obj;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint object-curly-newline: [\"error\", { \"consistent\": true }]*/\n/*eslint-env es6*/\n\nlet a = {foo: 1\n};\nlet b = {\n    foo: 1};\nlet c = {foo: 1, bar: 2\n};\nlet d = {\n    foo: 1, bar: 2};\nlet e = {foo: function() {\n    dosomething();\n    }\n};\nlet f = {\n    foo: function() {\n    dosomething();}};\n\nlet {g\n} = obj;\nlet {\n    h} = obj;\nlet {i, j\n} = obj;\nlet {k, l\n} = obj;\nlet {\n    m, n} = obj;\nlet {\n    o, p} = obj;\nlet {q = function() {\n    dosomething();\n    }\n} = obj;\nlet {\n    r = function() {\n        dosomething();\n    }} = obj;"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-newline: [\"error\", { \"consistent\": true }]*/\n/*eslint-env es6*/\n\nlet empty1 = {};\nlet empty2 = {\n};\nlet a = {foo: 1};\nlet b = {\n    foo: 1\n};\nlet c = {\n    foo: 1, bar: 2\n};\nlet d = {\n    foo: 1,\n    bar: 2\n};\nlet e = {foo: function() {dosomething();}};\nlet f = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {} = obj;\nlet {\n} = obj;\nlet {g} = obj;\nlet {\n    h\n} = obj;\nlet {i, j} = obj;\nlet {\n    k, l\n} = obj;\nlet {m,\n    n} = obj;\nlet {\n    o,\n    p\n} = obj;\nlet {q = function() {dosomething();}} = obj;\nlet {\n    r = function() {\n        dosomething();\n    }\n} = obj;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint object-curly-newline: [\"error\", { \"ObjectExpression\": \"always\", \"ObjectPattern\": \"never\" }]*/\n/*eslint-env es6*/\n\nlet a = {};\nlet b = {foo: 1};\nlet c = {foo: 1, bar: 2};\nlet d = {foo: 1,\n    bar: 2};\nlet e = {foo: function() {\n    dosomething();\n}};\n\nlet {\n} = obj;\nlet {\n    f\n} = obj;\nlet {\n    g, h\n} = obj;\nlet {\n    i,\n    j\n} = obj;\nlet {\n    k = function() {\n        dosomething();\n    }\n} = obj;"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-newline: [\"error\", { \"ObjectExpression\": \"always\", \"ObjectPattern\": \"never\" }]*/\n/*eslint-env es6*/\n\nlet a = {\n};\nlet b = {\n    foo: 1\n};\nlet c = {\n    foo: 1, bar: 2\n};\nlet d = {\n    foo: 1,\n    bar: 2\n};\nlet e = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {} = obj;\nlet {f} = obj;\nlet {g, h} = obj;\nlet {i,\n    j} = obj;\nlet {k = function() {\n    dosomething();\n}} = obj;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint object-curly-newline: [\"error\", { \"ImportDeclaration\": \"always\", \"ExportDeclaration\": \"never\" }]*/\n/*eslint-env es6*/\n\nimport {foo, bar} from 'foo-bar';\nimport {foo as f, bar} from 'foo-bar';\nimport {foo,\n    bar} from 'foo-bar';\n\nexport {\n   foo,\n   bar\n};\nexport {\n   foo as f,\n   bar\n} from 'foo-bar';"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-newline: [\"error\", { \"ImportDeclaration\": \"always\", \"ExportDeclaration\": \"never\" }]*/\n/*eslint-env es6*/\n\nimport {\n    foo,\n    bar\n} from 'foo-bar';\nimport {\n    foo, bar\n} from 'foo-bar';\nimport {\n    foo as f,\n    bar\n} from 'foo-bar';\n\nexport { foo, bar } from 'foo-bar';\nexport { foo as f, bar } from 'foo-bar';"
            }
        ]
    },
    {
        "name": "object-curly-spacing",
        "url": "https://eslint.org/docs/latest/rules/object-curly-spacing",
        "description": "Enforce consistent spacing inside bracesWhile formatting preferences are very personal, a number of style guides require or disallow spaces between curly braces in the following situations:This rule enforces consistent spacing inside braces of object literals, destructuring assignments, and import/export specifiers.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint object-curly-spacing: [\"error\", \"never\"]*/\n\nvar obj = { 'foo': 'bar' };\nvar obj = {'foo': 'bar' };\nvar obj = { baz: {'foo': 'qux'}, bar};\nvar obj = {baz: { 'foo': 'qux'}, bar};\nvar {x } = y;\nimport { foo } from 'bar';"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-spacing: [\"error\", \"never\"]*/\n\nvar obj = {'foo': 'bar'};\nvar obj = {'foo': {'bar': 'baz'}, 'qux': 'quxx'};\nvar obj = {\n  'foo': 'bar'\n};\nvar obj = {'foo': 'bar'\n};\nvar obj = {\n  'foo':'bar'};\nvar obj = {};\nvar {x} = y;\nimport {foo} from 'bar';"
            },
            {
                "type": "incorrect",
                "content": "/*eslint object-curly-spacing: [\"error\", \"always\"]*/\n\nvar obj = {'foo': 'bar'};\nvar obj = {'foo': 'bar' };\nvar obj = { baz: {'foo': 'qux'}, bar};\nvar obj = {baz: { 'foo': 'qux' }, bar};\nvar obj = {'foo': 'bar'\n};\nvar obj = {\n  'foo':'bar'};\nvar {x} = y;\nimport {foo } from 'bar';"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-spacing: [\"error\", \"always\"]*/\n\nvar obj = {};\nvar obj = { 'foo': 'bar' };\nvar obj = { 'foo': { 'bar': 'baz' }, 'qux': 'quxx' };\nvar obj = {\n  'foo': 'bar'\n};\nvar { x } = y;\nimport { foo } from 'bar';"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-spacing: [\"error\", \"never\", { \"arraysInObjects\": true }]*/\n\nvar obj = {\"foo\": [ 1, 2 ] };\nvar obj = {\"foo\": [ \"baz\", \"bar\" ] };"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-spacing: [\"error\", \"always\", { \"arraysInObjects\": false }]*/\n\nvar obj = { \"foo\": [ 1, 2 ]};\nvar obj = { \"foo\": [ \"baz\", \"bar\" ]};"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-spacing: [\"error\", \"never\", { \"objectsInObjects\": true }]*/\n\nvar obj = {\"foo\": {\"baz\": 1, \"bar\": 2} };"
            },
            {
                "type": "correct",
                "content": "/*eslint object-curly-spacing: [\"error\", \"always\", { \"objectsInObjects\": false }]*/\n\nvar obj = { \"foo\": { \"baz\": 1, \"bar\": 2 }};"
            }
        ]
    },
    {
        "name": "object-property-newline",
        "url": "https://eslint.org/docs/latest/rules/object-property-newline",
        "description": "Enforce placing object properties on separate linesThis rule permits you to restrict the locations of property specifications in object literals. You may prohibit any part of any property specification from appearing on the same line as any part of any other property specification. You may make this prohibition absolute, or, by invoking an object option, you may allow an exception, permitting an object literal to have all parts of all of its property specifications on a single line.This rule makes it possible to ensure, as some style guides require, that property specifications appear on separate lines for better readability. For example, you can prohibit all of these:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint object-property-newline: \"error\"*/\n\nconst obj0 = { foo: \"foo\", bar: \"bar\", baz: \"baz\" };\n\nconst obj1 = {\n    foo: \"foo\", bar: \"bar\", baz: \"baz\"\n};\n\nconst obj2 = {\n    foo: \"foo\", bar: \"bar\",\n    baz: \"baz\"\n};\n\nconst obj3 = {\n    [process.argv[3] ? \"foo\" : \"bar\"]: 0, baz: [\n        1,\n        2,\n        4,\n        8\n    ]\n};\n\nconst a = \"antidisestablishmentarianistically\";\nconst b = \"yugoslavyalılaştırabildiklerimizdenmişsiniz\";\nconst obj4 = {a, b};\n\nconst domain = process.argv[4];\nconst obj5 = {\n    foo: \"foo\", [\n    domain.includes(\":\") ? \"complexdomain\" : \"simpledomain\"\n]: true};"
            },
            {
                "type": "correct",
                "content": "/*eslint object-property-newline: \"error\"*/\n\nconst obj1 = {\n    foo: \"foo\",\n    bar: \"bar\",\n    baz: \"baz\"\n};\n\nconst obj2 = {\n    foo: \"foo\"\n    , bar: \"bar\"\n    , baz: \"baz\"\n};\n\nconst user = process.argv[2];\nconst obj3 = {\n    user,\n    [process.argv[3] ? \"foo\" : \"bar\"]: 0,\n    baz: [\n        1,\n        2,\n        4,\n        8\n    ]\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint object-property-newline: [\"error\", { \"allowAllPropertiesOnSameLine\": true }]*/\n\nconst obj = { foo: \"foo\", bar: \"bar\", baz: \"baz\" };\n\nconst obj2 = {\n    foo: \"foo\", bar: \"bar\", baz: \"baz\"\n};\nconst user = process.argv[2];\nconst obj3 = {\n    user, [process.argv[3] ? \"foo\" : \"bar\"]: 0, baz: [1, 2, 4, 8]\n};"
            }
        ]
    },
    {
        "name": "operator-linebreak",
        "url": "https://eslint.org/docs/latest/rules/operator-linebreak",
        "description": "Enforce consistent linebreak style for operatorsWhen a statement is too long to fit on a single line, line breaks are generally inserted next to the operators separating expressions. The first style coming to mind would be to place the operator at the end of the line, following the English punctuation rules.Some developers find that placing operators at the beginning of the line makes the code more readable.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint operator-linebreak: [\"error\", \"after\"]*/\n\nfoo = 1\n+\n2;\n\nfoo = 1\n    + 2;\n\nfoo\n    = 5;\n\nif (someCondition\n    || otherCondition) {\n}\n\nanswer = everything\n  ? 42\n  : foo;\n\nclass Foo {\n    a\n        = 1;\n    [b]\n        = 2;\n    [c\n    ]\n        = 3;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint operator-linebreak: [\"error\", \"after\"]*/\n\nfoo = 1 + 2;\n\nfoo = 1 +\n      2;\n\nfoo =\n    5;\n\nif (someCondition ||\n    otherCondition) {\n}\n\nanswer = everything ?\n  42 :\n  foo;\n\nclass Foo {\n    a =\n        1;\n    [b] =\n        2;\n    [c\n    ] =\n        3;\n    d = 4;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint operator-linebreak: [\"error\", \"before\"]*/\n\nfoo = 1 +\n      2;\n\nfoo =\n    5;\n\nif (someCondition ||\n    otherCondition) {\n}\n\nanswer = everything ?\n  42 :\n  foo;\n\nclass Foo {\n    a =\n        1;\n    [b] =\n        2;\n    [c\n    ] =\n        3;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint operator-linebreak: [\"error\", \"before\"]*/\n\nfoo = 1 + 2;\n\nfoo = 1\n    + 2;\n\nfoo\n    = 5;\n\nif (someCondition\n    || otherCondition) {\n}\n\nanswer = everything\n  ? 42\n  : foo;\n\nclass Foo {\n    a\n        = 1;\n    [b]\n        = 2;\n    [c\n    ]\n        = 3;\n    d = 4;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint operator-linebreak: [\"error\", \"none\"]*/\n\nfoo = 1 +\n      2;\n\nfoo = 1\n    + 2;\n\nif (someCondition ||\n    otherCondition) {\n}\n\nif (someCondition\n    || otherCondition) {\n}\n\nanswer = everything\n  ? 42\n  : foo;\n\nanswer = everything ?\n  42 :\n  foo;\n\nclass Foo {\n    a =\n        1;\n    [b] =\n        2;\n    [c\n    ] =\n        3;\n    d\n        = 4;\n    [e]\n        = 5;\n    [f\n    ]\n        = 6;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint operator-linebreak: [\"error\", \"none\"]*/\n\nfoo = 1 + 2;\n\nfoo = 5;\n\nif (someCondition || otherCondition) {\n}\n\nanswer = everything ? 42 : foo;\n\nclass Foo {\n    a = 1;\n    [b] = 2;\n    [c\n    ] = 3;\n    d = 4;\n    [e] = 5;\n    [f\n    ] = 6;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint operator-linebreak: [\"error\", \"after\", { \"overrides\": { \"+=\": \"before\" } }]*/\n\nvar thing = 'thing';\nthing +=\n  's';"
            },
            {
                "type": "correct",
                "content": "/*eslint operator-linebreak: [\"error\", \"after\", { \"overrides\": { \"+=\": \"before\" } }]*/\n\nvar thing = 'thing';\nthing\n  += 's';"
            },
            {
                "type": "correct",
                "content": "/*eslint operator-linebreak: [\"error\", \"after\", { \"overrides\": { \"?\": \"ignore\", \":\": \"ignore\" } }]*/\n\nanswer = everything ?\n  42\n  : foo;\n\nanswer = everything\n  ?\n  42\n  :\n  foo;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint operator-linebreak: [\"error\", \"after\", { \"overrides\": { \"?\": \"before\", \":\": \"before\" } }]*/\n\nfoo = 1\n+\n2;\n\nfoo = 1\n    + 2;\n\nfoo\n    = 5;\n\nif (someCondition\n    || otherCondition) {\n}\n\nanswer = everything ?\n  42 :\n  foo;"
            },
            {
                "type": "correct",
                "content": "/*eslint operator-linebreak: [\"error\", \"after\", { \"overrides\": { \"?\": \"before\", \":\": \"before\" } }]*/\n\nfoo = 1 + 2;\n\nfoo = 1 +\n      2;\n\nfoo =\n    5;\n\nif (someCondition ||\n    otherCondition) {\n}\n\nanswer = everything\n  ? 42\n  : foo;"
            }
        ]
    },
    {
        "name": "padded-blocks",
        "url": "https://eslint.org/docs/latest/rules/padded-blocks",
        "description": "Require or disallow padding within blocksSome style guides require block statements to start and end with blank lines. The goal is to improve readability by visually separating the block content and the surrounding code.Since it’s good to have a consistent code style, you should either always write padded blocks or never do it.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint padded-blocks: [\"error\", \"always\"]*/\n\nif (a) {\n    b();\n}\n\nif (a) { b(); }\n\nif (a)\n{\n    b();\n}\n\nif (a) {\n    b();\n\n}\n\nif (a) {\n    // comment\n    b();\n\n}\n\nclass C {\n    static {\n        a();\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padded-blocks: [\"error\", \"always\"]*/\n\nif (a) {\n\n    b();\n\n}\n\nif (a)\n{\n\n    b();\n\n}\n\nif (a) {\n\n    // comment\n    b();\n\n}\n\nclass C {\n\n    static {\n\n        a();\n\n    }\n\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint padded-blocks: [\"error\", \"never\"]*/\n\nif (a) {\n\n    b();\n\n}\n\nif (a)\n{\n\n    b();\n\n}\n\nif (a) {\n\n    b();\n}\n\nif (a) {\n    b();\n\n}\n\nclass C {\n\n    static {\n\n        a();\n\n    }\n\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padded-blocks: [\"error\", \"never\"]*/\n\nif (a) {\n    b();\n}\n\nif (a)\n{\n    b();\n}\n\nclass C {\n    static {\n        a();\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint padded-blocks: [\"error\", { \"blocks\": \"always\" }]*/\n\nif (a) {\n    b();\n}\n\nif (a) { b(); }\n\nif (a)\n{\n    b();\n}\n\nif (a) {\n\n    b();\n}\n\nif (a) {\n    b();\n\n}\n\nif (a) {\n    // comment\n    b();\n\n}\n\nclass C {\n\n    static {\n        a();\n    }\n\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padded-blocks: [\"error\", { \"blocks\": \"always\" }]*/\n\nif (a) {\n\n    b();\n\n}\n\nif (a)\n{\n\n    b();\n\n}\n\nif (a) {\n\n    // comment\n    b();\n\n}\n\nclass C {\n\n    static {\n\n        a();\n\n    }\n\n}\n\nclass D {\n    static {\n\n        a();\n\n    }\n\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint padded-blocks: [\"error\", { \"blocks\": \"never\" }]*/\n\nif (a) {\n\n    b();\n\n}\n\nif (a)\n{\n\n    b();\n\n}\n\nif (a) {\n\n    b();\n}\n\nif (a) {\n    b();\n\n}\n\nclass C {\n    static {\n\n        a();\n\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padded-blocks: [\"error\", { \"blocks\": \"never\" }]*/\n\nif (a) {\n    b();\n}\n\nif (a)\n{\n    b();\n}\n\nclass C {\n    static {\n        a();\n    }\n}\n\nclass D {\n\n    static {\n        a();\n    }\n\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint padded-blocks: [\"error\", { \"classes\": \"always\" }]*/\n\nclass  A {\n    constructor(){\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padded-blocks: [\"error\", { \"classes\": \"always\" }]*/\n\nclass  A {\n\n    constructor(){\n    }\n\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint padded-blocks: [\"error\", { \"classes\": \"never\" }]*/\n\nclass  A {\n\n    constructor(){\n    }\n\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padded-blocks: [\"error\", { \"classes\": \"never\" }]*/\n\nclass  A {\n    constructor(){\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint padded-blocks: [\"error\", { \"switches\": \"always\" }]*/\n\nswitch (a) {\n    case 0: foo();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padded-blocks: [\"error\", { \"switches\": \"always\" }]*/\n\nswitch (a) {\n\n    case 0: foo();\n\n}\n\nif (a) {\n    b();\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint padded-blocks: [\"error\", { \"switches\": \"never\" }]*/\n\nswitch (a) {\n\n    case 0: foo();\n\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padded-blocks: [\"error\", { \"switches\": \"never\" }]*/\n\nswitch (a) {\n    case 0: foo();\n}\n\nif (a) {\n\n    b();\n\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint padded-blocks: [\"error\", \"always\", { allowSingleLineBlocks: true }]*/\n\nif (a) {\n    b();\n}\n\nif (a) {\n\n    b();\n}\n\nif (a) {\n    b();\n\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padded-blocks: [\"error\", \"always\", { allowSingleLineBlocks: true }]*/\n\nif (a) { b(); }\n\nif (a) {\n\n    b();\n\n}"
            }
        ]
    },
    {
        "name": "padding-line-between-statements",
        "url": "https://eslint.org/docs/latest/rules/padding-line-between-statements",
        "description": "Require or disallow padding lines between statementsThis rule requires or disallows blank lines between the given 2 kinds of statements. Properly blank lines help developers to understand the code.For example, the following configuration requires a blank line between a variable declaration and a return statement.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"*\", next: \"return\" }\n]*/\n\nfunction foo() {\n    bar();\n    return;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"*\", next: \"return\" }\n]*/\n\nfunction foo() {\n    bar();\n\n    return;\n}\n\nfunction foo() {\n    return;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: [\"const\", \"let\", \"var\"], next: \"*\"},\n    { blankLine: \"any\",    prev: [\"const\", \"let\", \"var\"], next: [\"const\", \"let\", \"var\"]}\n]*/\n\nfunction foo() {\n    var a = 0;\n    bar();\n}\n\nfunction foo() {\n    let a = 0;\n    bar();\n}\n\nfunction foo() {\n    const a = 0;\n    bar();\n}\n\nclass C {\n    static {\n        let a = 0;\n        bar();\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: [\"const\", \"let\", \"var\"], next: \"*\"},\n    { blankLine: \"any\",    prev: [\"const\", \"let\", \"var\"], next: [\"const\", \"let\", \"var\"]}\n]*/\n\nfunction foo() {\n    var a = 0;\n    var b = 0;\n\n    bar();\n}\n\nfunction foo() {\n    let a = 0;\n    const b = 0;\n\n    bar();\n}\n\nfunction foo() {\n    const a = 0;\n    const b = 0;\n\n    bar();\n}\n\nclass C {\n    static {\n        let a = 0;\n        let b = 0;\n\n        bar();\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"directive\", next: \"*\" },\n    { blankLine: \"any\",    prev: \"directive\", next: \"directive\" }\n]*/\n\n\"use strict\";\nfoo();"
            },
            {
                "type": "correct",
                "content": "/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"directive\", next: \"*\" },\n    { blankLine: \"any\",    prev: \"directive\", next: \"directive\" }\n]*/\n\n\"use strict\";\n\"use asm\";\n\nfoo();"
            },
            {
                "type": "incorrect",
                "content": "/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: [\"case\", \"default\"], next: \"*\" }\n]*/\n\nswitch (foo) {\n    case 1:\n        bar();\n        break;\n    case 2:\n    case 3:\n        baz();\n        break;\n    default:\n        quux();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: [\"case\", \"default\"], next: \"*\" }\n]*/\n\nswitch (foo) {\n    case 1:\n        bar();\n        break;\n\n    case 2:\n\n    case 3:\n        baz();\n        break;\n\n    default:\n        quux();\n}"
            }
        ]
    },
    {
        "name": "quotes",
        "url": "https://eslint.org/docs/latest/rules/quotes",
        "description": "Enforce the consistent use of either backticks, double, or single quotesJavaScript allows you to define strings in one of three ways: double quotes, single quotes, and backticks (as of ECMAScript 6). For example:Each of these lines creates a string and, in some cases, can be used interchangeably. The choice of how to define strings in a codebase is a stylistic one outside of template literals (which allow embedded of expressions to be interpreted).",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint quotes: [\"error\", \"double\"]*/\n\nvar single = 'single';\nvar unescaped = 'a string containing \"double\" quotes';\nvar backtick = `back\\ntick`; // you can use \\n in single or double quoted strings"
            },
            {
                "type": "correct",
                "content": "/*eslint quotes: [\"error\", \"double\"]*/\n/*eslint-env es6*/\n\nvar double = \"double\";\nvar backtick = `back\ntick`;  // backticks are allowed due to newline\nvar backtick = tag`backtick`; // backticks are allowed due to tag"
            },
            {
                "type": "incorrect",
                "content": "/*eslint quotes: [\"error\", \"single\"]*/\n\nvar double = \"double\";\nvar unescaped = \"a string containing 'single' quotes\";"
            },
            {
                "type": "correct",
                "content": "/*eslint quotes: [\"error\", \"single\"]*/\n/*eslint-env es6*/\n\nvar single = 'single';\nvar backtick = `back${x}tick`; // backticks are allowed due to substitution"
            },
            {
                "type": "incorrect",
                "content": "/*eslint quotes: [\"error\", \"backtick\"]*/\n\nvar single = 'single';\nvar double = \"double\";\nvar unescaped = 'a string containing `backticks`';"
            },
            {
                "type": "correct",
                "content": "/*eslint quotes: [\"error\", \"backtick\"]*/\n/*eslint-env es6*/\n\nvar backtick = `backtick`;"
            },
            {
                "type": "correct",
                "content": "/*eslint quotes: [\"error\", \"double\", { \"avoidEscape\": true }]*/\n\nvar single = 'a string containing \"double\" quotes';"
            },
            {
                "type": "correct",
                "content": "/*eslint quotes: [\"error\", \"single\", { \"avoidEscape\": true }]*/\n\nvar double = \"a string containing 'single' quotes\";"
            },
            {
                "type": "correct",
                "content": "/*eslint quotes: [\"error\", \"backtick\", { \"avoidEscape\": true }]*/\n\nvar double = \"a string containing `backtick` quotes\""
            },
            {
                "type": "correct",
                "content": "/*eslint quotes: [\"error\", \"double\", { \"allowTemplateLiterals\": true }]*/\n\nvar double = \"double\";\nvar double = `double`;"
            },
            {
                "type": "correct",
                "content": "/*eslint quotes: [\"error\", \"single\", { \"allowTemplateLiterals\": true }]*/\n\nvar single = 'single';\nvar single = `single`;"
            }
        ]
    },
    {
        "name": "rest-spread-spacing",
        "url": "https://eslint.org/docs/latest/rules/rest-spread-spacing",
        "description": "Enforce spacing between rest and spread operators and their expressionsES2015 introduced the rest and spread operators, which expand an iterable structure into its individual parts. Some examples of their usage are as follows:In addition to the above, there is currently a proposal to add object rest and spread properties to the spec. They can be used as follows:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint rest-spread-spacing: [\"error\", \"never\"]*/\n\nfn(... args)\n[... arr, 4, 5, 6]\nlet [a, b, ... arr] = [1, 2, 3, 4, 5];\nfunction fn(... args) { console.log(args); }\nlet { x, y, ... z } = { x: 1, y: 2, a: 3, b: 4 };\nlet n = { x, y, ... z };"
            },
            {
                "type": "correct",
                "content": "/*eslint rest-spread-spacing: [\"error\", \"never\"]*/\n\nfn(...args)\n[...arr, 4, 5, 6]\nlet [a, b, ...arr] = [1, 2, 3, 4, 5];\nfunction fn(...args) { console.log(args); }\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nlet n = { x, y, ...z };"
            },
            {
                "type": "incorrect",
                "content": "/*eslint rest-spread-spacing:[\"error\", \"always\"]*/\n\nfn(...args)\n[...arr, 4, 5, 6]\nlet [a, b, ...arr] = [1, 2, 3, 4, 5];\nfunction fn(...args) { console.log(args); }\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nlet n = { x, y, ...z };"
            },
            {
                "type": "correct",
                "content": "/*eslint rest-spread-spacing: [\"error\", \"always\"]*/\n\nfn(... args)\n[... arr, 4, 5, 6]\nlet [a, b, ... arr] = [1, 2, 3, 4, 5];\nfunction fn(... args) { console.log(args); }\nlet { x, y, ... z } = { x: 1, y: 2, a: 3, b: 4 };\nlet n = { x, y, ... z };"
            }
        ]
    },
    {
        "name": "semi",
        "url": "https://eslint.org/docs/latest/rules/semi",
        "description": "Require or disallow semicolons instead of ASIJavaScript doesn’t require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as automatic semicolon insertion (ASI) and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:On the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nclass Foo {\n    bar = 1\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n\nclass Foo {\n    bar = 1;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n\nclass Foo {\n    bar = 1;\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n\nclass Foo {\n    bar = 1\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n\nfunction f() { bar(); baz() }\n\nclass C {\n    foo() { bar(); baz() }\n\n    static { bar(); baz() }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()"
            },
            {
                "type": "incorrect",
                "content": "/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()"
            }
        ]
    },
    {
        "name": "semi-spacing",
        "url": "https://eslint.org/docs/latest/rules/semi-spacing",
        "description": "Enforce consistent spacing before and after semicolonsJavaScript allows you to place unnecessary spaces before or after a semicolon.Disallowing or enforcing space around a semicolon can improve the readability of your program.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint semi-spacing: \"error\"*/\n\nvar foo ;\nvar foo;var bar;\nthrow new Error(\"error\") ;\nwhile (a) { break ; }\nfor (i = 0 ; i < 10 ; i++) {}\nfor (i = 0;i < 10;i++) {}"
            },
            {
                "type": "correct",
                "content": "/*eslint semi-spacing: \"error\"*/\n\nvar foo;\nvar foo; var bar;\nthrow new Error(\"error\");\nwhile (a) { break; }\nfor (i = 0; i < 10; i++) {}\nfor (;;) {}\nif (true) {;}\n;foo();"
            },
            {
                "type": "incorrect",
                "content": "/*eslint semi-spacing: [\"error\", { \"before\": true, \"after\": false }]*/\n\nvar foo;\nvar foo ; var bar;\nthrow new Error(\"error\");\nwhile (a) { break; }\nfor (i = 0;i < 10;i++) {}\nfor (i = 0; i < 10; i++) {}"
            },
            {
                "type": "correct",
                "content": "/*eslint semi-spacing: [\"error\", { \"before\": true, \"after\": false }]*/\n\nvar foo ;\nvar foo ;var bar ;\nthrow new Error(\"error\") ;\nwhile (a) {break ;}\nfor (i = 0 ;i < 10 ;i++) {}"
            }
        ]
    },
    {
        "name": "semi-style",
        "url": "https://eslint.org/docs/latest/rules/semi-style",
        "description": "Enforce location of semicolonsGenerally, semicolons are at the end of lines. However, in semicolon-less style, semicolons are at the beginning of lines. This rule enforces that semicolons are at the configured location.This rule reports line terminators around semicolons.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint semi-style: [\"error\", \"last\"]*/\n\nfoo()\n;[1, 2, 3].forEach(bar)\n\nfor (\n    var i = 0\n    ; i < 10\n    ; ++i\n) {\n    foo()\n}\n\nclass C {\n    static {\n        foo()\n        ;bar()\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint semi-style: [\"error\", \"last\"]*/\n\nfoo();\n[1, 2, 3].forEach(bar)\n\nfor (\n    var i = 0;\n    i < 10;\n    ++i\n) {\n    foo()\n}\n\nclass C {\n    static {\n        foo();\n        bar()\n    }\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint semi-style: [\"error\", \"first\"]*/\n\nfoo();\n[1, 2, 3].forEach(bar)\n\nfor (\n    var i = 0\n    ; i < 10\n    ; ++i\n) {\n    foo()\n}\n\nclass C {\n    static {\n        foo();\n        bar()\n    }\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint semi-style: [\"error\", \"first\"]*/\n\nfoo()\n;[1, 2, 3].forEach(bar)\n\nfor (\n    var i = 0;\n    i < 10;\n    ++i\n) {\n    foo()\n}\n\nclass C {\n    static {\n        foo()\n        ;bar()\n    }\n}"
            }
        ]
    },
    {
        "name": "space-before-blocks",
        "url": "https://eslint.org/docs/latest/rules/space-before-blocks",
        "description": "Enforce consistent spacing before blocksConsistency is an important part of any style guide. While it is a personal preference where to put the opening brace of blocks, it should be consistent across a whole project. Having an inconsistent style distracts the reader from seeing the important parts of the code.This rule will enforce consistency of spacing before blocks. It is only applied on blocks that don’t begin on a new line.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint space-before-blocks: \"error\"*/\n\nif (a){\n    b();\n}\n\nfunction a(){}\n\nfor (;;){\n    b();\n}\n\ntry {} catch(a){}\n\nclass Foo{\n  constructor(){}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint space-before-blocks: \"error\"*/\n\nif (a) {\n    b();\n}\n\nif (a) {\n    b();\n} else{ /*no error. this is checked by `keyword-spacing` rule.*/\n    c();\n}\n\nclass C {\n    static{} /*no error. this is checked by `keyword-spacing` rule.*/\n}\n\nfunction a() {}\n\nfor (;;) {\n    b();\n}\n\ntry {} catch(a) {}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-before-blocks: [\"error\", \"never\"]*/\n\nif (a) {\n    b();\n}\n\nfunction a() {}\n\nfor (;;) {\n    b();\n}\n\ntry {} catch(a) {}"
            },
            {
                "type": "correct",
                "content": "/*eslint space-before-blocks: [\"error\", \"never\"]*/\n\nif (a){\n    b();\n}\n\nfunction a(){}\n\nfor (;;){\n    b();\n}\n\ntry{} catch(a){}\n\nclass Foo{\n  constructor(){}\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-before-blocks: [\"error\", { \"functions\": \"never\", \"keywords\": \"always\", \"classes\": \"never\" }]*/\n/*eslint-env es6*/\n\nfunction a() {}\n\ntry {} catch(a){}\n\nclass Foo{\n  constructor() {}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint space-before-blocks: [\"error\", { \"functions\": \"never\", \"keywords\": \"always\", \"classes\": \"never\" }]*/\n/*eslint-env es6*/\n\nfor (;;) {\n  // ...\n}\n\ndescribe(function(){\n  // ...\n});\n\nclass Foo{\n  constructor(){}\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-before-blocks: [\"error\", { \"functions\": \"always\", \"keywords\": \"never\", \"classes\": \"never\" }]*/\n/*eslint-env es6*/\n\nfunction a(){}\n\ntry {} catch(a) {}\n\nclass Foo {\n  constructor(){}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint space-before-blocks: [\"error\", { \"functions\": \"always\", \"keywords\": \"never\", \"classes\": \"never\" }]*/\n/*eslint-env es6*/\n\nif (a){\n  b();\n}\n\nvar a = function() {}\n\nclass Foo{\n  constructor() {}\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-before-blocks: [\"error\", { \"functions\": \"never\", \"keywords\": \"never\", \"classes\": \"always\" }]*/\n/*eslint-env es6*/\n\nclass Foo{\n  constructor(){}\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint space-before-blocks: [\"error\", { \"functions\": \"never\", \"keywords\": \"never\", \"classes\": \"always\" }]*/\n/*eslint-env es6*/\n\nclass Foo {\n  constructor(){}\n}"
            }
        ]
    },
    {
        "name": "space-before-function-paren",
        "url": "https://eslint.org/docs/latest/rules/space-before-function-paren",
        "description": "Enforce consistent spacing before function definition opening parenthesisWhen formatting a function, whitespace is allowed between the function name or function keyword and the opening paren. Named functions also require a space between the function keyword and the function name, but anonymous functions require no whitespace. For example:Style guides may require a space after the function keyword for anonymous functions, while others specify no whitespace. Similarly, the space after a function name may or may not be required.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1"
            },
            {
                "type": "correct",
                "content": "/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1"
            },
            {
                "type": "correct",
                "content": "/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async(a) => await a"
            },
            {
                "type": "correct",
                "content": "/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async (a) => await a"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};"
            },
            {
                "type": "correct",
                "content": "/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function () {\n    // ...\n};\n\nfunction foo () {\n    // ...\n}\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};"
            }
        ]
    },
    {
        "name": "space-in-parens",
        "url": "https://eslint.org/docs/latest/rules/space-in-parens",
        "description": "Enforce consistent spacing inside parenthesesSome style guides require or disallow spaces inside of parentheses:This rule will enforce consistent spacing directly inside of parentheses, by disallowing or requiring one or more spaces to the right of ( and to the left of ).",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint space-in-parens: [\"error\", \"never\"]*/\n\nfoo( );\n\nfoo( 'bar');\nfoo('bar' );\nfoo( 'bar' );\n\nfoo( /* bar */ );\n\nvar foo = ( 1 + 2 ) * 3;\n( function () { return 'bar'; }() );"
            },
            {
                "type": "correct",
                "content": "/*eslint space-in-parens: [\"error\", \"never\"]*/\n\nfoo();\n\nfoo('bar');\n\nfoo(/* bar */);\n\nvar foo = (1 + 2) * 3;\n(function () { return 'bar'; }());"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-in-parens: [\"error\", \"always\"]*/\n\nfoo( 'bar');\nfoo('bar' );\nfoo('bar');\n\nfoo(/* bar */);\n\nvar foo = (1 + 2) * 3;\n(function () { return 'bar'; }());"
            },
            {
                "type": "correct",
                "content": "/*eslint space-in-parens: [\"error\", \"always\"]*/\n\nfoo();\nfoo( );\n\nfoo( 'bar' );\n\nfoo( /* bar */ );\n\nvar foo = ( 1 + 2 ) * 3;\n( function () { return 'bar'; }() );"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"{}\"] }]*/\n\nfoo({bar: 'baz'});\nfoo(1, {bar: 'baz'});"
            },
            {
                "type": "correct",
                "content": "/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"{}\"] }]*/\n\nfoo( {bar: 'baz'} );\nfoo(1, {bar: 'baz'} );"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"{}\"] }]*/\n\nfoo( {bar: 'baz'} );\nfoo( 1, {bar: 'baz'} );"
            },
            {
                "type": "correct",
                "content": "/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"{}\"] }]*/\n\nfoo({bar: 'baz'});\nfoo( 1, {bar: 'baz'});"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"[]\"] }]*/\n\nfoo([bar, baz]);\nfoo([bar, baz], 1);"
            },
            {
                "type": "correct",
                "content": "/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"[]\"] }]*/\n\nfoo( [bar, baz] );\nfoo( [bar, baz], 1);"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"[]\"] }]*/\n\nfoo( [bar, baz] );\nfoo( [bar, baz], 1 );"
            },
            {
                "type": "correct",
                "content": "/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"[]\"] }]*/\n\nfoo([bar, baz]);\nfoo([bar, baz], 1 );"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"()\"] }]*/\n\nfoo((1 + 2));\nfoo((1 + 2), 1);\nfoo(bar());"
            },
            {
                "type": "correct",
                "content": "/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"()\"] }]*/\n\nfoo( (1 + 2) );\nfoo( (1 + 2), 1);\nfoo(bar() );"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"()\"] }]*/\n\nfoo( ( 1 + 2 ) );\nfoo( ( 1 + 2 ), 1 );"
            },
            {
                "type": "correct",
                "content": "/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"()\"] }]*/\n\nfoo(( 1 + 2 ));\nfoo(( 1 + 2 ), 1 );"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"empty\"] }]*/\n\nfoo();"
            },
            {
                "type": "correct",
                "content": "/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"empty\"] }]*/\n\nfoo( );"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"empty\"] }]*/\n\nfoo( );"
            },
            {
                "type": "correct",
                "content": "/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"empty\"] }]*/\n\nfoo();"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"{}\", \"[]\"] }]*/\n\nbar( {bar:'baz'} );\nbaz( 1, [1,2] );\nfoo( {bar: 'baz'}, [1, 2] );"
            },
            {
                "type": "correct",
                "content": "/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"{}\", \"[]\"] }]*/\n\nbar({bar:'baz'});\nbaz( 1, [1,2]);\nfoo({bar: 'baz'}, [1, 2]);"
            }
        ]
    },
    {
        "name": "space-infix-ops",
        "url": "https://eslint.org/docs/latest/rules/space-infix-ops",
        "description": "Require spacing around infix operatorsWhile formatting preferences are very personal, a number of style guides require spaces around operators, such as:Proponents of this rule believe that it makes code easier to read and can more easily highlight potential errors, such as:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint space-infix-ops: \"error\"*/\n/*eslint-env es6*/\n\na+b\n\na+ b\n\na +b\n\na?b:c\n\nconst a={b:1};\n\nvar {a=0}=bar;\n\nfunction foo(a=0) { }"
            },
            {
                "type": "correct",
                "content": "/*eslint space-infix-ops: \"error\"*/\n/*eslint-env es6*/\n\na + b\n\na       + b\n\na ? b : c\n\nconst a = {b:1};\n\nvar {a = 0} = bar;\n\nfunction foo(a = 0) { }"
            }
        ]
    },
    {
        "name": "space-unary-ops",
        "url": "https://eslint.org/docs/latest/rules/space-unary-ops",
        "description": "Enforce consistent spacing before or after unary operatorsSome style guides require or disallow spaces before or after unary operators. This is mainly a stylistic issue, however, some JavaScript expressions can be written without spacing which makes it harder to read and maintain.This rule enforces consistency regarding the spaces after words unary operators and after/before nonwords unary operators.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint space-unary-ops: \"error\"*/\n\ntypeof!foo;\n\nvoid{foo:0};\n\nnew[foo][0];\n\ndelete(foo.bar);\n\n++ foo;\n\nfoo --;\n\n- foo;\n\n+ \"3\";"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-unary-ops: \"error\"*/\n/*eslint-env es6*/\n\nfunction *foo() {\n    yield(0)\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint space-unary-ops: \"error\"*/\n\nasync function foo() {\n    await(bar);\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint space-unary-ops: \"error\"*/\n\n// Word unary operator \"typeof\" is followed by a whitespace.\ntypeof !foo;\n\n// Word unary operator \"void\" is followed by a whitespace.\nvoid {foo:0};\n\n// Word unary operator \"new\" is followed by a whitespace.\nnew [foo][0];\n\n// Word unary operator \"delete\" is followed by a whitespace.\ndelete (foo.bar);\n\n// Unary operator \"++\" is not followed by whitespace.\n++foo;\n\n// Unary operator \"--\" is not preceded by whitespace.\nfoo--;\n\n// Unary operator \"-\" is not followed by whitespace.\n-foo;\n\n// Unary operator \"+\" is not followed by whitespace.\n+\"3\";"
            },
            {
                "type": "correct",
                "content": "/*eslint space-unary-ops: \"error\"*/\n/*eslint-env es6*/\n\nfunction *foo() {\n    yield (0)\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint space-unary-ops: \"error\"*/\n\nasync function foo() {\n    await (bar);\n}"
            }
        ]
    },
    {
        "name": "switch-colon-spacing",
        "url": "https://eslint.org/docs/latest/rules/switch-colon-spacing",
        "description": "Enforce spacing around colons of switch statementsSpacing around colons improves readability of case/default clauses.This rule controls spacing around colons of case and default clauses in switch statements. This rule does the check only if the consecutive tokens exist on the same line.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint switch-colon-spacing: \"error\"*/\n\nswitch (a) {\n    case 0 :break;\n    default :foo();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint switch-colon-spacing: \"error\"*/\n\nswitch (a) {\n    case 0: foo(); break;\n    case 1:\n        bar();\n        break;\n    default:\n        baz();\n        break;\n}"
            },
            {
                "type": "incorrect",
                "content": "/*eslint switch-colon-spacing: [\"error\", {\"after\": false, \"before\": true}]*/\n\nswitch (a) {\n    case 0: break;\n    default: foo();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint switch-colon-spacing: [\"error\", {\"after\": false, \"before\": true}]*/\n\nswitch (a) {\n    case 0 :foo(); break;\n    case 1 :\n        bar();\n        break;\n    default :\n        baz();\n        break;\n}"
            }
        ]
    },
    {
        "name": "template-curly-spacing",
        "url": "https://eslint.org/docs/latest/rules/template-curly-spacing",
        "description": "Require or disallow spacing around embedded expressions of template stringsWe can embed expressions in template strings with using a pair of ${ and }.This rule can force usage of spacing within the curly brace pair according to style guides.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint template-curly-spacing: \"error\"*/\n\n`hello, ${ people.name}!`;\n`hello, ${people.name }!`;\n\n`hello, ${ people.name }!`;"
            },
            {
                "type": "correct",
                "content": "/*eslint template-curly-spacing: \"error\"*/\n\n`hello, ${people.name}!`;\n\n`hello, ${\n    people.name\n}!`;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint template-curly-spacing: [\"error\", \"always\"]*/\n\n`hello, ${ people.name}!`;\n`hello, ${people.name }!`;\n\n`hello, ${people.name}!`;"
            },
            {
                "type": "correct",
                "content": "/*eslint template-curly-spacing: [\"error\", \"always\"]*/\n\n`hello, ${ people.name }!`;\n\n`hello, ${\n    people.name\n}!`;"
            }
        ]
    },
    {
        "name": "template-tag-spacing",
        "url": "https://eslint.org/docs/latest/rules/template-tag-spacing",
        "description": "Require or disallow spacing between template tags and their literalsWith ES6, it’s possible to create functions called tagged template literals where the function parameters consist of a template literal’s strings and expressions.When using tagged template literals, it’s possible to insert whitespace between the tag function and the template literal. Since this whitespace is optional, the following lines are equivalent:",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint template-tag-spacing: \"error\"*/\n\nfunc `Hello world`;"
            },
            {
                "type": "correct",
                "content": "/*eslint template-tag-spacing: \"error\"*/\n\nfunc`Hello world`;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint template-tag-spacing: [\"error\", \"always\"]*/\n\nfunc`Hello world`;"
            },
            {
                "type": "correct",
                "content": "/*eslint template-tag-spacing: [\"error\", \"always\"]*/\n\nfunc `Hello world`;"
            }
        ]
    },
    {
        "name": "unicode-bom",
        "url": "https://eslint.org/docs/latest/rules/unicode-bom",
        "description": "Require or disallow Unicode byte order mark (BOM)The Unicode Byte Order Mark (BOM) is used to specify whether code units are big endian or little endian. That is, whether the most significant or least significant bytes come first. UTF-8 does not require a BOM because byte ordering does not matter when characters are a single byte. Since UTF-8 is the dominant encoding of the web, we make \"never\" the default option.If the \"always\" option is used, this rule requires that files always begin with the Unicode BOM character U+FEFF. If \"never\" is used, files must never begin with U+FEFF.",
        "examples": [
            {
                "type": "correct",
                "content": "/*eslint unicode-bom: [\"error\", \"always\"]*/\n\nU+FEFF\nvar abc;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint unicode-bom: [\"error\", \"always\"]*/\n\nvar abc;"
            },
            {
                "type": "correct",
                "content": "/*eslint unicode-bom: [\"error\", \"never\"]*/\n\nvar abc;"
            },
            {
                "type": "incorrect",
                "content": "/*eslint unicode-bom: [\"error\", \"never\"]*/\n\nU+FEFF\nvar abc;"
            }
        ]
    },
    {
        "name": "wrap-iife",
        "url": "https://eslint.org/docs/latest/rules/wrap-iife",
        "description": "Require parentheses around immediate function invocationsYou can immediately invoke function expressions, but not function declarations. A common technique to create an immediately-invoked function expression (IIFE) is to wrap a function declaration in parentheses. The opening parentheses causes the contained function to be parsed as an expression, rather than a declaration.This rule requires all immediately-invoked function expressions to be wrapped in parentheses.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint wrap-iife: [\"error\", \"outside\"]*/\n\nvar x = function () { return { y: 1 };}(); // unwrapped\nvar x = (function () { return { y: 1 };})(); // wrapped function expression"
            },
            {
                "type": "correct",
                "content": "/*eslint wrap-iife: [\"error\", \"outside\"]*/\n\nvar x = (function () { return { y: 1 };}()); // wrapped call expression"
            },
            {
                "type": "incorrect",
                "content": "/*eslint wrap-iife: [\"error\", \"inside\"]*/\n\nvar x = function () { return { y: 1 };}(); // unwrapped\nvar x = (function () { return { y: 1 };}()); // wrapped call expression"
            },
            {
                "type": "correct",
                "content": "/*eslint wrap-iife: [\"error\", \"inside\"]*/\n\nvar x = (function () { return { y: 1 };})(); // wrapped function expression"
            },
            {
                "type": "incorrect",
                "content": "/*eslint wrap-iife: [\"error\", \"any\"]*/\n\nvar x = function () { return { y: 1 };}(); // unwrapped"
            },
            {
                "type": "correct",
                "content": "/*eslint wrap-iife: [\"error\", \"any\"]*/\n\nvar x = (function () { return { y: 1 };}()); // wrapped call expression\nvar x = (function () { return { y: 1 };})(); // wrapped function expression"
            },
            {
                "type": "incorrect",
                "content": "/* eslint wrap-iife: [2, \"inside\", { functionPrototypeMethods: true }] */\n\nvar x = function(){ foo(); }()\nvar x = (function(){ foo(); }())\nvar x = function(){ foo(); }.call(bar)\nvar x = (function(){ foo(); }.call(bar))"
            },
            {
                "type": "correct",
                "content": "/* eslint wrap-iife: [2, \"inside\", { functionPrototypeMethods: true }] */\n\nvar x = (function(){ foo(); })()\nvar x = (function(){ foo(); }).call(bar)"
            }
        ]
    },
    {
        "name": "wrap-regex",
        "url": "https://eslint.org/docs/latest/rules/wrap-regex",
        "description": "Require parenthesis around regex literalsWhen a regular expression is used in certain situations, it can end up looking like a division operator. For example:This is used to disambiguate the slash operator and facilitates more readable code.",
        "examples": [
            {
                "type": "incorrect",
                "content": "/*eslint wrap-regex: \"error\"*/\n\nfunction a() {\n    return /foo/.test(\"bar\");\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint wrap-regex: \"error\"*/\n\nfunction a() {\n    return (/foo/).test(\"bar\");\n}"
            }
        ]
    },
    {
        "name": "yield-star-spacing",
        "url": "https://eslint.org/docs/latest/rules/yield-star-spacing",
        "description": "Require or disallow spacing around the * in yield* expressionsThis rule enforces spacing around the * in yield* expressions.The rule takes one option, an object, which has two keys before and after having boolean values true or false.",
        "examples": [
            {
                "type": "correct",
                "content": "/*eslint yield-star-spacing: [\"error\", \"after\"]*/\n/*eslint-env es6*/\n\nfunction* generator() {\n  yield* other();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint yield-star-spacing: [\"error\", \"before\"]*/\n/*eslint-env es6*/\n\nfunction *generator() {\n  yield *other();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint yield-star-spacing: [\"error\", \"both\"]*/\n/*eslint-env es6*/\n\nfunction * generator() {\n  yield * other();\n}"
            },
            {
                "type": "correct",
                "content": "/*eslint yield-star-spacing: [\"error\", \"neither\"]*/\n/*eslint-env es6*/\n\nfunction*generator() {\n  yield*other();\n}"
            }
        ]
    }
]